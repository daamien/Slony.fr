<?xml version="1.0" encoding="UTF-8"?>
<!-- DerniÃšre modification
     le       $Date$
     par      $Author$
     rÃ©vision $Revision$ -->

<sect1 id="subscribenodes"> <title>Enregistrement des serveurs</title>

<indexterm><primary>>Enregistrement des serveurs</primary></indexterm>

<para>Avant d'enregistrer un serveur à un ensemble, assurez-vous d'avoir
<xref linkend="slon"/> un processus pour chacun des deux parties à savoir le fournisseur et pour le nouveau noeud de souscription. Si les slons respectifs ne sont pas encours d'exécution, alors il ne se passera rien,  et vous battrez votre tête contre un mur essayant de comprendre pourquoi.</para>

<para>Enregistrer un serveur à un jeux de serveurs est fait en publiant la <xref
linkend="slonik"/> commande <xref linkend="stmtsubscribeset"/>. Il peut sembler tentant d'essayer de souscrire plusieurs noeuds à un ensemble dans un bloc simple d'essai comme ceci :

<programlisting>
try {
  echo 'Subscribing sets';
  subscrifbe set (id = 1, provider=1, receiver=2, forward=yes);
  subscribe set (id = 1, provider=1, receiver=3, forward=yes);
  subscribe set (id = 1, provider=1, receiver=4, forward=yes);
} on error {
  echo 'Enregistrement du jeu des serveurs : impossible!';
  exit -1;
}
</programlisting></para>


<para> Mais vous êtes juste en train de vous demander quel est le souci en enregistrant les jeux des serveurs de cette façon. La méthode appropriée exige de procéder à l'enregistrement des serveurs, à raison d'un seul à la fois, tout en examinant le journal de l'instance de la base de donnée et avant d'entamer le prochain enregistrement. Il est également intéressant de noter que le
<quote>succès</quote> dans le ci-dessus <xref linkend="slonik"/> essai
de bloc, n'implique pas que les noeuds 2, 3, et 4 soient tous enregistrés avec succès. Il indique simplement que les commandes de slonik ont été avec succès reçues par <application>slon</application> fonctionnant
sur le noeud d'origine.</para>

<para>Un cas typique de problème qui peut surgir est qu'un abonné en cascade, recherche un fournisseur qui n'est pas encore prêt.
Dans ce cas d'échec, le noeud souscripteur ne deviendra <emphasis>jamais</emphasis>
l'abonné. Il obtiendra une attente <quote>bloquée</quote> pour que l'évènement attendu
survienne. Les autres noeuds seront persuadés que, ce noeud bloqué, s'est enregistré correctement (parce que aucune erreur ne leur remonte); la demande de désabonner le noeud sera <quote>bloqué</quote> car le noeud en question est coincé en attente d'enregistrement.</para>

<para>Lorsque vous enregistrez un noeud à un jeu de noeuds, vous devriez voir quelque chose de ce genre dans les logs de <application>slon</application> pour le noeud fournisseur:

<screen>
DEBUG2 remoteWorkerThread_3: Received event 3,1059 SUBSCRIBE_SET
</screen>
</para>
<para> Vous devriez également commencer à voir des entrées de notation comme ceci dans les notations de 
<application>slon</application>  pour le noeud de souscription:

<screen>
DEBUG2 remoteWorkerThread_1: copy table public.my_table
</screen>
</para>
<para>Il peut prendre un certain temps, pour de plus grandes tables, d'être copié du noeud de fournisseur au nouvel abonné. Si vous vérifiez la table de pg_stat_activity sur le noeud de fournisseur, vous devriez voir une requête qui copie la table vers stdout.
</para>
<para>La table <envar>sl_subscribe</envar> pour le fournisseur comme pour le nouveau souscripteur,devra contenir un enregistrement pour le nouveau abonnement:

<screen>
 sub_set | sub_provider | sub_receiver | sub_forward | sub_active
---------+--------------+--------------+-------------+------------
      1  |            1 |            2 |           t |         t
</screen>
</para>
<para>Un ultime test est d'insérer un enregistrement dans une des tables répliquées depuis le noeud d'origine, et de vérifier que cet enregistrement se copie bien chez le souscripteur.
</para>

<warning> <para> Si vous créez et souscrivez à un jeu de noeud qui ne contient aucune table, cela peut mener à une situation qui empêchera la réplication de se faire. </para>

<para> Notez que ce bug est notifié comme  &slony1; 1.1.5 </para>

<para> Si un abonné particulier est seulement alimenté par une séquence d'ordre d'un de ces fournisseurs, la requête qui collecte 
l'évènement<command>SYNC</command> ne sera pas correctement crée, et vous pouvez voir une erreur similaire à la suivante :
</para>
<screen>
2007-04-13 07:11:28 PDT ERROR remoteWorkerThread_11: "declare LOG
cursor for select log_origin, log_xid, log_tableid, log_actionseq,
log_cmdtype, log_cmddata from "_T1".sl_log_1 where log_origin = 11 and
( order by log_actionseq; " PGRES_FATAL_ERROR ERROR: syntax error at
or near "order" at character 162
</screen>

<para> La fonction <xref
linkend="function.subscribeset-integer-integer-integer-boolean"/> va générer
un avertissement si un jeu de réplication donné, ne connais pas des quelquonc tables à répliquer, comme l'exemple suivant le montre.
</para>

<screen>
cbbrowne@dba2:/tmp> cat create_empty_set.slonik
cluster name = T1;
node 11 admin conninfo = 'dbname=slony_test1';
node 22 admin conninfo = 'dbname=slony_test2';

create set (id = 255, origin = 11, comment='blank empty set');
subscribe set (id=255, provider = 11, receiver = 22, forward = false);
</screen>

<para> Ceci mène au message d'avertissement suivant : </para>

<screen>
bbrowne@dba2:/tmp> slonik create_empty_set.slonik
create_empty_set.slonik:6: NOTICE:  subscribeSet:: set 255 has no tables
- risk of problems - see bug 1226
create_empty_set.slonik:6: NOTICE: 
http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1226
cbbrowne@dba2:/tmp>
</screen>
</warning>
</sect1>
