<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
	le       $Date$
	par      $Author$
	révision $Revision$ -->

<sect1 id="requirements">
	<title>Pré requis système</title>

	<para>
		N'importe quelle plate forme capable de faire tourner
		&postgres;
		devrait être capable, en principe, de faire tourner
		&slony1;.
	</para>

	<indexterm>
		<primary>
			plates formes sur lesquelles
			&slony1;
			tourne
		</primary>
	</indexterm>

	<para>
		Les plates formes ayant été testées spécifiquement à ce jour pour cette release
		sont FreeBSD-4X-i368, FreeBSD-5X-i386,FreeBSD-5X-alpha, OS-X-10.3,
		Linux-2.4X-i386 Linux-2.6X-i386, Linux-2.6X-amd64,
		<trademark>Solaris</trademark>
		-2.8-SPARC,
		<trademark>Solaris</trademark>
		-2.9-SPARC, AIX 5.1, OpenBSD-3.5-sparc64 et
		&windows;
		2000, XP et 2003 (32 bit).
	</para>

	<sect2>
		<title>
			&slony1;
			Dépendances logicielles
		</title>

		<indexterm>
			<primary>Dépendances logicielles</primary>
		</indexterm>

		<para>
			A ce jour,
			&slony1;
			<emphasis>
				de la même façon que
				&postgres;
			</emphasis>
			nécessite d'être compilé depuis ses sources sur votre site.
		</para>

		<para>
			Afin de compiler
			&slony1;, vous avez besoin des outils suivants :

			<itemizedlist>
				<listitem>
					<para>
						GNU make. Les autres programmes make ne fonctionnent pas. GNU
						make est souvent installé sous le nom de
						<command>gmake</command>
						; qui sera référencé sous ce nom tout au long de ce document. (Sur les systèmes linux, GNU
						make est le make par defaut, et se nomme
						<command>make</command>
						) Pour tester si votre make est GNU make entrez
						<command>make version</command>
						. La version 3.76 ou supérieure convient; les versions antérieures ne conviennent pas.
					</para>
				</listitem>

				<listitem>
					<para>
						Vous avez besoin du compilateur C ISO/ANSI. Les versions
						récentes de
						<application>GCC</application>
						fonctionnent.
					</para>
				</listitem>

				<listitem>
					<para>
						Vous avez également besoin d'une version				
						<emphasis>source</emphasis>
						récente de &postgres;.
						&slony1;
						dépend du support namespace, nécessitant une
						version 7.3.3 de
						&postgres;
						ou plus récente pour pouvoir compiler et utiliser
						&slony1;.
					</para>

					<para>
						Les versions antérieures de
						&postgres;
						<emphasis>ne sont pas</emphasis>
						supportées, mais notez qu'un utilisateur a
						<quote>forcé</quote>
						l'utilisation de &slony1;
						dans le cadre d'une migration d'une version 7.2 vers une version 7.4; voir
						<link linkend="v72upgrade">
							&postgres;
							7.2 notes
						</link>
						.
					</para>

					<para>
						Les versions de
						&postgres;
						antérieures à la 7.4.8 peuvent rencontrer une requête sans fin
						conduisant à un problème de
						<link linkend="dupkey">
							<quote>duplicate keys</quote>
						</link>
						, vous devrez alors envisager une mise à jour pour éviter ce type d'erreur.
					</para>

					<para>
						Si vous utiliser une version de
						&postgres;
						antérieure à la version 8.0, vous devez vous assurer que
						les fichiers d'en-tête de serveur sont installés. Si
						vous installez depuis les sources, cela se fait par la
						commande
						<command>make install-all-headers</command>
						. Sinon, vous rencontrerez le problème
						<link linkend="missingheaders">
							missing headers for libpqserver
						</link>
						décrit dans le FAQ.
					</para>

					<para>
						Si vous utilisez les versions 8.1.0 à 8.1.3,
						un bug (corrigé en 8.1.4) empêche la fonction
						<xref linkend="stmtupdatefunctions" />
						de s'exécuter correctement. Pour plus de détails, voir
						<xref linkend="FAQ" />
						,
						<link linkend="pg81funs">
		
							&postgres;
							8.1.[0-3]
						</link>
						.
					</para>

				</listitem>

				<listitem>
					<para>
						Les packages GNU peuvent être inclus dans le packaging standard
						de votre système d'exploitation, ou doivent être recherchés sur votre
						miroir local GNU (voir
						<ulink
							url="http://www.gnu.org/order/ftp.html">
							http://www.gnu.org/order/ftp.html
						</ulink>
						pour une liste) ou
						<ulink url="ftp://ftp.gnu.org/gnu">
							ftp://ftp.gnu.org/gnu
						</ulink>
						.)
					</para>
				</listitem>

				<listitem>
					<para>
						Si vous devez obtenir les sources
						&postgres;
						, vous pouvez les télécharger depuis votre miroir
						&postgres;
						favori. Voir
						<ulink
							url="http://www.postgresql.org/mirrors-www.html">
							http://www.postgresql.org/mirrors-www.html
						</ulink>
						pour une liste.
					</para>
				</listitem>

				<listitem>
					<para>
						Cette documentation est écrite en SGML avec
						<ulink url="http://docbook.com/">DocBook</ulink>
						, et peut être traduite dans de nombreux formats
						incluant le HTML, le RTF, et le PDF en utilisant des outils 
						<ulink url="http://docbook.sourceforge.net/">
							dans le repository DocBook
						</ulink>
						avec
						<ulink url="http://openjade.sourceforge.net/">
							OpenJade.
						</ulink>
					</para>
				</listitem>

				<listitem>
					<para>
						Sous
						&windows;
						aurez aussi besoin de la boîte à outils
						<ulink
							url="http://www.postgresql.org/docs/faqs.FAQ_MINGW.html">
							MinGW/Msys
						</ulink>
						pour compiler les versions 8.0 et supérieures de
						&postgres;
						. De plus, vous devez installer
						<ulink
							url="http://sourceware.org/pthreads-win32/">
							pthreads-win32 2.x
						</ulink>
						.
					</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>
			Assurez-vous de disposer de suffisamment d'espace libre. Vous
			aurez besoin d'environ 5MB pour la distribution des sources pendant la compilation
			et l'installation.
		</para>

		<note>
			<para>
				Dans la version 1.1 de
				&slony1;
				, il est possible de compiler
				&slony1;
				séparemment de
				&postgres;, rendant libres les distributions
				<productname>Linux</productname>
				et
				<productname>FreeBSD</productname>
				d'inclure des packages binaires précompilés pour
				&slony1;. Si de tels packages ne sont pas disponibles, vous devez
				vous préparer à compiler
				&slony1;
				par vous-même.
			</para>
		</note>
	</sect2>

	<sect2>
		<title>
			Obtenir les sources de
			&slony1;
		</title>

		<indexterm>
			<primary>
				téléchargement des sources de
				&slony1;
			</primary>
		</indexterm>

		<para>
			Vous pouvez obtenir les sources de
			&slony1;
			à partir de l'url
			<ulink url="http://main.slony.info/downloads/">
				http://main.slony.info/downloads/
			</ulink>
		</para>

	</sect2>

	<sect2 id="encoding">
		<title>Encodage base de données</title>

		<indexterm>
			<primary>Encodage base de données</primary>
		</indexterm>

		<para>
			
			Les bases de données &postgres; peuvent être créés avec plusieurs types d'encodage,
			défini par la commande
			<command>
				createdb --encoding=$ENCODING databasename
			</command>
			.
			&slony1;
			suppose que les bases de données utilisent des encodages
			<emphasis>identiques.</emphasis>
		</para>

		<para>
			Des encodages
			<quote>très proches</quote>
			peuvent ne provoquer aucun problème.
			Par exemple, si le système d'origine utilise
			<envar>LATIN1</envar>
			et un abonné
			<envar>SQL_ASCII</envar>
			et un autre abonné
			<envar>UNICODE</envar>
			, et que votre application ne dépasse pas les conditions limites de frontière
			entre ces différents encodages, vous pouvez ne jamais rencontrer
			de problème.
		</para>

		<para>
			Dans la version 8.1 de
			&postgres;
			, des modifications ont été apportées à l'encodage
			<envar>UNICODE</envar>
			car les versions précédentes acceptaient des encodages invalides.
			Cela pouvait conduire à des
			<link linkend="faqunicode">problèmes de replication.</link>
		</para>

		<para>
			Notez que si l'encodage client (configuré soit
			dans
			<filename>postgresql.conf</filename>
			, par le paramètre
			<envar>client_encoding</envar>
			, ou soit par la commande
			<application>psql</application>
			<command>\encoding</command>
			, ou sous
			<application>psql</application>
			par la variable interne
			<envar>ENCODING</envar>
			) diffère de l'encodage serveur, cette différence peut conduire
			&slony1;
			a être incapable de répliquer les caractères supportés par l'encodage
			client et non pas par celui du serveur.
		</para>

	</sect2>

	<sect2 id="times">
		<title>Synchronisation horloge</title>

		<indexterm>
			<primary>Synchronisation horloge</primary>
		</indexterm>

		<para>
			Tous les serveurs utilisés dans le cluster de réplication doivent avoir
			leurs horloges internes synchronisées. Cela garantie que
			<xref linkend="slon" />
			ne génère pas d'erreur indiquant qu'un
			abonné est en avance par rapport à son fournisseur pendant
			la réplication. L'interprétation des logs sur des serveurs ayant une idée différente du temps
			est source de confusion et de frustration.
			Il est recommandé de faire tourner le démon
			<application>ntpd</application>
			sur tous les noeuds, où les noeuds abonnés utilisent le noeud
			<quote>maître</quote>
			comme serveur de temps.
		</para>

		<para>
			Il est possible pour
			&slony1;
			de fonctionner avec des différences de temps,
			mais avoir des systèmes
			<quote>synchonisés</quote>
			est normalement très important pour les applications distribuées.
		</para>

		<para>
			Voir
			<ulink url="http://www.ntp.org/">www.ntp.org</ulink>
			pour plus de détail au sujet de NTP (Network Time Protocol).
		</para>

		<para>
			Quelques utilisateurs ont reporté des problèmes
			lors de l'utilisation de certaines zones de temps, non reconnues par
			&postgres;
			.
			<itemizedlist>

				<listitem>
					<para>
						Sur
						<productname>AIX</productname>
						,
						<command>
							<envar>TZ</envar>
							=CUT0
						</command>
						était non reconnu, conduisant à des échecs d'appels système lors de la
						recherche de timestamps.
					</para>

					<para>
						<command>CUT0</command>
						est une variante pour décrire
						<command>UTC</command>
					</para>
				</listitem>

				<listitem>
					<para>
						Quelques zones de temps ne sont pas encore incluses
						dans
						&postgres;.
					</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>
			Dans tous les cas, ce qui semble être communément une 
			<quote>bonne pratique</quote>
			avec
			&slony1;
			(et, pour nous
			&postgres;) est d'utiliser pour l'utilisateur postmaster et/ou l'utilisateur sous lequel
			<application>slon</application>
			tourne
			<command>
				<envar>TZ</envar>
				=UTC
			</command>
			ou
			<command>
				<envar>TZ</envar>
				=GMT
			</command>
			. Ces zones de temps sont supportées de manière
			<emphasis>sûres</emphasis>
			par n'importe quelle plate-forme, ont le mérite par rapport à des timezones
			<quote>locaux</quote>
			de ne jamais diverger par rapport aux changements heures été-hiver.
		</para>

	</sect2>

	<sect2>
		<title>Connexions réseau</title>

		<indexterm>
			<primary>Connexions réseau</primary>
		</indexterm>

		<para>
			Il est nécessaire que les noeuds devant être répliqués entre eux aient des communications réseau
			<emphasis>bidirectionnelles</emphasis>
			entre les instances
			&postgres;
			. Ainsi, si le noeud B est en train de répliquer les données du noeud A
			, il est nécessaire qu'il y ai un chemin de A vers B et de B vers A.
			Il est recommandé que, dans la mesure du possible, tous les
			noeuds du cluster
			&slony1;
			permettent ce type de communication bidirectionnelle
			de n'importe quel noeud du cluster vers n'importe quel autre noeud du cluster.
		</para>

		<para>
			Pour faciliter la configuration, les adresses réseau devraient être
			idéalement identiques à travers tous les noeuds.
			<xref linkend="stmtstorepath" />
			leur permet d'être différentes, mais le maintien de ces différents paths
			pointant sur le même serveur peut devenir problématique.
		</para>

		<para>
			Un contournement possible de cela, dans les environnements où
			les règles de firewall sont particulièrement difficiles à implémenter, peut
			être d'établir des tunnels SSH
			<ulink
				url="http://www.brandonhutchinson.com/ssh_tunnelling.html"
				id="tunnelling">
				SSH Tunnels
			</ulink>
			crés sur chaque host permettant un accès distant
			au travers d'une adresse IP locale telle 127.0.0.1, en utilisant un
			port différent pour chaque destination.
		</para>

		<para>
			Notez que
			<application>slonik</application>
			et les instances
			<application>slon</application>
			ne nécessitent pas de connexions ou de protocoles spéciaux pour
			communiquer ensemble; ils nécessitent simplement un accès aux bases de données
			&postgres;
			, en s'y connectant comme
			<quote>super utilisateur</quote>
			<link linkend="morethansuper">
				capable de mettre à jour les tables du système.
			</link>
		</para>

		<para>
			Une conséquence d'un tel modèle de communication est que
			le réseau entier dans lequel un cluster
			&slony1;
			opère doit être sécurisé.
			Si une des bases de données du cluster ne peut être considérée
			comme sécurisée, cela représente une vulnérabilité pour tout le cluster.
			De la même manière que dans un système
			<quote>peer-to-peer</quote>
			,
			<emphasis>n'importe quel</emphasis>
			host est capable d'envoyer un évènement de réplication
			affectant tout le cluster. Ainsi, les règles de sécurité du cluster
			doivent être celles du noeud le plus
			<emphasis>faible</emphasis>
			. Faire tourner
			&slony1;
			à une localisation qui ne peut être considérée comme sécurisée
			compromet la sécurité du cluster dans son ensemble.
		</para>

		<para>
			Une nouvelle fonctionnalité de
			&slony1;
			version 1.1 est que les mises à jour pour un jeu de réplication particulier
			peuvent être sérialisées via le schéma
			&logshiplink;. La donnée enregistrée dans
			<envar>sl_log_1</envar>
			et
			<envar>sl_log_2</envar>
			est aussi écrite dans des fichiers log sur disque. Ces fichiers peuvent
			ensuite être transmis de n'importe quelle manière
			via scp, FTP, écrits sur DVD-ROMs puis adressés par messagerie, ou, pourquoi pas, en les enregistrant sur
			<quote>une clé USB</quote>
			permettant l'équivalence d'une
			<ulink url="http://www.faqs.org/rfcs/rfc1149.html">
				transmission de diagramme IP on avian carriers - RFC
				1149.
			</ulink>
			Quelquesoit le mécanisme de transmission, cela permet un seul accès de communication
			tel que les abonnés utilisant le log shipping ne nécessitent aucun accès
			aux autres noeuds
			&slony1;
			.
		</para>

	</sect2>
</sect1>
