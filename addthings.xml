<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="addthings">
<title>Une vue des taches  &slony1;</title>

<indexterm><primary>ajouter des objets à la réplication</primary></indexterm>

<para>Vous découvrirez peut-être que vous avez oubliez des choses que 
vous vouliez répliquer.</para>

<para>En général, on peut très aisément y remédier. Cette section propose
une  <quote>tour d'horizon</quote> des moyens pour répondre à la 
question <quote>Comment réaliser la tache <emphasis>X</emphasis> avec &slony1;?</quote>, pour différente valeur de <emphasis>X</emphasis>.</para>

<para>On ne peut pas utiliser directement les commandes 
<xref linkend="slonik"/> <xref linkend="stmtsetaddtable"/> 
ou <xref linkend="stmtsetaddsequence"/> pour ajouter des 
tables et des séquences à un ensemble de réplication en 
cours de fonctionnement; on doit au contraire créer un nouvel 
ensemble de réplication. Un fois que ce nouvel ensemble est répliqué
à l'identique ( c'est à dire les fournisseurs et abonnés sont 
<emphasis>entièrement identiques</emphasis> à ceux de l'ensemble que 
l'on veut compléter), les deux ensembles peuvent être fusionnés
avec la commande <xref
linkend="stmtmergeset"/>.</para>

<para>Jusqu'à la version 1.0.2 (incluse), il existait des risques
potentiels si <xref linkend="stmtmergeset"/> était lancée alors
que d'autres événements  de type abonnement étaient en attente;
des confusions pouvaient se produire sur les noeuds ayant ces 
événements en attente.

Ce problème fut résolu avec la version 1.0.5.  Jusqu'à la version 1.2.1,
il existait toujours un problème avec <xref linkend="stmtmergeset"/>,
si la commande était lancée avant que tous les abonnements soient complets,
des <quote>perturbations</quote> pouvaient apparaitre sur les noeuds 
où l'activité d'abonnement n'était pas terminée. </para>

<para> Notez que si vous ajoutez des noeuds, vous devez également ajouter
les déclarations  <xref linkend="stmtstorepath"/> pour indiquer comment
les noeuds communiquent entre eux, et les déclarations  <xref linkend="stmtstorelisten"/>
pour configurer le  <quote>réseau de communications</quote> correspondant.
Voir le chapitre <xref linkend="listenpaths"/> pour plus de détails.
</para>

<para>Il est conseillé d'être très prudent lorsque l'on ajoute des noeuds et des 
voies de communications. Par exemple, soumettre de multiples demandes 
d'abonnements à un ensemble donné dans un script  <xref linkend="slonik"/> 
finit mal, en général. Si il est <emphasis>vraiment</emphasis> nécessaire 
d'automatiser cette étape, il est préférable de soumettre des requêtes
<xref linkend="stmtwaitevent"/> entre chaque requête d'abonnement pour 
que le script  <xref linkend="slonik"/> attende qu'un abonnement soit
complet avant de lancer le suivant..</para>

<para>Mais en général, il est plus facile de gérer les reconfigurations 
complexes en s'assurant qu'un changement a été parfaitement réussi avant 
de passer au suivant. Il est beaucoup plus simple de corriger un problème
unique que de réparer les dégats provoqués par l'interaction erronée de cing commandes
successives.<</para>

<para> Voici un ensemble de  <quote>recettes</quote> pour réaliser 
différentes modifications sur la configuration de la réplication :</para>

<sect2><title> Ajouter une table dans le cluster de réplication </title>

<indexterm><primary> ajouter une table dans le cluster de réplication </primary></indexterm>

<para> &slony1; ne vous permet pas d'ajouter une table dans un ensemblde de
qui est déjà en cours de réplication. En principe, c'est certainement 
<emphasis>possible</emphasis>; mais cela implique l'événement SET_ADD_TABLE 
produise le code adéquat à partir de l'événement SUBSCRIBE_SET invoqué
pour analyser la table. Cela compliquerait de manière significative et regrettable
la logique de tous ces composants, donc ce n'est pas permis. </para>

<para>En contrepartie, vous devez procéder de la manière suivante :</para>

<itemizedlist>
<listitem><para> Ajouter la nouvelle table sur chaque noeud. </para>

<para> En principe, le script <xref linkend="stmtddlscript"/> peut être
utilisé pour cela, mais en réalité ce provoque des <link linkend="locking"> 
problèmes d'inter-blocages </link> et cela nécessite la modification de 
<emphasis>toutes</emphasis> les tables dans l'ensemble de réplication 
existant, sur <emphasis>tous</emphasis> les noeuds, ce qui fait que 
<xref linkend="stmtddlscript"/> est une approche peu attrayante sur un 
serveur chargé. Ceci brise la règle de &slony1; qui dit qu' <quote>il n'est pas
nécessaire d'interrompre l'activité normale pour ajouter la réplication.</quote>
</para>

<para> A contrario, vous pouvez ajouter la table via 
<application>psql</application> sur chaque noeud.

<n/para> </listitem>

<listitem><para> Créer un nouvel ensemble de réplication avec <xref linkend="stmtcreateset"/>
</para></listitem>
<listitem><para> 
Ajouter la table dans le nouvel ensemble avec <xref linkend="stmtsetaddtable"/> 
</para></listitem>

<listitem><para> Demander l'abonnement de ce nouvel ensemble avec <xref
linkend="stmtsubscribeset"/>. Si il existe plusieurs noeuds, vous devez
utiliser <xref linkend="stmtsubscribeset"/> une fois pour chaque noeud
que vous voulez abonner.  </para></listitem>

<listitem><para> Si vous voulez savoir de manière déterministe, si 
un abonnement est complet, vous devez soumettre pour chaque abonnement
un script slonik qui ressemble à cela :

<screen>
SUBSCRIBE SET (ID=1, PROVIDER=1, RECEIVER=2);
WAIT FOR EVENT (ORIGIN=2, CONFIRMED = 1);
SYNC(ID = 1);
WAIT FOR EVENT (ORIGIN=1, CONFIRMED=2);
</screen></para>
</listitem>

<listitem><para> Une fois que les abonnements sont configurés
de manière à ce que les abonnements du nouvel ensemble soit identiques
à ceux de l'ancien ensemble, vous pouvez fusionner le nouveau et l'ancien 
avec la commande <xref
linkend="stmtmergeset"/> </para></listitem>
</itemizedlist>
</sect2>

<sect2><title> Comment ajouter une colonne dans une table répliquée </title>

<indexterm><primary> ajouter des colonnes dans une table </primary></indexterm>

<para> Cette réponse est la même que pour la question <quote>Comment
renommer des colonnes dans une table répliquée ?</quote>, et plus généralement
au autres questions du type <quote>Comment modifier la définition 
de tables répliquées ?</quote></para>

<para>Si vous changez la <quote>shape</quote> d'une table répliquée, vous devez le 
faire au même instant dans le <quote>flux de transaction</quote> sur tous les noeuds
qui sont abonnés à l'ensemble qui contient la table.</para>

<para> Ainsi, la méthode pour consiste à construire un script SQL
composé des changements DDL et de le soumettre à tous les noeuds 
via la commande Slonik <xref linkend="stmtddlscript"/>.</para>

<para> Il existe une alternative, si vous avec installé les <link linkend="altperl">
scripts altperl</link>, vous pouvez utiliser <command>slonik_execute_script</command>
pour cela : </para>

<para> <command> slonik_execute_script [options] numero_de_l_ensemble
full_path_to_sql_script_file </command></para>

<para> Tapez la commande <command>slonik_execute_script -h</command> pour 
plus d'information; notez que ce script utilise <xref linkend="stmtddlscript"/>. 
</para>

<para> Il y a de nombreux <quote>points délicats</quote> à noter...</para>

<itemizedlist>
<listitem><para> Vous <emphasis>ne devez absolument jamais</emphasis> inclure
des commandes de controle de transaction, notamment <command>BEGIN</command>
et <command>COMMIT</command>, à l'intérieur de ces scripts. &slony1;
encapsule les scripts DDL avec une paire <command>BEGIN</command>/<command>COMMIT</command> 
; ajouter de opérateur de controle de transaction supplémentaire 
implique que des parties des ordres DDL seront <quote>committés</quote>
en dehors du controle de &slony1; </para></listitem>

<listitem><para> Avant la  version 1.2, il était nécessaire d'être 
extrêmement restrictif sur ce qu'on envoyait au script 
<xref linkend="stmtddlscript"/>. </para>

<para> Il était interdit de placer du texte <command>'entre quotes'</command> 
dans le script, car cela l'empéchait d'être stocké et transmis correctement
. A partir de la version 1.2, les quotes sont correctement prises en compte. </para>

<para> Si vous soumettez une séries d'order DDL, les derniers
ne peuvent pas faire référence aux objets créés par les premiers,
car tous les ordres sont soumis dans un requête unique,
dont le plan d'execution est basé sur l'état de la base de donnée
au <emphasis>début</emphasis>, avant que les modifications ne soient
effectuées. À partir de la version 1.2, il y a 12 ordres SQL, chacun est soumis
individuellement, ainsi la commande <command> alter table x add column c1
integer; </command> peut désormais être suivie par <command> alter table x
alter column c1 set not null; </command>.</para></listitem>

</itemizedlist>
</sect2>

<sect2><title> Comment supprimer la réplication sur un noeud</title>

<para> Vous devez supprimer les différents composants &slony1;
connectés à la base.</para>

<para> Considérons, un instant, que nous faisons cela pour un noeud. 
Si vous avez de multiples noeuds, vous devrez répéter ces étapes
autant de fois que nécessaire.</para>

<para> Les composants à retirer : </para>
<itemizedlist>

<listitem><para>Triggers de logs / Triggers de blocage de mises à jour

</para></listitem>
<listitem><para> Le schéma <quote>cluster</quote> contenant les tables &slony1;
qui indiquent l'état du noeud et diverses procédures stockées
</para></listitem>
<listitem><para> Le processus &lslon; qui gère le noeud </para></listitem>
<listitem><para> Accessoirement, les scripts SQL, les scripts pl/pgsql, 
et les binaires &slony1; qui font partie de la compilation de &postgres;.
(Bien sûr, cela complique la tache si vous souhaitez redémarrer la réplication;
il est peu probable que vous ayez besoin de supprimer ces fichiers...)
</para></listitem>
</itemizedlist>

<para> Comment effectuer facilement la suppression</para>
<itemizedlist>

<listitem><para> Vous pouvez utiliser la commande Slonik <xref linkend="stmtdropnode"/>
pour supprimer un noeud du cluster. Ceci provoquera la suppression
des triggers et tout ce qui se trouve dans schéma cluster.
Le processus <xref linkend="slon"/> sera automatiquement mourrir.</para></listitem>

<listitem><para> Dans le cas d'un noeud en échec ( lorsque vous avez utilisé
la commande  <xref linkend="stmtfailover"/> pour basculer sur un autre noeud
), vous devrez peut-être utiliser <xref linkend="stmtuninstallnode"/> 
pour supprimer les triggers, le schéma et les fonctions.</para>

<para> Si le noeud est en échec à cause d'une panne matérielle dramatique
(<emphasis>par exemple</emphasis> si vos disques ont pris feu),
il est possible qu'il n'y ait plus de traces de la base de données sur le noeud;
En général, la base ne survive que lorsque la panne matérielle est un 
problème de réseau qui n'endommage pas les données mais qui vous oblige à 
supprimer le noeud à cause de coupures réseau persitantes.
</para></listitem>

<listitem><para> Si les opérations ci-dessus se sont particulièrement
mal passée. vous pouvez lancer la commande SQL
<command>DROP SCHEMA "Nom_du_cluster" CASCADE;</command>, 
qui supprime toutes les fonctions, les tables et les triggers de 
&slony1;. En général, c'est une opération moins pratique que
<xref linkend="stmtuninstallnode"/>, car cette commande 
ne se contente pas de supprimer le schéma et son contenu, elle
supprime également toutes les colonnes ajoutées avec la 
commande  <xref linkend= "stmttableaddkey"/>.
</para>

<note><para> Dans &slony1; version 2.0, <xref linkend=
"stmttableaddkey"/>  <emphasis>n'est plus supporté</emphasis>, et 
donc <xref linkend="stmtuninstallnode"/> correspond simplement
à  <command>DROP SCHEMA "nom_du_cluster" CASCADE;</command>.  </para>
</note></listitem>
</itemizedlist>
</sect2>

<sect2><title> Ajouter un noeud dans le cluster de réplication</title>

<para>Les choses ne sont pas fondamentalement différentes entre l'ajout
d'un noeud flambant neuf et la restauration d'un noeud qu'on supprimé, puis reconstruit
. Dans les deux cas, vous ajouter un noeud dans le cluster de réplication.
 </para>

<para>Les étapes nécessaires sont ... </para>
<itemizedlist>

<listitem><para> Déterminer le numéro du noeud et les DSNs adéquates
pour le noeuds. Utilisez la commande &postgres; <command>createdb</command>
pour créer la base; ajoutez les définitions des tables que vous voulez
répliquer, car &slony1; ne propage pas automatiquement cette information.
</para>

<para> Si vous ne disposez pas d'un script SQL parfaitement propre pour ajouter
les tables, alors vous pouvez utiliser l'outil  <link linkend="extractschema">
<command> slony1_extract_schema.sh</command> </link> situé dans le répertoire 
<filename>tools</filename> afin d'obtenir le schéma utilisateur sans les 
<quote>morceaux</quote> de &slony1;.  </para>
</listitem>

<listitem><para> Si le noeud était un noeud en échec, vous devez lancer
la commande  <xref linkend="slonik"/> <xref linkend="stmtdropnode"/> 
afin de vous débarasser de ses vestiges dans le cluster et de supprimer
le schéma que &slony1; a créé.
</para></listitem>

<listitem><para> Lancer la commande slonik <xref linkend="stmtstorenode"/> 
pour établir le nouveau noeud.
</para></listitem>

<listitem><para> À cet instant, vous pouvez lancer le démon &lslon; sur le nouveau 
noeud. Il ne connaitra rien des autres noeuds, donc les logs de ce noeud seront
particulièrement calmes.
</para></listitem>

<listitem><para> Lancer la commande slonik <xref linkend="stmtstorepath"/>
pour indiquer comment les processus <xref linkend="slon"/> doivent 
communiquer avec le nouveau noeud. 
Dans la version 1.1 et suivante, cette commande génère automatiquement
des lignes de la table des <link linkend="listenpaths">voies d'écoute</link>;
Dans les versions précédentes vous devez utiliser <xref linkend="stmtstorelisten"/> 
pour les générer manuellement.
</para></listitem>

<listitem><para> A cet instant, lancer le script 
<command>test_slony_state-dbi.pl</command> est une excellente idée, which rummages
through the state of the entire cluster, pointing out any anomalies
that it finds.  This includes a variety of sorts of communications
problems.</para> </listitem>

<listitem><para> Issue the slonik
command <xref linkend="stmtsubscribeset"/> to subscribe the node to
some replication set.
</para></listitem>

</itemizedlist>
</sect2>

<sect2><title> How do I reshape subscriptions?</title>

<para> For instance, I want subscriber node 3 to draw data from node
1, when it is presently drawing data from node 2. </para>

<para> This isn't a case for <xref linkend="stmtmoveset"/>; we're not
shifting the origin, just reshaping the subscribers. </para>

<para> For this purpose, you can simply submit <xref
linkend="stmtsubscribeset"/> requests to <emphasis>revise</emphasis>
the subscriptions.  Subscriptions will not be started from scratch;
they will merely be reconfigured.  </para></sect2>

<sect2><title> How do I use <link linkend="logshipping">Log Shipping?</link> </title> 
<para> Discussed in the <link linkend="logshipping"> Log Shipping </link> section... </para>
</sect2>

<sect2><title> How do I know replication is working?</title> 

<para> The ultimate proof is in looking at whether data added at the
origin makes it to the subscribers.  That's a <quote>simply matter of
querying</quote>.</para>

<para> There are several ways of examining replication status, however: </para>
<itemizedlist>
<listitem><para> Look in the &lslon; logs.</para> 

<para> They won't say too much, even at very high debugging levels, on
an origin node; at debugging level 2, you should see, on subscribers,
that SYNCs are being processed.  As of version 1.2, the information
reported for SYNC processing includes counts of the numbers of tables
processed, as well as numbers of tuples inserted, deleted, and
updated.</para> </listitem>

<listitem><para> Look in the view <command> sl_status </command>, on
the origin node. </para>

<para> This view will tell how far behind the various subscribing
nodes are in processing events from the node where you run the query.
It will only be <emphasis>very</emphasis> informative on a node that
originates a replication set.</para> </listitem>

<listitem><para> Run the <filename>tools</filename>
script <command>test_slony_state-dbi.pl</command>, which rummages
through the state of the entire cluster, pointing out any anomalies
that it notices, as well as some information on the status of each
node. </para> </listitem>

</itemizedlist>

</sect2>

<sect2><title>How do I upgrade &slony1; to a newer version? </title>

<para> Discussed  <link linkend="slonyupgrade"> here </link> </para> </sect2>

<sect2><title> What happens when I fail over?</title> 

<para> Some of this is described under <xref linkend="failover"/> but
more of a procedure should be written...</para> </sect2>

<sect2><title> How do I <quote>move master</quote> to a new node? </title> 

<para> You must first pick a node that is connected to the former
origin (otherwise it is not straightforward to reverse connections in
the move to keep everything connected). </para>

<para> Second, you must run a &lslonik; script with the
command <xref linkend="stmtlockset"/> to lock the set on the origin
node.  Note that at this point you have an application outage under
way, as what this does is to put triggers on the origin that rejects
updates. </para>

<para> Now, submit the &lslonik; <xref linkend="stmtmoveset"/> request.
It's perfectly reasonable to submit both requests in the same
&lslonik; script.  Now, the origin gets switched over to the new
origin node.  If the new node is a few events behind, it may take a
little while for this to take place. </para> </sect2>

<sect2> <title> How Do I Do A <quote>Full Sync</quote> On A Table? </title>

<para> The &slony1; notion of a <command>SYNC</command> is actually
always an <emphasis>incremental</emphasis> thing; a
<command>SYNC</command> represents the set of updates that were
committed during the scope of a particular <command>SYNC</command>
event on the origin node.  If a set of updates that altered the entire
contents of a table were committed in a single
<command>SYNC</command>, that would affect the entire contents of the
table.  But as far as &slony1; is concerned, this change is
<quote>incremental</quote> even though the increment happened to be
<quote>the whole table.</quote> </para>

<para> The only time that &slony1; <quote>synchronizes</quote> the
contents of a table is at the time the subscription is set up, at
which time it uses <command>COPY</command> to draw in the entire
contents from the provider node.</para>

<para> Since subscriber tables are protected against modification by
anything other than &slony1;, there should be no way (aside from
horrible bugs) for tables to fall out of synchronization.  If they do,
there is some rather serious problem with &slony1;. </para>

<para> If some such severe corruption takes place, the answer is to
drop the table from replication, then create a new replication set and
add it back. </para>

</sect2>

</sect1>
