<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="versionupgrade"><title>Utiliser &slony1; pour les mises à jour &postgres;</title>

<indexterm><primary>Mettre à jour la version de &postgres; en utilisant &slony1;</primary></indexterm>

<para> Un certain nombre de personnes ont trouvé que &slony1; était pratique pour effectuer les mises à jours de versions majeures  ( <emphasis>par exemple</emphasis> celles qui nécessitent d'éxécuter <application>initdb</application> afin de recréer une nouvelle instance ) sans subir une coupure de service importante.
</para>

<para>La méthode simple que l'on peut imaginer pour effectuer une telle mise à jour consiste à éxecuter  <application>pg_dump</application> sur l'ancienne version de la base, puis d'envoyer le résultat dans une session <application>psql</application> connectée à la nouvelle version de la base. Malheureusement le temps nécessaire pour cette approche peut être prohibitif. Pour une base contenant 40Go de données ainsi que de nombreux index, le processus nécessite les étapes suivantes :
<itemizedlist>
<listitem><para> Arrêtez toutes les applications qui peuvent modifier les données; </para></listitem>
<listitem><para> Lancez le <application>pg_dump</application>, et charger les données dans la nouvelle base;</para></listitem>
<listitem><para> Attendez 40 heures que le processus d'extraction/chargement se termine;</para></listitem>
<listitem><para> Faites pointer les applications <quote>en écriture</quote> vers la nouvelle base</para></listitem>  
<itemizedlist> 
</para>  

<para>Notez que cette opération a provoqué une coupure de service de 40 heures.</para>

<para> &slony1; offre une opportunité de remplacer cette longue coupure de service par une autre de quelques minutes, voire quelques secondes. Cette approche consiste à créer un réplicat &slony1; utilisant la nouvelle version de &postgres;. Il est possible que cela prenne plus de 40 heures pour créer ce réplicat, mais une fois qu'il est créé, il peut être rafraîchi rapidement.
  
<para> Au moment de basculer vers la nouvelle base de données, la procédure est beaucoup moins longue :

<itemizedlist>
<listitem><para> Arrêtez toutes les applications qui peuvent modifier les données;</para></listitem>

<listitem><para> Verrouillez le set contre les lectures des applications clientes en utilisant <xref linkend="stmtlockset"/>;</para></listitem>

<listitem><para> Lancez le commande Slonik <xref
linkend="stmtmoveset"/> pour déplacer l'origine de l'ensemble de réplication depuis l'ancienne base vers la nouvelle.</para></listitem>

<listitem><para> Faites pointer les applications vers la nouvelle base;</para></listitem>

</itemizedlist></para>

<para> Cette procédure devrait prendre un temps très court, qui dépendra principalement de votre rapidité lors de la reconfiguration de vos applications. Si vous pouvez souhaiter automatiser toutes ces étapes, il est possible que cela prenne moins d'une seconde. Sinon il est probable que cela prenne entre quelques secondes et quelques minutes.
  
<para>Notez qu'après le déplacement de l'origine, les mises à jour vont vers l'<emphasis>ancienne</emphasis> base. Si vous découvrez qu'à cause d'un problème imprévu ou non-testé, votre application rencontre certains problèmes pour se connecter à la nouvelle base, vous pouvez facilement utiliser  <xref linkend="stmtmoveset"/> à nouveau pour re-déplacer l'origine vers l'ancienne base.
</para>

<para>Si vous considerez qu'il est particulièrement vital de pouvoir revenir à l'ancienne base dans l'état où elle se trouvait avant la bascule, afin de pouvoir revenir complètement en arrière et que vous souhaitez également pouvoir revenir à l'ancienne version (mise à jour depuis la bascule), accomplissez les étapes suivantes :
  
<itemizedlist>
  
<listitem><para> Préparez <emphasis> deux </emphasis>  réplicats &slony1; de la base;
<itemizedlist>
<listitem><para> Un pour la nouvelle version de &postgres;;</para></listitem>
<listitem><para> Un pour l'ancienne version de &postgres;.</para></listitem>
</itemizedlist></para>

<para>Ainsi vous avez <emphasis>trois</emphasis> noeuds, un avec la nouvelle versin de &postgres;, et deux autres avec l'ancienne version.</para></listitem>

<listitem><para> Une fois qu'ils sont à peu près <quote>synchronisés</quote>, arrêtez toutes les applications qui peuvent modifier les données.
</para></listitem>

<listitem><para> Lancez la synchronisation des noeuds, puis 
<command>arrêtez</command> le démon <application>slon</application> qui a synchronisé le noeud esclave qui héberge l'ancienne version de &postgres;
</para>

<para>Vous voudrez peut-être utiliser <xref linkend="stmtuninstallnode"/> pour
isoler ce noeud et ainsi le transformer en une base indépendante, ou simplement tuer le démon <application>slon</application>, selon 
votre volonté de rendre cette transformation permanente ou non.
</para></listitem>

<listitem><para> Ensuite utilisez <xref linkend="stmtmoveset"/> pour déplacer l'origine, comme décrit précédemment.</para></listitem>

</itemizedlist></para>

<para> Si de <quote>petits</quote> problèmes apparaissent, vous pourrez récupérer
  le noeud qui héberge l'ancienne base qui a reçues les mises à jours de données; 
 Si vous découvrez des problèmes plus importants, vous pouvez abandonner les deux noeuds 
 et revenir à la base qui a été isolée.</para> 

<para>Il ne s'agit pas ici de dire qu'il est courant 
  de rencontrer des problèmes qui nécessitent une procédure aussi <quote>paranoïaque</quote>; 
  Toutefois les personnes soucieuses d'évaluer les risques peuvent être rassurées 
  par de tels choix. 
  
<note><para>&slony1; ne supporte pas les versions de &postgres antérieures à la 7.3.3 
    parcequ'il a besoin des espaces de noms ("namespaces") qui n'étaient pas stable jusque là.
    Rod Taylor modifia une version de &slony1 pour qu'elle fonctionne avec la 7.2 en autorisant 
    les objets &slony1; à se placer dans le schéma global. Il trouva cela assez compliqué, de plus 
    certaines requêtes n'était pas assez rapides ( l'optimiseur de requêtes de &postgres; a été <emphasis>considérablement</emphasis> amélioré depuis la version 7.2), cependant cette solution était plus pratique pour lui que les autres systèmes de réplication tels que <productname>eRServer</productname>. Si vous recherchez désespérement ce type de solution, contactez-le sur la liste des hackers de &postgres;. Il n'est pas prévu que la version 7.2 de &postgres; soit supportée par une version officielle de &slony1;

</para></note></para>

</sect1>
