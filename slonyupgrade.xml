<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<sect1 id="slonyupgrade">
<title>Mise à jour de &slony1;</title>
<indexterm><primary>remplacer &slony1; par une nouvelle version</primary></indexterm>

<para>
  Lorsqu'on met à jour &slony1;, chaque n&oelig;ud du cluster doit être mis à
  jour simultanément, en utilisant la commande <xref
  linkend="stmtupdatefunctions"/> de &lslonik;.
</para>

<para>
  Cela nécessite un arrêt temporaire de la réplication, mais cela n'implique
  pas obligatoirement une coupure de service au niveau des applications qui
  utilisent le cluster.
</para>

<para>
  La procédure correcte est la suivante&nbsp;:
</para>

<itemizedlist>
  <listitem>
    <para>
      Arrêtez les processus &lslon; sur chaque n&oelig;ud
      (<emphasis>c'est-à-dire</emphasis> l'ancienne version de &lslon;).
    </para>
  </listitem>

  <listitem>
    <para>
      Installez la nouvelle version du logiciel &lslon; sur tous les
      n&oelig;uds.
    </para>
  </listitem>

  <listitem>
    <para>
      Exécutez un script &lslonik; contenant la commande
      <command>update functions (id = [valeur]);</command> pour chaque
      n&oelig;ud du cluster.
    </para>

    <note>
      <para>
        Souvenez-vous que le script de mise à jour, comme tous les scripts
	&slonik; doit contenir les fonctions adéquates pour fonctionner.
      </para>
    </note>
  </listitem>
  
  <listitem>
    <para>
      Démarrez tous les démons slons.
    </para>
  </listitem>
</itemizedlist>

<para>
  Toute cette opération est relativement sûre&nbsp;: s'il y a une incohérence
  entre les versions des composants, le &lslon; refusera de démarrer, ce qui
  constitue une protection contre les corruptions.
</para>

<para>
  Vous devez vous assurer que la bibliothèque C contenant les fonctions trigger
  SPI ont été copiées à la bonne place lors de la compilation de &postgres;. Il
  existe de multiples approches pour cela&nbsp;:
</para>

<para>
  La partie la plus compliquée consiste à s'assurer que la bibliothèque C
  contenant les fonctions SPI est copiée au bon endroit lors de la compilation
  de &postgres;&nbsp;; la manière la plus simple et la plus sûre de faire cela
  consiste à avoir deux versions compilées de &postgres;, une pour chaque
  version de &slony1;, puis d'éteindre le serveur et de le relancer avec la
  <quote>nouvelle</quote> version compilée&nbsp;; cette approche implique une
  courte coupure de service sur chaque n&oelig;ud.
</para>

<para>
  Si cette approche est réputée plus simple et plus rapide, rien ne vous
  empêche de mettre en place avec précaution les composants &slony1; pour
  écraser l'ancienne version comme décrit dans l'étape d'installation. Ceci
  peut ne <emphasis>pas</emphasis> fonctionner sous Windows si Windows pose un
  verrou sur les fichiers qui sont utilisés.
</para>

<variablelist>
  <varlistentry>
    <term>Exécuter <command>make install</command> pour installer les nouveaux
    composants &slony1; au dessus des anciens.</term>

    <listitem>
      <para>
        Si vous compilez &slony1; sur le système sur où il sera déployé et
        que vous compilez à partir des sources, écraser l'ancienne version avec
        la nouvelle se fait simplement avec <command>make install</command>.
        Il n'est pas nécessaire de relancer la base de donnée, il faut juste
        arrêter les processus &slony1;, exécuter le script <command>UPDATE
        FUNCTIONS</command> et démarrer les nouveaux processus &lslon;.
      </para>

      <para>
        Malheureusement, cette approche nécessite un environnement de
	compilation sur le serveur où la mise à jour sera déployée. Ceci n'est
	pas forcément compatible avec la volonté d'utiliser des binaires
	communs à &postgres; et &slony1; sur l'ensemble des n&oelig;uds.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>Compiler à nouveau &postgres; et &slony1;</term>

    <listitem>
      <para>
        Avec cette approche, l'ancienne version de &postgres; accompagnée des
        anciens composants &slony1; est conservée après la bascule vers une
	nouvelle version de &postgres; accompagnée des nouveaux composants
	&slony1;. Afin de basculer vers la nouvelle version de &slony1;, vous
	devez redémarrer le serveur <command>postmaster</command>, ce qui
	implique l'interruption des applications. afin que le serveur soit
	informé de l'emplacement des nouveaux composants.
      </para>
    </listitem>
  </varlistentry>
</variablelist>

</sect1>
