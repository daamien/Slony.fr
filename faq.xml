<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modifications
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<qandaset>
<indexterm><primary>Foire Aux Questions de &slony1;</primary></indexterm>

<qandadiv id="faqcompiling"><title> &slony1; FAQ: Monter et Installer &slony1; </title>

<qandaentry>

<question><para> J'utilise <productname> Frotznik Freenix
4.5</productname>, avec son système de gestion de paquetages <acronym>FFPM</acronym> (Frotznik Freenix Package Manager).  Il existe des paquets
<acronym>FFPM</acronym> pour &postgres; 7.4.7, que j'utilise actuellement
comme base de données, mais il n'y a pas encore de paquetages &slony1;.
Comment puis-je rajouter &slony1; à cette distribution ?  </para>
</question>


<answer><para> <productname>Frotznik Freenix</productname> c'est nouveau pour moi,
alors il est un peu dangereux, de donner une réponse définitive, concise et rapide.  </para>

<para> Les réponses différent légèrement selon les diverses combinaisons de versions entre
&postgres; et &slony1; Il est légérement plus facile, avec les versions récentes, de faire face à ce genre de questions qu'avec les versions plus anciennes. En général, vous devez presque certainement recompiler &slony1; depuis les sources; selon les versions
des deux composants &slony1; et &postgres;, vous
<emphasis>devez</emphasis> également recompiler &postgres; à partir de zéro.
(Savoir si vous devez <emphasis> utilisez </emphasis> la version compilée de &postgres; 
est un autre problème; en général ce n'est pas le cas...) </para>

<itemizedlist>

<listitem><para> &slony1; la version 1.0.5 et ultérieur nécessite d'avoir une version  complètement configurées des sources de &postgres;, afin de recompiler
&slony1;.</para>

<!-- TODO -->

<para> <emphasis>Heureusement </emphasis> vous pouvez adapter la configuration pour qu'elle corresponde à la configuration utilisée nativement par la paquet d'origine, en vérifiant la 
version de &postgres; avec la commande
<command> pg_config --configure</command>. </para> </listitem>

<listitem> <para> &slony1; La version 1.1 simplifie considérablement les choses;
dans la mesure où vous êtes dispensé d'avoir la version complète de de sources de &postgres;, au lieu de cela, elle se réfère aux emplacements des librairies,
des binaires, de la configuration, et  <command> des fichiers #include </command>.
</para> </listitem>

<listitem><para> &postgres; 8.0 et supérieur est généralement plus facile car l'<quote>installation par défaut</quote> contient la totalité des fichiers d'inclusion <command> #include </command>.  </para>

<para> Si vous utilisez une version antérieure de &postgres;, il est préférable d'utiliser une version installée à partir des sources, 
en particulier si la version packagée ne contient  <quote> les fichiers d'inclusions<command>#include</command></quote> du serveur. Ces fichiers peuvent être installés par la commande <command> make install-all-headers </command>.</para>
</listitem>

</itemizedlist>

<para> En pratique, la <quote>pire situation</quote> est un scénario où 
vous utilisez une version de &slony1; antérieure à 1.1 avec une
<quote>vieille</quote> version de &postgres;, dans ce cas vous devez compiler &postgres;
à partir de zéro afin d'avoir tout les pré-requis de compilation de &slony1; même si  
vous utilisez une version<quote>packagée</quote> de &postgres;.</para>

<para> Si vous utilisez une version récente de &postgres; et une version récente de &slony1;,
alors les dependences peuvent être assez faibles, et vous n'avez pas  besoin de fichiers sources complémentaires.  Ces améliorations devraient soulager la mise en production des
paquets de &slony1;  de sorte que vous pourriez même pouvoir espérer éviter la compilation
de &slony1;.</para>

</answer>

<answer><para> </para> </answer>

</qandaentry>

<qandaentry id="missingheaders">
<question><para> J'essaie d'installer &slony1; 1.1 et j'obtiens le message d'erreur suivant:
<screen>
configure: error: Headers for libpqserver are not found in the includeserverdir.
   This is the path to postgres.h. Please specify the includeserverdir with
   --with-pgincludeserverdir=&lt;dir&gt;
</screen>
</para></question>

<answer><para> Vous exécutez certainement une version &postgres; 7.4
ou antérieure, où les en-têtes de serveur ne sont pas installés par défaut, il vous suffit dans ce cas de lancer la commande <command>make install</command> de &postgres;.</para>

<para> Vous devez installer les en-têtes du serveur lors d'installation de &postgres; via la commande <command>make install-all-headers</command>.

</para> </answer> </qandaentry>

<qandaentry id="threadsafety">

<question><para> &slony1; semble se compiler correctement; maintenant, lorsque j'exécute un &lslon;, certain évènements se déclenchent, mais la réplication ne se met pas 
route.</para>

<para> Les logs de Slony ressemble à ça :

<screen>
DEBUG1 remoteListenThread_1: connected to 'host=host004 dbname=pgbenchrep user=postgres port=5432'
ERROR  remoteListenThread_1: "select ev_origin, ev_seqno, ev_timestamp,
		  ev_minxid, ev_maxxid, ev_xip,
		  ev_type,
                  ev_data1, ev_data2,
		  ev_data3, ev_data4,
 	          ev_data5, ev_data6,
		  ev_data7, ev_data8 from "_pgbenchtest".sl_event e 
where (e.ev_origin = '1' and e.ev_seqno > '1') order by e.ev_origin, e.ev_seqno" - could not receive data from server: Operation now in progress
</screen>
</para>

<para> Parfois ils contiennent les lignes suivantes  ...

<screen>
ERROR  remoteListenThread_2: "select ev_origin, ev_seqno, ev_timestamp,
ev_minxid, ev_maxxid, ev_xip,        ev_type,        ev_data1, ev_data2,
ev_data3, ev_data4,        ev_data5, ev_data6,        ev_data7, ev_data8
from "_sl_p2t2".sl_event e where (e.ev_origin = '2' and e.ev_seqno >
'0') order by e.ev_origin, e.ev_seqno" - could not receive data from
server: Error 0
</screen> 
</para>
</question>

<answer><para>Sur AIX et Solaris (et probablement sur d'autre OS), 
&slony1; <emphasis>et &postgres;</emphasis> doivent être compilés avec l'option <option>--enable-thread-safety</option> .  Le message ci-dessus arrive lorsque la compilation
de &postgres; n'a pas fait appel à cette option.</para>
<TODO>
<para>Le disfonctionnement ici vient du fait que le libc (indépendant des threads) et libpq
(basés sur les threads) utilisent des emplacements de mémoire différente pour les codes d'erreur, c'est qui fait échouer les requêtes.</para>

<para>Des problèmes de ce genre surviennent avec des régularités surprenantes sur AIX et sur Solaris. Il sera probablement nécessaire
de réaliser un <quote>audit du code objet</quote> pour s'assurer que  <emphasis>tous</emphasis> les composants nécessaire ont été compilés et linkés avec l'option <option>--enable-thread-safety</option>.</para>

<para>Par exemple, on peut rencontrer un problème sur Solaris lorsque 
<envar>LD_LIBRARY_PATH</envar> est défini et  pointe sur les
librairies depuis d'une ancienne version compilée de &postgres;. Cela signifie que même si
la base de donnée <emphasis>avait été</emphasis> compilée avec l'option 
<option>--enable-thread-safety</option>, et même si 
<application>slon</application> a été recompilé pour cette version, lors de l'édition de lien dynamique de
<application>slon</application> pointait sur un 
<quote>ancienne mauvaise version compilée sans l'option thread-safe,</quote>, et donc slon ne fonctionne pas.  On ne peut s'apercevoir de cela qu'en exécutant <command>ldd</command>
sur <application>slon</application>.</para> </answer>

<answer><para> A noter que la version   7.4.2 de libpq sur Solaris nécessite <link linkend="threadpatch"> un patch supplémentaire pour les threads </link> ; Ce pré-requis est également demandé pour &postgres; version 8.0.
</para>
</answer>
</qandaentry>

<qandaentry id="pg81funs">

<question> <para> Je suis en train de migrer sur une nouvelle version de &slony1;
et je me débat avec un problème avec <xref
linkend="stmtupdatefunctions"/>.  Lors d'exécution de <xref
linkend="stmtupdatefunctions"/>, mon
<application>postmaster</application> plante avec le signal 11.
Le fichier log ne contient aucune erreur, exceptées celles relatives à
&postgres; les logs indiquent simplement que le postmaster est bel bien tombé.</para>

<para> En scrutant le fichier core avec un déboggueur, on constate que
l'incident survient lors de la validation d'une transaction. </para>

<para> Pour infos je suis sur &postgres; 8.1.[0-3]. </para>
</question>

<answer> <para> Malheureusement les anciennes versions de &postgres; 8.1 avait un problème lors de la re-définition d'une fonction ( par exemple <function>upgradeSchema(text)</function>), lorsque la fonction est appellée juste après, au sein de la même transaction,
, le
<application>postmaster</application> plante et la
transaction est annulée.  </para>

<para> La commande &lslonik; <xref linkend="stmtupdatefunctions"/>
fonctionne de cette manière; dans une même transaction elle effectue ceci :

<itemizedlist>
<listitem><para> Charger les nouvelles fonctions (depuis <filename>slony1_funcs.sql</filename>), notamment comprenant <function>upgradeSchema(text)</function>.
</para> </listitem>
<listitem><para> Lancer <function>upgradeSchema(text)</function> pour effectuer la migration nécessaire des schémas de la base. </para> </listitem>
<listitem><para> Avertir les processus &lslon; du changement de configuration.</para> </listitem>
</itemizedlist>
</para>

<para> Malheureusement, en &postgres; 8.1.0, 8.1.1, 8.1.2, et 8.1.3,
ceci est conflictuel avec un bug où l'utilisation et la modification d'une fonction plpgsql au sein de la même transaction
provoque un plantage. </para>

<para> Plusieurs contournements sont envisageables. </para>

</answer>

<answer> <para> La meilleur solution consiste à migrer &postgres; vers une version 8.1.4 ou supérieure. Les changements entre deux versions mineures ne nécessite pas la reconstruction de la base, il suffit simplement d'installer la nouvelle version puis de redémarrer le <application>postmaster</application> avec cette nouvelle version.  </para>
</answer>

<answer><para> Si cette solution ne convient pas, il est possible d'effectuer la mise à jour via une série de transaction  <quote>à la main</quote>, qui correspondent à ce que &lslonik; aurait fait pour cette migration. </para>

<itemizedlist>
<listitem><para> Prendre <filename>slony1_funcs.sql</filename> et faire trois remplacements dans ce fichier: </para> 

<itemizedlist>
<listitem><para> Remplacer <quote>@CLUSTERNAME@</quote>avec le nom du cluster</para> </listitem>
<listitem><para> Remplacer <quote>@MODULEVERSION@</quote> avec la version de &slony1; par exemple <quote>1.2.10</quote> </para> </listitem>
<listitem><para> Remplacer <quote>@NAMESPACE@</quote> avec le nom du namespace du cluster <quote>entre doubles quotes</quote> , par exemple "_monCluster" </para> </listitem>
</itemizedlist>
</listitem>
<listitem><para> Recharger dans la base cet ensemble de fonctions <quote>mise à jour</quote>.</para> </listitem>
<listitem><para> Exécuter la fonction stockée via <command>select <function>upgradeSchema('1.2.7')</function>; </command>, 
en supposant que la précédente version de &slony1; en cours était la 1.2.7. </para> </listitem>
<listitem><para> Le redémarrage de tous les processus &lslon; est probablement une sage décision après ce genre de <quote>chirurgie.</quote> </para> </listitem>
</itemizedlist>
</answer>
</qandaentry>

<qandaentry>
<question> <para> Problème d'installation sur Fedora/x86-64 </para>

<para> Lorsqu'on essaie de configurer &slony1; sur système Fedora x86-64,
où <application>yum</application> a été utilisé pour une installation du paquetage
<filename>postgresql-libs.x86_64</filename>, le message suivant se manifeste :

<screen>
configure: error: Your version of libpq doesn't have PQunescapeBytea
 this means that your version of PostgreSQL is lower than 7.3
 and thus not supported by Slony-I.
</screen></para>

<para> Ceci arrive avec &postgres; 8.2.5, ce qui est nettement plus récent que la version 7.3. </para>
</question>

<answer> <para> La fonction <application>configure</application> est à la recherche du symbole PQunescapeBytea, elle compile un petit programme qu'il l'appele et 
vérifie la compilation se passe bien. Dans la ligne de commande <command>gcc</command>,
elle utilise <command>-lpq</command> pour chercher la librairie. </para>


<para> Malheureusement, ce paquetage n'a pas de lien symbolique, reliant <filename>/usr/lib64/libpq.so</filename> à
<filename>libpq.so.5.0</filename>; c'est pourquoi la fonction configure n'arrive pas à trouber libpq.  
Le <emphasis>vrai</emphasis> problème c'est que le compilateur n'arrive pas à trouver une librairie pour l'édition de lien, et non pas que libpq ait manqué à l'appel.
</para>

<para> Au final, ces informations doivent être envoyée vers ceux qui gèrent le paquet <filename>postgresql-libs.x86_64</filename>. </para>
</answer>

<answer> <para> Notez que ce même symptôme peut être révélateur d'autres problèmes de ce genre  au niveau de la configuration système. Les mauvais liens symboliques, les mauvaises permissions, le mauvais comportement de la part de votre compilateur C, tout peuvent potentiellement mener à ce même message d'erreur. </para> 

<para> Ainsi si vous rencontrez cette erreur, vous aurez besoin de regarder le fichier log
<filename>config.log</filename>.  Cherchez à partir du bas, et regardez quel est le souci <emphasis>réellement</emphasis> rencontré.
Ceci sera utile pour trouver la vrai racine de cet épineux problème.</para>
</answer>

</qandaentry>

</qandadiv>

<qandadiv id="faqconnections"> <title> &slony1; FAQ: Problèmes relatifs aux connections</title>
<qandaentry>

<question><para>Je cherche le namespace<envar>_clustername</envar>, et 
il est introuvable.</para></question>

<answer><para> Si le DNS sont erronés, alors l'instance &lslon;
ne pourra pas se connecter aux noeuds.</para>

<para>Ceci mène au fait que les noeuds seront introuvables.</para>

<para>Revérifier la configuration des connexions. D'ailleurs, puisque <xref linkend="slon"/> est lié à libpq, vous pouvez stocker le mot de passe dans <filename> $HOME/.pgpass</filename>, le problème vient peut-être d'une erreur dans ce fichier.</para>
</answer>
</qandaentry>

<qandaentry id="morethansuper">
<question> <para> J'ai créé un compte <quote>super-utilisateur</quote>,
<command>slony</command>, pour exécuter les activités de réplications. Comme suggéré,
je l'ai configuré comme super-user, avec la requête suivante : 
<command>
update pg_shadow set usesuper = 't' where usename in ('slony',
'molly', 'dumpy');
</command>
(Cette même commande permet d'autoriser autres utilisateurs d'exécuter vacuums et
sauvegarde).</para>

<para> Malheureusement, je suis tombé en erreur, à chaque fois où je voulais souscrire à un nouveau ensemble.</para>

<programlisting>
DEBUG1 copy_set 28661
DEBUG1 remoteWorkerThread_1: connected to provider DB
DEBUG2 remoteWorkerThread_78: forward confirm 1,594436 received by 78
DEBUG2 remoteWorkerThread_1: copy table public.billing_discount
ERROR  remoteWorkerThread_1: "select "_mycluster".setAddTable_int(28661, 51, 'public.billing_discount', 'billing_discount_pkey', 'Table public.billing_discount with candidate primary key billing_discount_pkey'); " PGRES_FATAL_ERROR ERROR:  permission denied for relation pg_class
CONTEXT:  PL/pgSQL function "altertableforreplication" line 23 at select into variables
PL/pgSQL function "setaddtable_int" line 76 at perform
WARN   remoteWorkerThread_1: data copy for set 28661 failed - sleep 60 seconds
</programlisting>

<para> Cela continue de planter, encore et toujours, jusqu'à ce que je redémarre <application>slon</application> pour qu'il se connecte avec le compte <command>postgres</command>.</para>
</question>

<answer><para> Le problème est assez évident en soi; la permission sur la table de système <envar>pg_class</envar> est ignorée.</para></answer>

<answer><para> La <quote>solution</quote> est la suivante:</para>
<programlisting>
update pg_shadow set usesuper = 't', usecatupd='t' where usename = 'slony';
</programlisting>
</answer>

<answer><para> En version 8.1 et supérieure, vous avez aussi besoin de:</para>
<programlisting>
update pg_authid set rolcatupdate = 't', rolsuper='t' where rolname = 'slony';
</programlisting>
</answer>
</qandaentry>

<qandaentry>
<question><para> Au moment d'enregistrer un esclave, j'obtiens le message suivant dans les logs :

<screen>
DEBUG1 copy_set 1
DEBUG1 remoteWorkerThread_1: connected to provider DB
WARN	remoteWorkerThread_1: transactions earlier than XID 127314958 are still in progress
WARN	remoteWorkerThread_1: data copy for set 1 failed - sleep 60 seconds
</screen></para></question>

<answer> <para> Il y a évidemment un certain nombre de vieilles transactions qui empêche &slony1; de traiter des synchronisations. Vous devriez jeter un coup d'oeil à pg_locks pour ce qu'il en est :</para>

<screen>
sampledb=# select * from pg_locks where transaction is not null order by transaction;
 relation | database | transaction |  pid    |     mode      | granted 
----------+----------+-------------+---------+---------------+---------
          |          |   127314921 | 2605100 | ExclusiveLock | t
          |          |   127326504 | 5660904 | ExclusiveLock | t
(2 rows)
</screen>

<para>Vous voyez ? la transaction 127314921 est en effet plus vieilles que la transaction 127314958, et elle est toujours en cours d'exécution.</para>

<para> Un long traitement de publi-postage, une requête <application>RT3</application> qui s'emballe, un
<application>pg_dump</application>, toutes ces opérations ouvrent des transactions pour une période importante.
Jusqu'à ce qu'elles soient complétées ou bien interrompues, on verra alors le message d'erreur suivant:
<quote> data copy
for set 1 failed - sleep 60 seconds </quote>.</para>

 
<para>Quoiqu'il en soit, s'il y a plus d'une base de données sur le cluster du &postgres; , et que la charge se situe sur une autre base, vous verrez apparaitre des <quote>transactions en cours avec un XID
antérieur</quote> à celle de &slony1;.  Le fait que la transaction se déroule sur une base de donnée dissociée ne change rien ; &slony1; attendra jusqu'à ce que ces vieilles transactions se terminent.</para>
</answer>
</qandaentry>


<qandaentry>
<question><para>Même question que précèdemment.  J'ai oublié de mentionner que j'essayais d'ajouter 
<emphasis>DEUX</emphasis> abonnés, simultanément.</para></question>

<answer><para> Cela ne peut pas marcher: &slony1; ne peut employer la commande
<command>COPY</command> de manière concurrente.  Voir  la fonction
<function>copy_set()</function> dans le fichier <filename>src/slon/remote_worker.c</filename></para>

<screen>
$ ps -aef | egrep '[2]605100'
postgres 2605100  205018	0 18:53:43  pts/3  3:13 postgres: postgres sampledb localhost COPY 
</screen>
 
<para>Une transaction <command>COPY</command> 
essaie d'installer l'abonnement pour un des noeuds. Tout a l'air bien; 
le système s'occupe de configurer le premier abonné; il ne vapas démarrer sur le second tant que le premier n'a pas fini son enregistrement. Cela représente une cause possible.</para>

<para>Ceci a comme (facheuse) conséquence que vous ne pouvez pas peupler deux esclaves simultanément à partir d'un même fournisseur. Vous devez souscrire un et un seul abonné à la fois,
une fois qu'il a accompli l'abonnement,( en copiant le contenu des table, etc.), on peut s'occuper de débuter l'enregistrement
du deuxième.</para></answer>
</qandaentry>

<qandaentry id="missingoids"> <question> <para> Nous avons rencontré un message inattendu en désinstallant entièrement un cluster de réplication slony sur le maître et l'esclave.</para>

<warning> <para><emphasis>MAKE SURE YOU STOP YOUR APPLICATION RUNNING
AGAINST YOUR MASTER DATABASE WHEN REMOVING THE WHOLE SLONY
CLUSTER</emphasis>, or at least re-cycle all your open connections
after the event!  </para></warning>

<para> The connections <quote>remember</quote> or refer to OIDs which
are removed by the uninstall node script. And you will get lots of
errors as a result...
</para>


</question>

<answer><para> Il y a deux mécanismes de 
&postgres; qui mettent en cache les plans d'interrogation et les OIDs:</para>
<itemizedlist>
<listitem><para> Les requêtes préparées ("prepared statements")</para></listitem>
<listitem><para> Les fonctions pl/pgSQL </para></listitem>
</itemizedlist>

<para>Ce problème n'est pas pas particulier à &slony1;; 
il se produit à chaque fois quand des modifications importantes sont apportées aux schémas de la base 
de données. Cela n'entaine pas de perte des données, mais cela provoque des vagues d'erreurs relatives aux OID.
</para></answer>

<answer><para> Le problème survient lorsque vous utilisez une sorte de 
<quote>pool de connexion</quote> qui recycle les vieilles connexions.
Si vous relancez l'application après ceci, les nouvelles connexions
vont produire de <emphasis>nouveau</emphasis>plan d'exécution et les erreurs disparaitront. Si votre pool de connexion tue les sessions, et en recrée de nouvelles, alors ces nouvelles sessions auront de <emphasis>nouveaux</emphasis> plans d'exécution, et que les erreurs disparaîtront. </para></answer>
 
<answer> <para> Dans notre code nous éliminons toutes connexions ayant des erreurs inattendues dans
le contexte. Ainsi, toutes les connexions devraient être renouvelées dès l'apparition d'une erreur
inattendue. Naturellement si l'erreur remonte une violation de contrainte, qui est une condition reconnue, ce va provoquer une renouvellement de connexion,  et si le problème persiste, les connexions sont recyclées en permanence, ce qui annulera l'effet du pool, dans ce cas, le pooler de connexion proposera probablement à l'administrateur de jeter un coup d'oeil à la situation. </para> </answer>

</qandaentry>

<qandaentry><question><para> J'ai migré mon  &slony1; en version
1.2.  J'ai maintenant cet avertissement dans les logs:</para>

<screen>NOTICE:  Slony-I: log switch to sl_log_2 still in progress - sl_log_1 not truncated</screen>

<para> Les tables <envar>sl_log_1</envar> et <envar>sl_log_2</envar> continue de prendre du volume, 
et <envar>sl_log_1</envar> n'est jamais vidée.
Quel est le souci?
</para> </question>

<answer><para> Ceci est un cas symptomatique du problème précèdent,
relatif à la suppression de réplication : s'il y a des vieilles connexions établies, qui continuent à utiliser des plan d'exécutions
basés sur des vieilles fonctions stockées, ce qui provoque des écritures dans  <envar>sl_log_1</envar> </para>

<para> La fermeture des vieilles connexions et l'ouverture des nouvelles connexions, résoudra ce problème.</para> </answer> 

<answer> <para> A plus long terme, il y a un item dans la TODO liste de &postgres; pour implémenter une vérification des dépendances, qui pourra supprimer un plan d'exécution caché, lorsque un objet lié à ce plan est modifié. </para> </answer>
</qandaentry>

<qandaentry>
<question><para>J'ai pointé un noeud abonné vers un noeud fournisseur différent, et il a cessé la réplication.</para></question>

<answer><para>
Nous avons constaté que ceci arrive lorsque on réinitialise un noeud dans la configuration suivante: 

<itemizedlist>
<listitem><para> Noeud 1 - fournisseur</para></listitem>
<listitem><para> Noeud 2 - abonné au noeud 1 - le noeud que l'on réinitialise</para></listitem>
<listitem><para> Noeud 3 - abonné au noeud 3 - le noeud qui doit continuer à répliquer</para></listitem>
</itemizedlist></para>

<para>L'abonnement du noeud 3 est changé pour que le noeud 1 soit
son fournisseur et on exécute <xref linkend="stmtdropset"/> /<xref
linkend="stmtsubscribeset"/> sur le noeud 2 pour qu'il soit repeuplé.</para>

<para>Malheureusement, la réplication s'arrête soudainement sur le noeud 3.</para>

<para>Le problème vient du fait qu'il n'y a pas d'ensemble approprié de
<quote>voies d'écoute</quote> dans la table <xref linkend="table.sl-listen"/> pour propager les évènements 
depuis le noeud 1 vers sur le noeud 3. Les événements sont transportés vers le noeud 2 et sont bloqués par l'événement  <xref linkend="stmtsubscribeset"/> que le noeud 2 est en train de traiter.</para>

<para>Le script suivant supprime les voies d'écoute qui font transiter les events par le noeud 2 et ajouter une voie d'écoute directe entre  les noeuds 1 et 3.

<programlisting>
cluster name = oxrslive;
 node 1 admin conninfo='host=32.85.68.220 dbname=oxrslive user=postgres port=5432';
 node 2 admin conninfo='host=32.85.68.216 dbname=oxrslive user=postgres port=5432';
 node 3 admin conninfo='host=32.85.68.244 dbname=oxrslive user=postgres port=5432';
 node 4 admin conninfo='host=10.28.103.132 dbname=oxrslive user=postgres port=5432';
try {
  store listen (origin = 1, receiver = 3, provider = 1);
  store listen (origin = 3, receiver = 1, provider = 3);
  drop listen (origin = 1, receiver = 3, provider = 2);
  drop listen (origin = 3, receiver = 1, provider = 2);
}
</programlisting></para>

<para>Juste après l'éxécution de ce script, les événements <command>SYNC</command> se propagent à nouveau vers le noeud 3.

Ceci souligne deux principes:
<itemizedlist>
<listitem><para>
Si vous avez plusieurs noeuds, et des abonnés en cascade,
vous devez faire attention en repeuplant les entrés <xref
linkend="stmtstorelisten"/>, et en modifiant si la structure de l'<quote>arbre</quote> de réplication a changé.</para></listitem>

<listitem><para> La version 1.1 fourni des meilleurs outils pour gérer ce cas.</para>
</listitem>

</itemizedlist></para>

<para>Les problèmes relatifs aux <quote>voies d'écoute</quote> sont discutés plus précisions dans la section <xref linkend="listenpaths"/> </para></answer>
</qandaentry>

<qandaentry id="multipleslonconnections">

<question><para> En redémarrant  &lslon;, j'obtiens
les messages <quote>FATAL</quote> suivants dans le log. Que se passe-t-il??? </para>
<screen>
2006-03-29 16:01:34 UTC CONFIG main: slon version 1.2.0 starting up
2006-03-29 16:01:34 UTC DEBUG2 slon: watchdog process started
2006-03-29 16:01:34 UTC DEBUG2 slon: watchdog ready - pid = 28326
2006-03-29 16:01:34 UTC DEBUG2 slon: worker process created - pid = 28327
2006-03-29 16:01:34 UTC CONFIG main: local node id = 1
2006-03-29 16:01:34 UTC DEBUG2 main: main process started
2006-03-29 16:01:34 UTC CONFIG main: launching sched_start_mainloop
2006-03-29 16:01:34 UTC CONFIG main: loading current cluster configuration
2006-03-29 16:01:34 UTC CONFIG storeSet: set_id=1 set_origin=1 set_comment='test set'
2006-03-29 16:01:34 UTC DEBUG2 sched_wakeup_node(): no_id=1 (0 threads + worker signaled)
2006-03-29 16:01:34 UTC DEBUG2 main: last local event sequence = 7
2006-03-29 16:01:34 UTC CONFIG main: configuration complete - starting threads
2006-03-29 16:01:34 UTC DEBUG1 localListenThread: thread starts
2006-03-29 16:01:34 UTC FATAL  localListenThread: "select "_test1538".cleanupNodelock(); insert into "_test1538".sl_nodelock values (    1, 0, "pg_catalog".pg_backend_pid()); " - ERROR:  duplicate key violates unique constraint "sl_nodelock-pkey"

2006-03-29 16:01:34 UTC FATAL  Do you already have a slon running against this node?
2006-03-29 16:01:34 UTC FATAL  Or perhaps a residual idle backend connection from a dead slon?
</screen>

</question>

<answer><para> La table <envar>sl_nodelock</envar> est utilisée comme un 
<quote>verrou partagé</quote>pour empêcher que deux processus &lslon; essaient de prendre le controle du même noeud en même temps. Le &lslon; essaie d'insérer un enregistrement dans la table; il ne peut réussier que si il est le seul à gérer le noeud. </para></answer>

<answer><para> Ce message d'erreur est typiquement un signe que vous avez démarrez un second processus  &lslon;  pour un noeud donné.  Le &lslon; pose la question évidente qui est :  <quote>Avez vous déjà un slon démarré pour gérer ce noeud?</quote> </para></answer>

<answer><para> En supposant que vous subissez une panne de réseau,
les connections entre &lslon; et la base de données peuvent échouer, et  &lslon; peut s'en apercevoir bien avant l'instance de &postgres; sur laquelle il est connecté.
La conséquence en est qu'un certain nombre de connexion pré-établie vont rester ouvertes sur la base de données jusqu'à ce que le timeout de TCP/IP arrive à échéance, chose qui nomallement arrive au bout de  
deux heures. Durant cette période de deux heures, le &lslon; va essayer de se reconnecter, encore et encore, et obtient le message d'erreur ci-dessous, encore et encore. </para>

<para> Un administrateur peut mettre fin à cette situation en se connectant sur
le serveur et en lançant <command>kill -2</command> pour terminer les connexions bloquantes.
Malheureusement , puisque le problème a eu lieu au niveau de la couche  réseau,  &postgres; et &slony1; 
n'ont aucun moyen direct de détecter ceci. </para> 

<para> Vous pouvez éviter ceci dans <emphasis>la plupart</emphasis> des cas en vous assurant que le processus &lslon; est hébergé à proximité des serveurs qu'il gère. Si le &lslon;
est hébergé sur le même serveur que la base de donnée qu'il gère, alors
toute <quote>panne de réseau</quote> qui peut interrompre les connexions
serait susceptible d'être assez sérieuse pour menacer le serveur entier. </para></answer>
</qandaentry>


<qandaentry>
<question><para> Quand est-ce que je peux arrêter les processus &lslon;?</para></question>

<answer><para> Généralement, il n'y a aucun risque à arrêter un processus &lslon;. Chacun d'eux est un <quote>simplement</quote> un client de &postgres;, gérant un noeud, qui déploie des threads pour gérer et recevoir des évènements
depuis d'autres noeuds.  </para>

<para>Les threads des<quote>évènements d'écoute</quote> ne sont pas 
très importants; ils ne font que vérifier de temps en temps les noeuds distants pour déterminer si il y a des taches à faire sur le noeud local. Si vous tuez le processus &lslon; ces threads de surveillance seront fermés, qui aura peu ou pas du tout d'impact. Les éventements produits pendant que &lslon; est arrêté seront récupérés 
lors de son redémarrage.</para>

<para> Le thread de <quote>gestion des noeuds</quote> est un peu plus intéressant;  la plupart du temps sur un abonné, on peut s'attendre à ce que le ce thread traite des évènements <command>SYNC</command>. Si vous arrêtez le &lslon; durant un évènement, la transaction va échouer, et s'annuler, et lorsque &lslon; 
redémarre, il reprendra l'évènement pour l'exécuter.</para>

<para> L'unique situation où cela peut provoquer des problèmes  <emphasis>particulièrs</emphasis> est lorsque l'évènement  en cours est un traitement de longue durée comme,
un <command>COPY_SET</command> pour une large ensemble de réplication.</para>

<para>L'autre chose qui <emphasis>pourrait</emphasis> poser problème relativement distant du noeud auxquel il est connecté;
vous pouvez découvrir que les connexions de la base de données sont laissées <command>disponible en transaction</command> ("idle in transaction"). 
Ceci peut peut arriver si les  connexions réseaux  sont supprimées sans que &lslon; ni la base en ait pris connaissance 
.Dans ce cas vous pouvez découvrir que des connexions <quote>zombies</quote> traînent encore durant deux long heures
si vous n'y aller pas tuer à la main les processus &postgres;
.</para>

<TODO>

<para> Il y a un autre cas qui pourrait causer l'ennui; quand
&lslon; administrant son noeud d'attachement n'est pas en cours d'exécution
,aucun évènement <command>SYNC</command> s'exécute sur ce même serveur. Si le &lslon; 
 arrêté pour une longue durée, et que quelques chose du genre <xref linkend="gensync"/> n'est pas encours, 
vous pouvez vous retrouvez avec  <emphasis>un énorme<command>SYNC</command></emphasis> à effectuer
lorsque vous vous apprêtez à réaliser une sauvegarde.  Ceci est vrai seulement si &lslon; est en arrêt pendant une période 
assez longue; alors que un arrêt de quelques seconds ne génère pas de problème.</para> </answer>
</qandaentry>

<qandaentry>
<question><para> Y a-t-il des risques pour ce faire ? Quels en sont les avantages ?</para></question>

<answer><para> En bref, si votre <command>COPY_SET</command> prend environ 18h pour s'exécuter
finalement, ce n'est pas un grand sacrifice d'arrêter quelques moments un &lslon; 
ou peut-être même durant un cycle<emphasis>all</emphasis> de &lslon;s. </para> </answer>
</qandaentry>

</qandadiv>

<qandadiv id="faqconfiguration"> <title> &slony1; FAQ: Problèmes de configuration </title>
<qandaentry>
<question><para>Slonik tombe en erreur - ne peut pas charger les librairies &postgres;  -
<command>PGRES_FATAL_ERROR load '$libdir/xxid';</command></para>

<para> Lorsque j'exécute un simple script de configuration, j'obtiens un message similaire à
:

<command>
stdin:64: PGRES_FATAL_ERROR load '$libdir/xxid';  - ERROR:  LOAD:
could not open file '$libdir/xxid': No such file or directory
</command></para></question>

<answer><para> Evidemment, vous n'avez pas accès à la librairie
<filename>xxid.so</filename> dans le répertoire <envar>$libdir</envar>
où l'instance &postgres; est en usage. Notez que le composant &slony1;doit être installé sur le noyau du &postgres;
pour <emphasis>chacun des noeud</emphasis> et pas seulement sur le noeud d'origine.</para>

<para>Cela peut également venir du fait d'une disparité entre les binaires
du noyau  &postgres; et celui du noyau de  &slony1;. Si vous avez manuellement compilé &slony1;
vous même, sur une machine où il y a plusieurs noyau de
&postgres;  <quote>se trouvant autour,</quote> il est possible
que les binaires slon ou lslonik demande de charger une librairie qui n'est pas accessible
actuellement dans les répertoires du noyau de &postgres; gérant le cluster.</para>

<para>Court et concis: Ceci indique un besoin de <quote>auditer</quote>
quel mode d'installation de &postgres; et de &slony1; vous avez en place sur vos machines.
Malheureusement,n'importe quelle incompatibilité peut faire remonter ce genre
de soucis.  Voir aussi<link linkend="threadsafety">
sécurité des thread </link> à propos de la gestion des thread sur Solaris.
...</para> 

<para> La situation sera plus simple si vous aviez un seul noyau de &postgres; installé par serveur
dans ce cas il n'y aura pas d' <quote>incompatibilité
de chemins</quote> dans lequel les composants de &slony1; sont installés.</para>
Si vous avez une installation multiple,
vous devrez vous assurez de la compatibilité de la bonne 
versions de &slony1; associé à la bonne version du noyau de 
&postgres;. </answer></qandaentry>

<qandaentry>
<question> <para>J'essai de créer un cluster dont le nom contient un "-".
Cela ne marche pas!.</para></question>

<answer><para> &slony1; Utilise les même règles de nommage que &postgres;
alors  confirmation, il ne faudra pas utiliser un "-"
dans le nom.</para>

<para> Vous pouvez tenter de mettre des simples <quote>quotes</quote> pour l'identifiant
,mais vous allez vous exposer à des soucis, qui pourront surgir à tout moment.</para>
</answer>
</qandaentry>

<qandaentry>
<question><para>La commande ps affiche le mot de passe en claire</para>

<para> Si je lance une commande <command>ps</command>, tout le monde,
peut voir le mot de passe qui a été fourni à la ligne de commande.</para></question>

<answer> <para>Conservez vous mot de passe en dehors de la configuration Slony, en les mettant dans
des fichiers <filename>$(HOME)/.pgpass.</filename></para>
</answer></qandaentry>

<qandaentry>
<question><para>Sommaire de questions posées sur namespace

<programlisting>
set add table (set id = 1, origin = 1, id = 27, 
               full qualified name = 'nspace.some_table', 
               key = 'key_on_whatever', 
               comment = 'Table some_table in namespace nspace with a candidate primary key');
</programlisting></para></question>

<answer><para> Si vous avez <command> key =
'nspace.key_on_whatever'</command> la demande 
<emphasis>echoura</emphasis>.</para>
</answer></qandaentry>

<qandaentry>
<question> <para> La réplication a été retardée, et il semble que les interrogations pour restituer des données
depuis  <xref linkend="table.sl-log-1"/>/<xref
linkend="table.sl-log-2"/> prennent beaucoup de temps en indiquant quelques demande de 
<command>SYNC</command>s. </para>
</question>

<answer> <para> Jusqu'à la version 1.1.1, la table <xref
linkend="table.sl-log-1"/>/<xref linkend="table.sl-log-2"/>,possédait seulement un index, et si plusieurs jeu de réplication 
se mettaient en route en même temps, quelques colonnes dans l'indexe n'était pas très discriminent pour la manière d'accès.
Si l'index ne contient pas la colonne<function> log_xid</function>, il est conseillé de l'ajouter. Voir le script
<filename>slony1_base.sql</filename> pour regarder la manière de créer un indexe.
</para>
</answer>
</qandaentry>

<qandaentry><question> <para> J'ai besoin de renommer une colonne qui figure dans la clef 
primaire pour l'une de mes tables répliquées. L'opération s'avère un peu dangereuse, est-ce vrai ? 
Aurai-je à la recréer en dehors de la réplication ?</para>
</question>

<answer><para> Affirmatif, c'est un scénario qui fonctionne proprement.  &slony1; fait un usage intensif de
clef primaire, mais actuellement c'est ainsi et on espère une gestion intégrée et transparente  prochainement</para>.

<para> Supposez que vous souhaiter renommer une colonne, comme dans uns script sql, on utiliserais la 
commande DDL suivante<command> alter table accounts alter column aid rename to cid; </command> Ceci
permet de renommer la colonne dans la table; elle permet de manière 
<emphasis>transparente</emphasis> de effectuer la mise à jour dans clef primaire qui contient la colonne en question. 
Le résultat est que ce genre de changement s'effectue simultanément sur les différents composants, du noeud.</para>

<para> Dans l' <emphasis>ideal</emphasis> et pour bien faire les choses 
il aurait fallu utiliser <xref linkend="stmtddlscript"/> pour déployer la modification 
en étant sur que le bon changement s'applique aux bons noeuds.</para>

<para> Pour la clarté des choses, tant que la modification commence par la partie répliquée et bien avant les abonnés,
il n'y aura pas de cassure irrémédiable. Se retrouver avec quelques évènements de 
<command>SYNC</command> qui n'incluent pas la table sur laquelle il y a la modification, n'est pas un problème car ils vont se dérouler 
sans difficulté...  Par contre si le changement est signalé d'abord par un abonné, alors 
point that the first update to the table is drawn in by a subscriber,
<emphasis>ce</emphasis> sera le point de départ pour que 
<command>SYNC</command> tombe en erreur, puisque le fournisseur indiquera une 
<quote>nouvelle</quote>  colonne alors que l'abonné connait toujours
ses <quote>anciens</quote> formats. En appliquant la modification à postériori chez l'abonné, la commande
<command>SYNC</command>, peut retrouver le
<quote>nouveau</quote> nom de colonne et fonctionner sans plantage .
</para> </answer></qandaentry>

<qandaentry id="v72upgrade">
<question> <para> J'ai un &postgres; version 7.2 que je souhaite 
<emphasis>vraiment, vraiment</emphasis> employer avec &slony1; Que faut-il faire pour une migration en
version 8.2 ? Quel est l'implication pour récupérer &slony1; afin de les exploiter ensemble?</para>
</question>

<answer> <para> Voici l'écrit d'un certain Rod Taylor sur le sujet ...
</para>

<para> Voici ce dont approximativement vous avez besoin:</para>
<itemizedlist>
<listitem><para>Prendre les formulaire 7.3 et de mes copier en 7.2 -- ou bien de 
        mettre en dur 7.3 dans vos formulaire </para></listitem>
<listitem><para>Supprimer toute trace de schémas dans le code sql de vos formulaires. 
        Sommairement je remplace "." par "-". </para></listitem>
<listitem><para> Le bloc de travail relatif aux models de données XID ainsi quaux fonctions. 
        Par exemple, Slony crée des  CASTs pour  the xid en  xxid et vice versa -- mais 
        la 7.2 ne peut pas crée de nouveau casts et dans ce cas vous êtes obligé de le modifier à la main.
        Je rappelle la création d'une classe d'opérateur ainsi que l'édition de certaines fonctions. </para></listitem>
<listitem><para>sl_log_1 aura de grave problème de performance quelque soit le volume de données.
        Ceci exige qu'un certain nombre d'indexe soient positionnés pour optimiser les interrogations en 7.2. 7.3
        et supérieur. </para></listitem>
<listitem><para> Ne pas s'  embeter à essayer de travailler en séquence. Faites les à la main
        en utilisant pg_dump et grep. </para></listitem>
</itemizedlist>
<para> Bien sûr, une fois que ces pre-requis terminés, on n'est pas encore compatible avec
le Slony standard. Ainsi ou bien, vous devez au moins implémenter la 7.2 de manière artisanale
du moins, forcer slony à travailler sans les schémas dans la nouvelle version versions de &postgres; 
ainsi le dialogue entre les deux peut être établi.
</para>
<para> Juste après le déroulement de la procédure de migration de 7.2 vers 7.4, 
on peut désinstaller la version bidouillée de Slony (à la main encore pour la majeur partie), et démarrer la migration
de  7.2 à 7.4 sur les différentes machines en utilisant un Slony standard.
Ceci permettant de s'assurer sur la fiabilité d'un catalogue système qui avait subi des changement manuels.
</para>

<para> Tout cela pour dire, que nous migrons quelque centaine de GO de données,
de  7.2 a  7.4 en espace de 30 minutes. (contre 48 heures auparavant annoncées myeneant un dump et 
restore) sans pertes de données.
</para>
</answer>

<answer> <para> Ceci vous dresse un éventail assez laid qualifié de
<quote>bidouille</quote> qu'il faut admettre entrer dans le périmètre de production.
Si quelqu'un est intéressé pour le transformer en
<quote>tâche de production</quote>, il y aura un sens dans ce cas de s'appuyer sur
&slony1; en version 1.0, avec un maître mot de ne 
<emphasis>pas</emphasis> essayer de le rendre pérenne, étant donnée sa durée de vie limitée.</para>

<para> Vous devriez seulement adapter cette solution que si vous êtes à l'aise avec
&postgres; et &slony1; et que de mettre la main au code ne vous fait pas peur. </para> </answer>
</qandaentry>

<qandaentry>
<question> <para> J'avais un réseau <quote>pas performant</quote> qui m'obligeais à utiliser
 <xref linkend="stmtfailover"/> un basculement sur un noeud secondaire.
Le plantage n'était pas causé par un problème de corruption de donnée venant du disque,
Pourquoi serais-je obligé de reconstruire depuis le début, le noeud planté ? </para></question>

<answer><para> Le rôle de <xref linkend="stmtfailover"/> est d'
<emphasis>abandonner</emphasis> le noeud planté, et par conséquence il n'a plus de 
charge générée par l'activité de &slony1;. Plus le temps passe plus le serveur planté se désynchronise.</para></answer>

<answer><para> L'<emphasis>énorme</emphasis> problème afin de restaurer le serveur planté,
est qu'il peut contenir des mises à jours qui n'ont pas eu le temps de se propager endors.
Vous ne pouvez pas non plus les rejouer, car elles vont être conflictuelles, car à moitié en place.
En tout cas vous avez une sorte de corruption <quote>logique</quote>de donnée, qui n'est jamais causée par une erreur disque.
dite <quote>physique.</quote>
</para></answer>

<answer><para> Comme cela a été abordé en <xref linkend="failover"/>, utiliser <xref
linkend="stmtfailover"/> revient à accepter comme <emphasis>dernier
ressort</emphasis> tant qu'il implique d'abandonner le noeud d'origine pour cette corruption.</para></answer>
</qandaentry>


<qandaentry> <question><para> Après notification d'un abonnement sur un 
<emphasis>autre</emphasis> noeud, la réplication échoue sur l'un des abonnés, avec le message d'erreur suivant:</para>

<screen>
ERROR  remoteWorkerThread_1: "begin transaction; set transaction isolation level serializable; lock table "_livesystem".sl_config_lock; select "_livesystem".enableSubscription(25506, 1, 501); notify "_livesystem_Event"; notify "_livesystem_Confirm"; insert into "_livesystem".sl_event     (ev_origin, ev_seqno, ev_timestamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3, ev_data4    ) values ('1', '4896546', '2005-01-23 16:08:55.037395', '1745281261', '1745281262', '', 'ENABLE_SUBSCRIPTION', '25506', '1', '501', 't'); insert into "_livesystem".sl_confirm      (con_origin, con_received, con_seqno, con_timestamp)    values (1, 4, '4896546', CURRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or update on table "sl_subscribe" violates foreign key constraint "sl_subscribe-sl_path-ref"
DETAIL:  Key (sub_provider,sub_receiver)=(1,501) is not present in table "sl_path".
</screen>

<para> Par la suite l'erreur est suivie par un ensemble d'<xref
linkend="slon"/> arrêt: de syncs:</para>

<screen>
DEBUG2 remoteListenThread_1: queue event 1,4897517 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897518 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897519 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897520 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897521 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897522 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897523 SYNC
</screen>

</question>

<answer><para> Si vous regardez les journaux de &lslon; à l'arrêt avec des erreurs due à cet effet
<emphasis>d'arrêt</emphasis>, vous auriez besoin de revenir en arrière en ignorant une partie de
ces journalisation, 
<emphasis>en attendant</emphasis> après le redémarrage du serveur en erreur de trouver la cause d'origine.</para></answer>

<answer><para> Dans ce cas particulier, l'erreur est due à la commande
<xref linkend="stmtstorepath"/> qui n'est pas encore répercutée sur le noeud 4 en attendant la propagation 
de <xref linkend="stmtsubscribeset"/> command</para>

<para>Ceci démontre encore un autre exemple où l'approximatif ne devra pas prendre le dessus,
et que on doit avec assurance vérifier le bon fonctionnement des choses 
<emphasis>avant</emphasis> de suggérer un changement de la configuration.
</para></answer>

</qandaentry>

<qandaentry>

<question><para>J'ai juste utilisé <xref linkend="stmtmoveset"/> afin de déporter le noeud d'origine sur
un nouveau serveur. Malheureusement certains abonnés sont toujours attachés à l'ancien noeud que je viens de migrer,
or je ne peux les mettre hors service tant qu'il n'ont pas reçu le signalement de ce changement.
Que puis-je faire?  </para></question>

<answer><para> Vous avez besoin d'utiliser <xref linkend="stmtsubscribeset"/> afin de modifier les abonnements
 de ces serveurs abonnés, que leurs fournisseur <emphasis>sera</emphasis> indisponible durant une période maintenance.</para>

<warning> <para> Que vous avez <emphasis>omis</emphasis> de faire <xref
linkend="stmtunsubscribeset"/>; pour que vous soyez obligé de recommencer à rafraîchir les noeuds depuis le début.

</para></warning>
</answer>
</qandaentry>

<qandaentry>
<question><para> Après la notification d'un abonnement auprès 
<emphasis>d'un autre</emphasis> serveur fournisseur, la réplication tombe en erreur, et commençant des messages d'erreurs
avec :</para>

<screen>
ERROR  remoteWorkerThread_1: "begin transaction; set transaction isolation level serializable; lock table "_livesystem".sl_config_lock; select "_livesystem".enableSubscription(25506, 1, 501); notify "_livesystem_Event"; notify "_livesystem_Confirm"; insert into "_livesystem".sl_event     (ev_origin, ev_seqno, ev_timestamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3, ev_data4    ) values ('1', '4896546', '2005-01-23 16:08:55.037395', '1745281261', '1745281262', '', 'ENABLE_SUBSCRIPTION', '25506', '1', '501', 't'); insert into "_livesystem".sl_confirm      (con_origin, con_received, con_seqno, con_timestamp)    values (1, 4, '4896546', CURRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or update on table "sl_subscribe" violates foreign key constraint "sl_subscribe-sl_path-ref"
DETAIL:  Key (sub_provider,sub_receiver)=(1,501) is not present in table "sl_path".
</screen>

<para> Ceci est suivi plus tard par une série d'erreur de syncs puisque le <xref
linkend="slon"/> est à l'arrêt:

<screen>
DEBUG2 remoteListenThread_1: queue event 1,4897517 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897518 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897519 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897520 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897521 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897522 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897523 SYNC
</screen>

</para></question>

<answer><para> Si lors d'un arrêt, vous voyez dans le journal d'un &lslon;  
<emphasis>des nouveaux évènements ignorés dus à l'arrêt</emphasis> ,
c'est le cas parlant où il faut revenir une étape en arrière 
<emphasis>avant</emphasis> l'arrêt pour voir l'origine de l'erreur.
</para></answer>

<answer><para> Dans ce cas particulier, le problème était que certain 
 <xref linkend="stmtstorepath"/> commandes n'ont pas été transmises aux noeud 4 avant <xref linkend="stmtsubscribeset"/> 
 la commande soit propagée. </para>

<para>C'est encore un exemple où il ne faut pas hâtivement modifier les choses
;vous devrez avec certitude, constater le disfonctionnement 
<emphasis>avant</emphasis> de faire de nouveau changement de configuration.
</para></answer>

</qandaentry>

<qandaentry>
<question> <para> Est-ce que dans une configuration globale, l'ordre dans lequel, on traite les tables
est important ?</para>
</question>
<answer> <para> La plupart de temps il ne l'est pas. Vous devrez adapter un ordre selon lequel
les tables <quote>maîtres</quote> sont mises à jour avant celles de <quote>détails</quote>
en fonction de la relation de clef étrangère qui les relie; ceci ne sera <emphasis>pas exigé</emphasis> si sur le noeud abonné, 
on a pris le soin, de désactiver les déclencheurs.
</para>
</answer>

<answer> <para>(Les commentaires de Jan Wieck:) L'ordre des ID des tables
a une importance uniquement lors d'une opération de <xref linkend="stmtlockset"/> en préparation de basculement.
Si l'ordre est différent de celui selon lequel les applications obtiennent des verrous,
ces derniers peuvent se transformer en verrous mortels et par conséquent faire tomber l'application ou bien
<application>slon</application>.
</para>
<answer><para> (David Parker) Dans un autre cas, j'ai lancé l'opération où l'ordre des
tables avait une importance : en présence des tables avec les contraintes d'intégrité référentielles.
Si une table détail se présente avant celle de maître, alors le serveur abonné, supprime son 
contenu, avant qu'elle soit à nouveau rafraîchie, car la logique de la commande
<command>copy_set</command> vaut que <command>delete</command>,
ne soit pas un <command>delete only</command>, or la suppression des données de la table maître, impose bien la suppression de celle
de détail.
</para>
</answer></answer>

</qandaentry>

<qandaentry>

<question><para> Si votre script  <xref linkend="slonik"/> ressemble à quelque chose comme le suivant,
il peut tomber en erreur et ne jamais se terminer, car vous n'avez pas
<command>wait pour ev la mise à jour à nouveau. Bien sûr Of course, as mentioned
above, it could be faster to drop the node and recreate it than to let
ent</command> à l'intérieur d'un bloc de 
<command>try</command>. Un bloc de <command>try</command> est exécuté comme une seule et même transaction,
et l'évènement pour lequel vous êtes en attente, peut jamais avoir lieu
dans le scope de la transaction.</para>

<programlisting>
try {
      echo 'Moving set 1 to node 3';
      lock set (id=1, origin=1);
      echo 'Set locked';
      wait for event (origin = 1, confirmed = 3);
      echo 'Moving set';
      move set (id=1, old origin=1, new origin=3);
      echo 'Set moved - waiting for event to be confirmed by node 3';
      wait for event (origin = 1, confirmed = 3);
      echo 'Confirmed';
} on error {
      echo 'Could not move set for cluster foo';
      unlock set (id=1, origin=1);
      exit -1;
}
</programlisting></question>

<answer><para> Vous ne devez pas invoquer<xref linkend="stmtwaitevent"/>
à l'intérieur d'un bloc de<quote>try</quote>.</para></answer>

</qandaentry>

<qandaentry>
<question><para>Slony-I: cannot add table to currently subscribed set 1</para>

<para> J'ai essayé de rajouter une table à un jeu d'ensemble et j'ai le message
d'erreur suivant :

<screen>
	Slony-I: cannot add table to currently subscribed set 1
</screen></para></question>

<answer><para> Vous ne pouvez pas rajouter des tables à un ensemble pour lequel il y a des abonnées.
</para>

<para>Le contournement est de créer un <emphasis>AUTRE</emphasis>
jeu de table, d'y rajouter la table souhaitée, brancher les serveurs abonnés au "jeu 1" sur le nouveau qu'on vient de créer,et en suite de
fusionner les 2 jeux ensemble.</para>
</answer></qandaentry>

<qandaentry>
<question><para>
ERROR: duplicate key violates unique constraint "sl_table-pkey"</para>

<para>En essayant de monter un deuxième jeu de réplication, j'ai ce message :I tried setting up a second replication set, and got the following error:

<screen>
stdin:9: Could not create subscription set 2 for oxrslive!
stdin:11: PGRES_FATAL_ERROR select "_oxrslive".setAddTable(2, 1, 'public.replic_test', 'replic_test__Slony-I_oxrslive_rowID_key', 'Table public.replic_test without primary key');  - ERROR:  duplicate key violates unique constraint "sl_table-pkey"
CONTEXT:  PL/pgSQL function "setaddtable_int" line 71 at SQL statement
</screen></para></question>

<answer><para> Les identifaiants des tables utilisées dans  <xref linkend="stmtsetaddtable"/>
demande d'être unique <emphasis>A TRAVERS TOUT LE JEU</emphasis>.  Thus,
you can't restart numbering at 1 for a second set; if you are
numbering them consecutively, a subsequent set has to start with IDs
after where the previous set(s) left off.</para> </answer>
</qandaentry>

<qandaentry>
<question><para> L'un de mes serveurs tombe en erreur sur (&lslon; / postmaster was
down) et dont aucune notification depuis plusieurs jours.Maintenant lorsque &lslon; sur ce noeud démarre,
ll tourne durant cinq minutes, puis s'arrête,
avec l'erreur suivante : <command>ERROR: remoteListenThread_%d: timeout
for event selection</command> What's wrong, and what do I do? </para> 
</question>

<answer><para> Le problème est que le port d'écoute de ce processus (dans
<filename>src/slon/remote_listener.c</filename>) arrive à une expiration de temps, lors il tente
de déterminer quels est l'évènement à reprendre sur ce noeud.Par défaut
le délai d'expiration de cette interrogation est de 5 minutes; si la reprise contient plus d'évènement,
cela prendra beaucoup plus de temp.
 </para> </answer>

<answer><para> La réponse à cette question pour les versions de &slony1; antérieur à  1.1.7, 1.2.7, et à 1.3, serait de dire
d'augmenter le délai d'expiration dans
<filename>src/slon/remote_listener.c</filename>, de recompiler &lslon;, et enfin de ressayer.  </para> </answer>

<answer><para> Une autre réponse serait de conseiller de reconstruire entièrement le noeud ayant échoué, 
à l'aide de la commande &lslonik;  <xref linkend="stmtdropnode"/> en le supprimant d'abord et le recréer après.
Si les mises à jours sont volumineuses côté base de données, il vaut mieux reconstruir plutôt que d'essayer de rattraper.
</para> </answer>
  
<answer><para> Dans les version récentes de &slony1;, il y a une nouveau paramètre appelé :<xref
linkend="slon-config-remote-listen-timeout"/>;qui permet de modifier le délai d'expiration
et de relancer les mises à jour. Bien sûr, comme il a été mentionné ci-dessus, il est plus efficace dans ce cas
de supprimer et de recréer le noeud, que d'essayer de rattraper les mises à jours. </para> </answer>

</qandaentry>

</qandadiv>
<qandadiv id="faqperformance"> <title> &slony1; FAQ: Performance Issues </title>

<qandaentry id="longtxnsareevil">


<question><para> Replication has been slowing down, I'm seeing
<command> FETCH 100 FROM LOG </command> queries running for a long
time, <xref linkend="table.sl-log-1"/> is growing, and performance is,
well, generally getting steadily worse. </para>
</question>

<answer> <para> Les causes de ce genre de choses sont multiples.
Il y a une question évoquée par ce genre de pathologie, où le problème d'augmentation du volume dans
 <link linkend="pglistenerfull"> 
&pglistener; est dû au fait que la purge via vaccume n'est pas exécutée.</link>
</para>

<para> Par rapprochement <quote> on peut avancer </quote>, pour cette augmentation de volume,
est que une session existante sur le serveur rend le noeud
 <command>
IDLE IN TRANSACTION </command> pour une durée infinie. </para>

<para> La session ouverte peut avoir des effets négatifs,
entraînant une dégradation de performances.</para>

<itemizedlist>

<listitem><para> Le fait de lancer un Vacuum sur la totalité des tables,
&pglistener; y compris, ne va pas nettoyer les tuplets pour les transactions qui sont ouvertes et disponible, car elle 
viennent de démarrer. </para> </listitem>

<listitem><para> Le nettoyage des processus ne pourra pas se faire 
sur les entrées dans <xref linkend="table.sl-log-1"/> et <xref
linkend="table.sl-seqlog"/>, qui entraîne par conséquence, une croissance 
de volume tant que les transactions persistent. </para>
</listitem>
</itemizedlist>
</answer>

<answer> <para> Vous pouvez surveiller, dans la base, ces conditions que si
dans le fichier d'initialisation de &postgres; <filename> postgresql.conf </filename>
le paramètre <envar>stats_command_string</envar> est positionner à vrai.
Dans ce cas, vous pouvez lancer une intérrogation sql comme suit :
<command> select * from pg_stat_activity where current_query like '%IDLE% in transaction';
</command> dont le résultat vous donnent les activités relatives.  </para> </answer>

<answer> <para> Vous devrez également être capable de rechercher
les <quote> idle in transaction </quote> dans la table des processes 
ceux qui détiennent encore des transactions actives.
 </para> </answer>

<answer> <para> Il est aussi possible (quoique plus rare)que le problème soit causé par
une transaction, qui pour dautres raisons, est conservée comme ouverte et ceci pour une longue durée.
La table <envar> query_start </envar> time in <envar>
pg_stat_activity </envar> vous présentra les longues requêtes qui sont dans cet état. </para> </answer>

<answer> <para> Il est prévue que &postgres; aie un paramètre d'expiration de 
délai, <envar> open_idle_transaction_timeout </envar>, qui permettrais
de venir à bout des transactions dont le temps arrivent à échéance.

Le concept de connexion par pool, engendre ce genre de situation d'erreur.
Il est prévu des amélioration où <productname> <link linkend="pgpool"> pgpool
</link> </productname> devrait présenter des meilleurs alternatifs afin de mieux gérer les connexion partagée à
travers la notion de 'pool'.
Cela devrez faire diminuer les bugs rencontrés dans les applications
Java ou PHP;si un nombre restreint de <emphasis> vrai </emphasis>
connections sont conservées dans<productname>pgpool</productname>, ceci va faire croire à la base,
que en réalité  les connexions de l'application reste dans un statut 
disponible et en activité, pour de

J'avis lancé I have been running &slony1; on a node for a while, and am
s heures durant.
</para> </answer>

</qandaentry> 

<qandaentry id="faq17">
<question><para>Après une suppression de noeud, le fichier journal <xref linkend="table.sl-log-1"/>
n'est plus purgé.</para></question>

<answer><para> Ceci est un scénario commun dans les versions d'avant 1.0.5, comme
le <quote>nettoyage</quote> du prend effet en oubliant les entrées des
 tables &slony1; <xref linkend="table.sl-confirm"/>, pour le serveur qui vient de disparaître.</para>

<para> Le noeud ne s'occupe plus de mettre à jour des confirmations, comme quoi 
syncs vient de s'effectuer sur ce serveur, car il estime qu'il ne peut sans risque supprimer les entrées plus récentes
que la dernière <xref linkend="table.sl-confirm"/> entrée, qui plutôt
limite la capacité de purge des anciens fichiers journaux.</para>

<para>Diagnostics: Exécuter les requêtes suivantes pour voir si il y a 
un résidus d'entrées en état de <quote>fantôme/obsolète/bloqué</quote> <xref
linkend="table.sl-confirm"/>:

<screen>
oxrsbar=# select * from _oxrsbar.sl_confirm where con_origin not in (select no_id from _oxrsbar.sl_node) or con_received not in (select no_id from _oxrsbar.sl_node);
 con_origin | con_received | con_seqno |        con_timestamp                  
------------+--------------+-----------+----------------------------
          4 |          501 |     83999 | 2004-11-09 19:57:08.195969
          1 |            2 |   3345790 | 2004-11-14 10:33:43.850265
          2 |          501 |    102718 | 2004-11-14 10:33:47.702086
        501 |            2 |      6577 | 2004-11-14 10:34:45.717003
          4 |            5 |     83999 | 2004-11-14 21:11:11.111686
          4 |            3 |     83999 | 2004-11-24 16:32:39.020194
(6 rows)
</screen></para>

<para>En version 1.0.5, la fonction <xref linkend="stmtdropnode"/> 
purges les données dans <xref linkend="table.sl-confirm"/> pour le noeud qui quitte la configuration.
Dans les versions plus anciennes, cposés par quelques tables du groupe de réplication ? Cela bloquerait invisiblement That would somewhat-invisibly
eci demande une exécution manuelle.
Supposons que l'identifiant du noeud soit 3, alors la requête sera la suivante :


<screen>
delete from _namespace.sl_confirm where con_origin = 3 or con_received = 3;
</screen></para>

<para>Sinon, pour chasser <quote>tous les fantômes,</quote> vous pouvez utiliser 
<screen>
oxrsbar=# delete from _oxrsbar.sl_confirm where con_origin not in (select no_id from _oxrsbar.sl_node) or con_received not in (select no_id from _oxrsbar.sl_node);
DELETE 6
</screen></para>

<para>Une  <quote>raisonnable diligence</quote> dicterait de commencer par
<command>BEGIN</command>, voir le contenu de<command>SYNC</command> de se mettre à jour à l'origine, via le planificateur to be updated on the origin based on a
 
<xref linkend="table.sl-confirm"/> avant, 

Quelque noeud commencent à prendre du retard Some nodes start consistently falling behind
en veillant à ce que seul les bons enregistrements 
sont purgés, et puis, seulement après avoir vérifier cette suppression, valider l'opération par une  <command>COMMIT</command>.  Si 
vous supprimer par erreur les données d'un autre noeud, votre journée est perdu le temps de rattraper l'erreur commise.</para>

<para>Vous aurez besoin d'exécuter cette opération, sur chaque noeud qui reste...</para>

<para>A noter que dans la version 1.0.5, ce n'est plus un problème, car il purge les entrées inutiles
de <xref linkend="table.sl-confirm"/> à deux endroits :

<itemizedlist>
<listitem><para> Lorsque un noeud est supprimé</para></listitem>

<listitem><para> Au démarrage de chaque lancement de 
<function>cleanupEvent</function>, qui est l'évènement qui purge les vieilles données de
<xref linkend="table.sl-log-1"/> et de <xref
linkend="table.sl-seqlog"/></para></listitem> </itemizedlist></para>
</answer>
</qandaentry>

<qandaentry>

<question><para>Le <application>slon</application> se dépense un week-end entier hors de la 
commission [for some reason], et il prend énormément de temps pour exécuter un 
sync.</para></question>

<answer><para> Vous pourriez jeter un coup d'oeil, sur les tables <xref
linkend="table.sl-log-1"/>/<xref linkend="table.sl-log-2"/>, 
et voir brièvement si il y a réellement un énorme &slony1;
encours d'exécution. Jusqu'au au moins la version  1.0.2, il faut qu'il y ait un 
&lslon; connecté pour que <command>SYNC</command> soit encours.</para>

<para>Si cet évènement n'est pas généré, alors toute la mise à jour, et celle-ci jusqu'au prochain évènement va se faire 
à travers un énorme transaction &slony1;.</para>

<para>Conclusion: Même si il n'y a pas d'abonné en cause,
vous avez <emphasis>vraiment</emphasis> besoin d'un 
<application>slon</application> en fonctionnement pour entretenir le noeud source.</para>

<para>&slony1; 1.1 fournit une procédure stockée qui permet aux comptes Synchros d'être 
mis à jour par le planificateur <application>cron</application>même si <xref
linkend="slon"/> ne tourne pas en tâche de fond.</para> </answer></qandaentry>

<qandaentry id="pglistenerfull">
<question><para>Quelques noeuds commencent à se ralentir constamment. </para>

<para>J'avais lancé, depuis un moment, &slony1; sur un noeud, et je vois que la machine est à
genoux.</para>

<para>Je vois des instructions en cours comme :
<screen>
	fetch 100 from LOG;
</screen></para></question>

<answer><para> Ceci peut être un exemple type de &pglistener; (la table qui contient les données de 
<command>NOTIFY</command>)avec en abondance, des données obsolètes des tuplets mortes.


Ce qui fait que l'évènement <command>NOTIFY</command> prend du temps,
et cause le ralentissement de plus en plus fort du noeud affecté.</para>

<para>Vous avez probablement besoin d'effectuer un <command>VACUUM FULL</command> sur
&pglistener;, pour le nettoyer vigoureusement, et besoin de purger 
&pglistener; vraiment fréquemment. Une planification tous les cinq minutes fera l'affaire.</para>

<para> Le démon Slon fait déjà une purge d'un groupe de table,et
<filename>cleanup_thread.c</filename> contient une liste de tables à nettoyer fréquemment de manière automatique.
Dans &slony1; 1.0.2,&pglistener; ceci n'est pas inclus. Dans 1.0.5 et supérieur, il est purgé régulièrement,
du coup ce problème n'a plus le lieu d'être. Dans la version 1.2,
&pglistener; sera seulement utilisé quand le noeud reçoit périodiquement l'évènement,
ce qui signifie que ce problème la plupart du temps disparaître même
en présence des transaction longues et lentes...</para>

<para>Il y a, cependant, toujours un scénario où ceci peut
<quote>mordre toujours.</quote> Sous MVCC, vacuums ne peut pas supprimer des tuplets qui sont rendus 
<quote>obsolètes</quote> à n'importe quel moment après le démarrage de la transaction la plus ancienne
qui reste encore ouverte. Les transactions longues, devront être évitées, car elles sont sources de soucis, 
même sur un serveur abonné.</para> </answer></qandaentry>

<qandaentry> <question> <para> J'ai soumis un requête <xref
linkend="stmtmoveset"/> / <xref linkend="stmtddlscript"/>, et 
elle semble être coincée, sur mon serveur. Les journaux de &slony1; ne mon

La <command>restitution depuis LOG</command> procède à lire query will draw
trent 
pas d'qui est défini dans le fichier which is defined in the
erreurs ni d'avertissement </para> </question>

<answer> <para> Il est possible que vous soyez en train d'exécuter
<application>pg_autovacuum</application>, et qu'l soit tombait sur des verrous
posés par des tables dans le groupe de réplication ? Ceci voudra dire que de manière silencieuse
ock &slony1; est bloqué d'effectuer des opérations qui exigent l'acquisition des <link
linkend="locking"> exclusifs. </link> </para>


<para> Vous pourriez vérifier ce genre de verrous à l'aide de cette requête :
<command> select l.*, c.relname from pg_locks l, pg_class c
where c.oid = l.relation ; </command> Un verrous
<envar>ShareUpdateExclusiveLock</envar> va bloquer les opérations de &slony1;
qui nécessitent leurs propres verrous exclusifs, qui sont probablement en attentes, 
marqués comme n'étant pas garantis. </para>
</answer> </qandaentry>

<qandaentry>

<question><para> Je remarque que dans les journaux d'un &lslon; l'état commute fréquent 
entre le <quote>vote</quote>  démarré et arrêt. 
reporté fréquemment <quote>LISTEN - switch from polling mode to use
LISTEN</quote> et  <quote>UNLISTEN - switch into polling
mode</quote>. </para> </question>

<answer><para> Les seuils pour commuter entre ces modes sont commandés par 
le paramètres de configuration <xref
linkend="slon-config-sync-interval"/> et celui de <xref
linkend="slon-config-sync-interval-timeout"/>; si la valeur du temps d'expiration
(par défaut étant à 10000, impliquant 10s) est maintenu bas, facilite la situation pour que 
&lslon; décide de retourner à l'état  <quote>listening</quote>.
Vous devriez augmenter cette valeur d'expiration de temps. </para>
</answer>
</qandaentry>


</qandadiv>
<qandadiv id="faqbugs"> <title> &slony1; FAQ: &slony1; Bugs dans les versions anciennes</title>
<qandaentry>
<question><para>Le process &lslon; processes entretenant mes abonnés devient énorme en taille
, mettant en danger la ressource du système en terme de swap ainsi que le risque d'attendre la taille limite
de 2GB par processe . </para> 

<para> D'ailleurs, les données que je suis en train de répliquer,
ont une taille assez grande. Il y a des enregistrements dont la taille
dépasse des dizaine de mega octets.Peut-être ceci n'est pas approprié ? </para> </question>

<answer> <para> Oui, ces enregistrements volumineux sont à la racine du problème.
L'explication vient du fait que &lslon; normalement procède par paquet de
 100 enregistrement à la fois, lorsqu'un abonné fait des interrogation depuis le fournisseur.
Ainsi si la taille moyenne des enregistrements est de 
is 10MB, ceci entraîne des données atteignant 1000MB qui sont en attente de 
 <command>INSERT</command> ou de <command>UPDATE</command>
à procéder par le processe &lslon;.</para>

<para> Cela mène évidemment à &lslon; d'atteindre des tailles gigantesques. </para>

<para> Nombre d'enregistrement restitués par la valeur <envar> SLON_DTA_FETCH_SIZE </envar>,
défini par le fichier <filename>src/slon/slon.h</filename>. La partie extraite appropriée à ce paramètre est :
</para>
 
<programlisting>
#ifdef	SLON_CHECK_CMDTUPLES
#define SLON_COMMANDS_PER_LINE		1
#define SLON_DATA_FETCH_SIZE		100
#define SLON_WORKLINES_PER_HELPER	(SLON_DATA_FETCH_SIZE * 4)
#else
#define SLON_COMMANDS_PER_LINE		10
#define SLON_DATA_FETCH_SIZE		10
#define SLON_WORKLINES_PER_HELPER	(SLON_DATA_FETCH_SIZE * 50)
#endif
</programlisting>

<para> Si vous rencontrez ce problème, vous devriez définir
 <envar> SLON_DATA_FETCH_SIZE </envar>, peut-être réduit par un facteur de 10
 10, et de recompiler ensuite  &lslon;.  Il y a deux 
définitions dont <envar> SLON_CHECK_CMDTUPLES</envar> qui laisse faire une certaine surveillance
supplémentaire pour s'assurer que le abonnés ne sont pas tombé hors de la
SYNC en regard du fournisseur. Par défaut, cette option est désactivée, ainsi il faudra prendre la deuxième option,
afin de modifier la valeur par defeuillé, il faudra changer 
<envar> SLON_DATA_FETCH_SIZE </envar> pour remplacer  10 par 1. </para> </answer>

<answer><para> Dans la version 1.2, la configuration des valeurs de<xref
linkend="slon-config-max-rowsize"/> et de <xref
linkend="slon-config-max-largemem"/> sont associées avec un nouveau algorithme 
qui change la logique des choses, plutôt que de restituer 100
enregistrements à la fois.</para>

<itemizedlist>

<listitem><para> La lecture de <command>fetch from LOG</command> se fera
par paquet de 500 enregistrements à la fois, tant que la taille n'excède pas 
<xref linkend="slon-config-max-rowsize"/>.  Avec une valeur par défaut, ceci limitera 
ce phénomène de consommation de mémoire à la hauteur de 8MB.  </para>
</listitem>


<listitem><para> Les tuplets sont lus jusqu'à ce que la taille n'excède pas
le paramètre  <xref linkend="slon-config-max-largemem"/>.  Par défaut, cette restriction
ne consommera pas environ 5MB. Cette valeur n'est pas un seil de limitation stricte;
si vous avez des tuplets dont la taille est de 50MB, il <emphasis>doit</emphasis> de manière forcée,
être charger en mémoire. Il n'est pas question de négliger cela.
Mais &lslon; au moins, n'essayera pas  de charger, à la fois 100 enregistrements coûte que coûte, dépassant les 10GB de 
mémoire consommée à cet effet.</para> </listitem>
</itemizedlist>

<para> Ceci devrait alléger des problèmes que les gens avaient éprouvé, quand ils ont sporadiquement,
des séries de tuplets très volumineux. </para>
</answer>
</qandaentry>

<qandaentry id="faqunicode"> <question> <para> Je suis en train de répliquer
les données de type <envar>UNICODE</envar> depuis la version 8.0 de &postgres; à la  version 8.1, 
et rencontre des problèmes. </para>
</question>

<answer> <para> &postgres; 8.1 est un peu plus strict dans l'usage des codes caractères
UTF-8 et Unicode, comparé à la version 8.0.</para>

<para> Si vous êtes emmener à utiliser &slony1; pour migrer depuis une plus vieille version à celle  8.1, 
et que au passage vous devrez faire une conversion depuis le format UTF-8, vous auriez une surprise déplaisante.</para>

<para> Permettez de supposer que votre version de base est 8.0, avec l'encodage en UTF-8.
La base va accepter des séquences  <command>'\060\242'</command> en conformité avec UTF-8,
même si il ne peut vraiment pas. </para>

<para> Si vous répliquez dans des instance de &postgres; en version 8.1, il va se plaindre de cela,
, à la fois lors d'enregistrement d'un abonné, où &slony1; va râler 
à propos des codes caractères invalides qu'il vient de rencontrer durant la COPY des données,
qui empêcherait que l'enregistrement se fasse, ou, empêchant de rajouter les données,plutard, 
lorsqu'il se reproduira, la réplication tombera en erreur sans possibilité de reprise.
(Vous pouvez tricher sur le contenu de sl_log_1, mais assez rapidement 
cela deviendra <emphasis>vraiment</emphasis> inintéressante...)</para>

<para>Il y a déjà eu une discutions sur ce sujet pour savoir ce qu'il faudra faire.
Pour le moment une stratégie attractive ne se dégage pas sur le sujet. </para>

<para>Si vous utilisez Unicode avec la version 8.0 de &postgres;, vous courrez un risque
considérable de corrompre vos données. </para>

<para> Si votre réplication a pour but de convertir une fois pour toutes vos données,
il y a le risque évoqué; si cela vous arrive, il voudra mieux de convertir vos données de la version 8.0
d'abord et de re-essayer après. </para>

<para> A propos des risques encourus, exécuter la réplication en mettant en jeu des versions différentes,
semble être non pérennene à maintenir et qu'une migration vers 8.1 s'imposera. </para>

<para> Pour plus d'information, voir la discutions<ulink url=
"http://archives.postgresql.org/pgsql-hackers/2005-12/msg00181.php">
sur le groupe de discutions postgresql-hackers. </ulink>.  </para>
</answer>
</qandaentry>

<qandaentry>
<question> <para> J'utilise  &slony1; 1.1 avec 4+ nouds dans le jeu où il y a deux jeux d'abonnements,
 1 et 2, qui ne partagent pas d'autre noeuds. Je découvre que la confirmation pour le jeu 1
n'arrivent jamais pour le noeud souscrivant au jeu 2, et inversement, celles du jeu 2 n'arrivent pas non plus 
au noeud souscrivant au jeu 1. En conséquence, <xref
linkend="table.sl-log-1"/> crois et grossi et n'est jamais purgée. Ceci est mentionné
comme &slony1; <ulink
url="http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1485">
bug 1485 </ulink>.
</para>
</question>

<answer><para> Apparemment le code pour 
<function>RebuildListenEntries()</function> ne suffit pas pour ce cas.</para>

<para> <function> RebuildListenEntries()</function> sera rectifié dans &slony1; en version 1.2 
avec un algorithme couvrant ce cas. </para>
<para> 
Dans l'intérim, vous voudrez ajouter manuellement quelques entrées <xref linkend="table.sl-listen"/> utilisant <xref
linkend="stmtstorelisten"/> ou <function>storeListen()</function>,
basé sur les  (apparemment pas aussi désuet que nous avons pensé) principes décrits dans <xref linkend="listenpaths"/>.

</para></answer>
</qandaentry>

<qandaentry>
<question> <para> Je trouve que quelques colonnes de multibyte (Unicode, Big5) sont tronqués un peu, avec outre les derniers caractères truncés. Pourquoi?
</para> </question>

<answer> <para> C'était un bug présent jusqu'à la version 1.1.0 de &slony1; ; la manière dont des colonnes étaient capturées par la fonction <function>logtrigger()</function> qui coupait outre les derniers byte d'une colonne représentée dans un format de multibyte. Vérifiez pour voir que votre version de <filename>src/backend/slony1_funcs.c</filename> est bien 1.34 ou suppérieur; le e patch a été intégré dans la version  CVS de  1.34 de ce fichier.  </para> </answer>
</qandaentry>

<qandaentry id="sequenceset"><question><para> <ulink url=
"http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1226">
Bug #1226 </ulink> indique une condition d'erreur qui peut survenir si
vous faites placer une réplique composée seulement d'ordres.
</para>
</question>

<answer> <para> Une brève réponse serait de dire qu'une réplication composée seulement d'ordre, n'est pas une bonne pratique <link linkend="bestpractices">
.</link> </para>
</answer>

<answer>
<para> Le problème avec un ensemble d'ordre  seulement si vous avez un cas pour lequel les seuls abonnements qui sont en activité pour un abonné particulier vis à vis d'un fournisseur particulier, sont pour les jeux <quote>sequence-only</quote>. Si un noeud entre dans cet état,
la réplique échouera, étant donnée la requête qui collectera les données depuis <xref
linkend="table.sl-log-1"/> n'aura plus de tables à trouver et par conséquence la requête tombera en erreur.  S'un jeu de réplication de nouveau <emphasis>avec</emphasis>
des tables reapparît, tout va fonctionner correctement; il 
 <emphasis>paraîtra</emphasis> tout simplement effrayant.
</para>

<para> Ce problème devrait être résolu un certaine temps après &slony1;
1.1.0.</para>
</answer>
</qandaentry>

<qandaentry>
<question><para>Je dois supprimer une table d'un ensemble de réplication</para></question>
<answer><para>
Ceci peut être accompli de plusieurs manières, pas toutes également souhaitables;-).

<itemizedlist>

<listitem><para> Vous pourriez supprimer tout  le jeu de réplication, et les recréer avec juste les tables dont vous avez besoin.  Hélas, ce signifie reproduire un tas de données, et tue l'intérêt du cluster sur lequel cela se produit.</para></listitem>

<listitem><para> Si vous êtes en version 1.0.5 ou supérieur, il y a une commande SET DROP TABLE, qui fera  "l'affaire."</para></listitem>

<listitem><para> Si vous employez toujours 1.0.1 ou 1.0.2, l'
<emphasis>essentiel de la fonctionnalité de <xref linkend="stmtsetdroptable"/>
impliquant <function>droptable_int()</function> est présent.
Vous pouvez feuilleter cela à la main en trouvant l'identification de la table à supprimer, et que vous pouvez trouver dedans<xref
linkend="table.sl-table"/>, et après lancer les trois requêtes suivantes sur chaque noeud :</emphasis>

<programlisting>
  select _slonyschema.alterTableRestore(40);
  select _slonyschema.tableDropKey(40);
  delete from _slonyschema.sl_table where tab_id = 40;
</programlisting></para>

<para>Le schéma dépendra évidemment de la façon dont vous avez défini le cluster &slony1;. L'identifiant de la table, dans cet exemple, 40, sera à vous de remplacer par celui que vous voulez vous en débarrasser.</para>

<para> Vous devrez lancer ces trois interrogations sur tous les noeuds, de préférence premièrement sur le noeud d'origine, de sorte que la réplique de ses propagations soit correcte.
Implémenter ceci à travers un ordre de <xref linkend="slonik"/>
avec un nouveau &slony1; pourra se faire. La soumission des trois requêtes utilisant <xref linkend="stmtddlscript"/> peut le faire aussi.
Également il sera possible de se connecter à chaque base de données et de lancer les requêtes à la main.</para></listitem> </itemizedlist></para>
</answer>
</qandaentry>

<qandaentry>
<question><para>Je dois supprimer un ordre dans une séquence pour un ensemble de réplication</para></question>

<answer><para></para><para>Si vous êtes en version 1.0.5 ou supérieur, il y a une commande <xref linkend="stmtsetdropsequence"/> dans Slonik vous permettant de le faire en paralelle <xref linkend="stmtsetdroptable"/>.</para>

<para>Si vous êtes en version 1.0.2 ou antérieur, l'opération sera un peu plus manuel.</para>

<para>À supposer que je veux me débarrasser des deux ordres énumérés ci-dessous,<envar>whois_cachemgmt_seq</envar> and
<envar>epp_whoi_cach_seq_</envar>, we start by needing the
<envar>seq_id</envar> values.

<screen>
oxrsorg=# select * from _oxrsorg.sl_sequence  where seq_id in (93,59);
 seq_id | seq_reloid | seq_set |       seq_comment				 
--------+------------+---------+-------------------------------------
     93 |  107451516 |       1 | Sequence public.whois_cachemgmt_seq
     59 |  107451860 |       1 | Sequence public.epp_whoi_cach_seq_
(2 rows)
</screen></para>

<para>Les données à supprimer, afin d'éviter que soit propager, nécessite l'arrêt de Slony :

<programlisting>
delete from _oxrsorg.sl_seqlog where seql_seqid in (93, 59);
delete from _oxrsorg.sl_sequence where seq_id in (93,59);
</programlisting></para>

<para>Ces deux interrogations peuvent être soumises à l'ensemble des noeud via la fonction &funddlscript; / <xref
linkend="stmtddlscript"/>, éliminant l'ordre partout en 
<quote>même temps.</quote> Ou bien appliquer à la main à chacun des noeuds.</para>

<para>Similarly to <xref linkend="stmtsetdroptable"/>, this is
implemented &slony1; version 1.0.5 as <xref
linkend="stmtsetdropsequence"/>.</para></answer></qandaentry>

</qandadiv>

<qandadiv id="faqobsolete"> <title> &slony1; FAQ: Hopefully Obsolete Issues </title>

<qandaentry>
<question><para> &lslon; ne se remet pas en marche après un incident</para>

<para> Après un après brutal de &postgres; (en simulant une panne système)
dans &pglistener; un tuplets existe avec  <command>
relname='_${cluster_name}_Restart'</command>. slon ne démarre pas car 
il considère quune autre processe sert le  cluster sur ce noeud. Que puis-je faire? 
Le tuplet ne peut pas être supprimé dans la relation.</para>

<para> Le journal prétend que  <blockquote><para>un autre slon en tâche de fond
sert ce noeud déjà</para></blockquote></para></question>

<answer><para> Le problème est que la table système  &pglistener;, utilisée par
&postgres; à gérer l'évènement de notification, contiens quelques entrées pointant vers le central,
n'existent plus. La nouvelle instance de <xref
linkend="slon"/> se  connecte à la base, et elle est convaincue, par la
présence de ces entrées qu'un ancien
<application>slon</application> est toujours en activité pour s'occuper de ce noeud de &slony1;.</para>

<para> Le <quote>détritus</quote> dans cette table doit être nettoyer.</para>

<para>Il sera utile de maintenir un script manuel pour ce genre de situation:

<programlisting>
twcsds004[/opt/twcsds004/OXRS/slony-scripts]$ cat restart_org.slonik 
cluster name = oxrsorg ;
node 1 admin conninfo = 'host=32.85.68.220 dbname=oxrsorg user=postgres port=5532';
node 2 admin conninfo = 'host=32.85.68.216 dbname=oxrsorg user=postgres port=5532';
node 3 admin conninfo = 'host=32.85.68.244 dbname=oxrsorg user=postgres port=5532';
node 4 admin conninfo = 'host=10.28.103.132 dbname=oxrsorg user=postgres port=5532';
restart node 1;
restart node 2;
restart node 3;
restart node 4;
</programlisting></para>

<para> <xref linkend="stmtrestartnode"/> nettoie les notifications mortes
pour en suite redémarrer le noeud.</para>

<para>Comme en version 1.0.5, au démarrage de slon, les processes cherche ce genre de données obsolètes et les nettoient
le cas échéant.</para>

<para> Comme en version 8.1 de &postgres;, la  fonction manipulant
&pglistener; ne supporte pas cet usage, alors pour la version de &slony1; après 
1.1.2 (<emphasis>e.g. - </emphasis> 1.1.5), ce 
<quote>couplage</quote> est manipulé par l'intermédiaire d'une autre table, et l'issu de la situation est
rendu un peu plus transparent. <quote>.</quote> </para>

</answer></qandaentry>

<qandaentry><question><para> J'ai essayé la requête suivante qui ne marche pas:</para> 

<programlisting>
sdb=# explain select query_start, current_query from pg_locks join
pg_stat_activity on pid = procpid where granted = true and transaction
in (select transaction from pg_locks where granted = false); 

ERROR: could not find hash function for hash operator 716373
</programlisting>

<para> Il semble que &slony1; <function>xxid</function> les fonctions vont être 
dôtées de brouillage(hashing), qu'elles n'ont pas actuellement.</para>


<para> Que se passe-t-il ? </para>

</question>

<answer><para> &slony1; a défini un nouveau type de données et d'opérateurs XXID
ce type afin de permettre la manipulation des IDs de transaction qui sont employés
pour grouper ensemble, les mises à jour qui sont associées à la même transaction.
</para>

<para> Opérateurs qui n'étaient pas disponible pour &postgres; version 
7.3 et inférieur; afin de le rendre opérationnelle en 7.3, les fonctions spécifiques
doivent être ajoutées. L'opérateur <function>=</function>  
a été marqué comme soutenant
le hachage, mais pour que celui-ci travaille correctement, l'opérateur de jointure doit 
apparaître dans une classe d'opérateur d'index haché. Cela n'a pas été défini, 
et en conséquence, les requêtes (comme celle ci-dessus) qui décident d'employer 
le hash-joins échoueront. </para> </answer>

<answer> <para> Ceci  <emphasis> n'a pas </emphasis> 
été considéré comme bug <quote>release-critical</quote>, comme &slony1; 
ne produit probablement pas des intérrogations intérnes employant des hash-join. Ce problème ne devrait 
pas entacher &slony1; devant la capacité qu'il a de gérer la  réplication. </para> </answer>

<answer> <para> La nouvelle version de &slony1; (<emphasis>e.g.</emphasis>
1.0.6, 1.1) omettra l'indicateur <command>HASHES</command>, donc ceci
</para> </answer>

<answer> <para> Supposons que vous souhaitez réparer une instance existante, et vous constatez 
que vos propres scripts ne fonctionneront pas bien, vous pouvez suivre la démarche suivante : </para>

<programlisting>
/* cbbrowne@[local]/dba2 slony_test1=*/ \x     
Expanded display is on.
/* cbbrowne@[local]/dba2 slony_test1=*/ select * from pg_operator where oprname = '=' 
and oprnamespace = (select oid from pg_namespace where nspname = 'public');
-[ RECORD 1 ]+-------------
oprname      | =
oprnamespace | 2200
oprowner     | 1
oprkind      | b
oprcanhash   | t
oprleft      | 82122344
oprright     | 82122344
oprresult    | 16
oprcom       | 82122365
oprnegate    | 82122363
oprlsortop   | 82122362
oprrsortop   | 82122362
oprltcmpop   | 82122362
oprgtcmpop   | 82122360
oprcode      | "_T1".xxideq
oprrest      | eqsel
oprjoin      | eqjoinsel

/* cbbrowne@[local]/dba2 slony_test1=*/ update pg_operator set oprcanhash = 'f' where 
oprname = '=' and oprnamespace = 2200 ;
UPDATE 1
</programlisting>
</answer>

</qandaentry>
<qandaentry> <question><para> Je peux faire un <command>pg_dump</command>
et chargez les données en les sauvegardant, beaucoup plus rapidement que si <command>SUBSCRIBE
SET</command> les exécutait lui-même. Pourquoi c'est ainsi?  </para></question>

<answer><para> &slony1; dépend des index, supposons qu'il soit sur un  clef primaire, dont les feuilles se trouvant isolées (sans branches), en utilisant la commande
 &postgres; <command>COPY</command> les données sont lues rapidement.
Alors que il peut y avoir une dégradation de performance, provoquée par l'évènement <command>COPY SET</command> (un 
évènement généré par le souscripteur) dans la mesure où l'opération dans ce cas démarre par d'abord une suppression des contenus des tables, et rien que cela laisse des tuplets morts.</para>

<para> Lorsque vous utilisez <command>pg_dump</command> pour exporter le contenus de la base, et que vous les re-importez après, les indexes ne sont crées qu'à la fin. Ceci est <emphasis>beaucoup</emphasis> plus performant des reconstruire les indexes sur une table entièrement re-importée, plutôt que de refaire les indexes à la volet lorsque les enregistrement sont rajoutés un à un à la table.</para></answer>

<answer><para> Si d'emblée, vous pouvez supprimer des indexes inutiles, lorsque <command>COPY</command> se met en marche, les performances sont sensiblement améliorée. Encore mieux, si vous pouvez<command>TRUNCATER</command> les tables dont le contenu devra disparaître, les performance vont augmenter d'<emphasis>avantage.</emphasis> </para></answer>

<answer><para> &slony1; en version 1.1.5 et supérieur, fait cela automatiquement; il <quote>cogne</quote> sur les indexes dans le catalogue de &postgres; afin de les inhiber, de plus, de la même façon il désactive les déclencheurs, tout en les <quote>réactivant</quote> à la fin sans oublier de reconstruire les indexes des tables en question. </para> </answer>
</qandaentry>

<qandaentry id="dupkey">
<question><para>La réplication échoue - Violation des Constraintes unique</para>

<para>Alors que la Réplication se déroule correctement, depuis un bout de temps, lorsque le noeud rencontre <quote>intempestivement,</quote> des erreurs suivant envoyées dans le journal:

<screen>
DEBUG2 remoteWorkerThread_1: syncing set 2 with 5 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 1 with 41 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 5 with 1 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 3 with 1 table(s) from provider 1
DEBUG2 remoteHelperThread_1_1: 0.135 seconds delay for first row
DEBUG2 remoteHelperThread_1_1: 0.343 seconds until close cursor
ERROR  remoteWorkerThread_1: "insert into "_oxrsapp".sl_log_1          (log_origin, log_xid, log_tableid,                log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '34', '35090538', 'D', '_rserv_ts=''9275244''');
delete from only public.epp_domain_host where _rserv_ts='9275244';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '34', '35090539', 'D', '_rserv_ts=''9275245''');
delete from only public.epp_domain_host where _rserv_ts='9275245';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090540', 'D', '_rserv_ts=''24240590'''); 
delete from only public.epp_domain_contact where _rserv_ts='24240590';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090541', 'D', '_rserv_ts=''24240591''');
delete from only public.epp_domain_contact where _rserv_ts='24240591';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090542', 'D', '_rserv_ts=''24240589''');
delete from only public.epp_domain_contact where _rserv_ts='24240589';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '11', '35090543', 'D', '_rserv_ts=''36968002''');
delete from only public.epp_domain_status where _rserv_ts='36968002';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '11', '35090544', 'D', '_rserv_ts=''36968003''');
delete from only public.epp_domain_status where _rserv_ts='36968003';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090549', 'I', '(contact_id,status,reason,_rserv_ts) values (''6972897'',''64'','''',''31044208'')');
insert into public.contact_status (contact_id,status,reason,_rserv_ts) values ('6972897','64','','31044208');insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090550', 'D', '_rserv_ts=''18139332''');
delete from only public.contact_status where _rserv_ts='18139332';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090551', 'D', '_rserv_ts=''18139333'''); 
delete from only public.contact_status where _rserv_ts='18139333';" ERROR:  duplicate key violates unique constraint "contact_status_pkey"
 - qualification was: 
ERROR  remoteWorkerThread_1: SYNC aborted
</screen></para>

<para>La transaction s'annule, et &slony1; essaie à nouveau sans cesse.
Le problème est dû à une des <emphasis>dernière</emphasis> requête SQL
précisant  <command>log_cmdtype = 'I'</command>. Ce n'est pat tout à fait évident; ce qui se passe est que &slony1; regroupe 10 opérations de mise à jour, ensemble, afin de diminuer les aller-retour réseau.</para></question>

<answer><para> Une origine <emphasis>certaine</emphasis>  pour ceci est difficile à déterminer.</para>

<para>En même temps, nous notons qu'il y a un problème de transactions manquées concernant les suppressions qui sont déjà nettoyées dans <xref
linkend="table.sl-log-1"/>, et on constate qu'un recouvrement est impossible. A ce stade, ce qui semble nécessaire, est de supprimer le jeu de réplication (ou même carrément le noeud), est de redémarrer la réplication de début pour le noeud.</para>

<para>Dans &slony1; 1.0.5, l'opération de purge de <xref
linkend="table.sl-log-1"/> devient plus prudente, en refusant 
de purger des entrées qui n'ont pas encore été synchronisées. pour au moins 10 minutes sur l'ensemble des noeuds. Il n'est pas certain que ceci empêche que
<quote>le problème</quote> ait lieu, mais il paraît plausible que  cela laisse assez de volume dans <xref linkend="table.sl-log-1"/> permettant un recouvrement ou bien de permettre d'au moins de diagnostiquer plus exactement la situation. Et peut-être que le problème venait du fait que <xref linkend="table.sl-log-1"/> a été brutalement purgée, donc cette solution permet de résoudre complètement ce genre d'incident.</para>

<para> C'est une honte de reconstruire un réplication volumineuse sur un noeud,
si vous découvrez que le problème pérciste. La bonne idée serai de diviser la réplication
en plusieurs morceaux afin de dimin<envar>tgrelid</envar> en les pointant sur l'identifiant OID of the <quote>primary
key</quote> index on the table rather than to the table
uer la charge de travail lors de redémarrage de réplication.
Si un seul jeu est cassé, vous n'auriez qu'à désabonner et supprimer celui-ci.
</para>

<para> Dans un cas, nous avons trouvé deux lignes dans le journal d'erreur des requêtes sql
qui sont  <emphasis> identique </emphasis> concernant l'insertion dans
 <xref linkend="table.sl-log-1"/>. Ceci <emphasis> doit
</emphasis> être impossible d'autant plus qu'il s'agit d'une clef primaire sur <xref
linkend="table.sl-log-1"/>.  La dernière théorie, moins forte, laisserait à penser que cette situation
viendrait que <emphasis>cette</emphasis> clé serait peut-être corrompue (présence d'un bug de &postgres;), et afin de soulever ce doute, 
on peut exécuter l'ordre suivant:</para>

<programlisting>
# reindex table _slonyschema.sl_log_1;
</programlisting>

<para> Au moins dans une occasion cette solution s'est révélée efficace, alors cela sera dommage de ne pas suivre l'exemple.</para>
</answer>

<answer> <para> Ce problème s'est avéré comme un bug dans &postgres; par opposition à un autre dans &slony1;. La version 7.4.8 avait intégré deux solutions qui permettent de résoudre ce cas. Or si vous avez un noyau de &postgres; antérieur à 7.4.8,
vous devriez migrer d'abord pour éviter l'erreur.
</para>
</answer>
</qandaentry>
<qandaentry> <question><para>J'ai commencé à faire une sauvegarde via
<application>pg_dump</application>, et Slony
s'arrête soudainement</para></question>

<answer><para>Ouf. Ce qui se passe dans ce cas est à cause d'un conflit entre:
<itemizedlist>

<listitem><para> <application>pg_dump</application>, qui sort un <command>AccessShareLock</command> pour toutes les tables de la base, y compris celle de &slony1; et</para></listitem>

<listitem><para> Une synchronisation de &slony1; qui veut saisir
<command>AccessExclusiveLock</command> sur la table <xref
linkend="table.sl-event"/>.</para></listitem> </itemizedlist></para>

<para>La requête initiale qui est bloquée est :

<screen>
select "_slonyschema".createEvent('_slonyschema, 'SYNC', NULL);	  
</screen></para>

<para>(vous pouvez voir ceci dans<envar>pg_stat_activity</envar>, si votre paramètre d'affichage des requête est positionné à vrai dans
<filename>postgresql.conf</filename>)</para>

<para>L'interrogation encours qui cause ce verrous vient de la fonction  <function>Slony_I_ClusterStatus()</function>, que vous trouverez dans 
<filename>slony1_funcs.c</filename>, localisé dans un bloc de code qui est :

<programlisting>
  LOCK TABLE %s.sl_event;
  INSERT INTO %s.sl_event (...stuff...)
  SELECT currval('%s.sl_event_seq');
</programlisting></para>

<para>Le <command>VERROUS</command> se poste à ce moment et dure jusqu'à ce que 
<command>pg_dump</command> (ou le temps que les verrous bloquent les accès à <xref linkend="table.sl-event"/>)
se términe.</para>

<para>Chaque lecture touchant 
<xref linkend="table.sl-event"/> sera bloqué derrière les appels à 
<function>createEvent</function>.</para>

<para>Les réponses à cette question sont multiples:
<itemizedlist>

<listitem><para> Faire spécifier à <application>pg_dump</application> d'exporter le schéma en utilisant l'option <option>--schema=whatever</option>, et ne pas essayer d'exporter le schéma du cluster entièrement.</para></listitem>

<listitem><para> Il sera utile aussi d'ajouter une option 
<option>--exclude-schema</option> à 
<application>pg_dump</application> afin d'exclure le schéma du cluster de &slony1;. A rêver que dans 8.2...</para></listitem>

<listitem><para>Notez que 1.0.5 utilise des verrous plus précis et moins exclusifs qui soulage ce problème.</para></listitem>
</itemizedlist></para>
</answer></qandaentry>

</qandadiv>

<qandadiv id="faqoddities"> <title> &slony1; FAQ: Singularité des vulnérabilité dans Slony-I </title>
<qandaentry><question><para> Que se produit à propos des règles et des déclencheurs pour des tables répliquées  par 
&slony1;?</para>
</question>

<answer><para> Premièrement regardons comment elle  est gérée
<emphasis>l'absence</emphasis> de gestion spécifique de  la commande Slonik<xref
linkend="stmtstoretrigger"/>.  </para>

<para> La fonction <xref
linkend="function.altertableforreplication-integer"/> prépare chacune des tables
pour la réplication.</para>

<itemizedlist>

<listitem><para> Sur le noeud maître, ceci implique l'ajout d'un déclencheur
qui utilise la fonction <xref linkend="function.logtrigger"/> à la table.</para>

<para> Le déclencheur a pour action d'enregistrer, toutes les mises à jours dans 
la table <xref linkend="table.sl-log-1"/> de &slony1;.
</para></listitem>

<listitem><para> Sur un noeud d'abonné, répliquer une table, revient à désactiver les déclencheurs,
puis, via un déclencheur, de restreindre le droit d'accès en écriture sur celle-ci en
utilisant la fonction <function>denyAccess()</function>.</para>

<para> Jusqu'à la version 1.1 (et peut-être avant), le
<quote>désactivation</quote> est faite en modifiant
<envar>pg_trigger</envar> ou <envar>pg_rewrite</envar>
<envar>tgrelid</envar> en pointant l'identifiant OID sur 
la  <quote>clé primaire</quote> de l'index du catalogue, plutôt qu'une action directe sur la table
elle-même.</para></listitem>

</itemizedlist>

<para> Un effet secondaire quelque part malheureu de ces actions sur les règles et les déclencheurs
donne un effet de les <quote>piétiner</quote>. Dans la mesure où les règles et les déclencheurs sont toujours là, 
mais ne plus correctement attachés à leurs tables. Si vous faite un <command>pg_dump</command> sur 
<quote>le noeud d'abonné</quote>, il ne trouvera pas les contraintes  ni les déclencheur, et surtout il ne s'attend pas
à les voir associés à un indexe.</para>

</answer>

<answer> <para> Maintenant observer comment  <xref linkend="stmtstoretrigger"/>
entre en jeu.</para>

<para> Mettez simplement cette commande  pour que 
&slony1; restore les déclencheurs :
<function>alterTableRestore(table id)</function>, qui restaure l'identifiant OID 
de la table dans <envar>pg_trigger</envar> ou 
<envar>pg_rewrite</envar> <envar>tgrelid</envar> sur le noeud affecté.</para></answer> 

<answer><para> Ceci implique que le jour où vous souhaitez lancer une sauvegarde directement
sur un abonné, vous devrez reprendre le schéma depuis un noeud d'origine. Clairement il faudra faire : </para>

<screen>
% pg_dump -h originnode.example.info -p 5432 --schema-only --schema=public ourdb > schema_backup.sql
% pg_dump -h subscribernode.example.info -p 5432 --data-only --schema=public ourdb > data_backup.sql
</screen>

</answer>
</qandaentry>

<qandaentry> <question> <para> J'essaie de demander  <xref
linkend="stmtddlscript"/> ou <xref linkend="stmtmoveset"/>, et trouves
les messages suivants sur l'un des abonnés :</para>

<screen>
NOTICE: Slony-I: multiple instances of trigger defrazzle on table frobozz
NOTICE: Slony-I: multiple instances of trigger derez on table tron
ERROR: Slony-I: Unable to disable triggers
</screen>
</question>

<answer> <para> La  difficulté semble venir du fait que 
vous ajouter un déclencheur à une table dont le nom rentre en conflit,
avec le déclencheur que &slony1; cache. </para>

<para> &slony1; cache des déclencheurs (sauf ceux marqués comme <quote>unhidden</quote>
via <xref linkend="stmtstoretrigger"/>) en les attachant à la clé primaire de leur table.
Dans le cas d'une clef étrangère, d'autre déclencheurs sont rajoutés afin de garantir la cohérence des données.
Il est complètement inutile des les lancer depuis un abonné, ainsi ces déclencheurs doivent être provoquer 
depuis le noeud d'origine. En revanche, les déclencheurs de type
<quote>cache invalidation</quote> sont ceux que vous devrez lancer depuis l'abonné.</para>

<para> La <emphasis>bonne manière</emphasis> de manipuler ce genre de déclencheurs est d'utiliser
 <xref linkend="stmtstoretrigger"/>, qui indique à 
&slony1; de ne pas désactiver des déclencheurs. </para> </answer>

<answer> <para> Mais il peut y avoir quelques DBA intrépides, qui vont assumer individuellement ce travail on
installant les déclencheur à la main sur l'abonné, et donc capable de  créer ce genre de situation. Que faire?
</para>

<para> La réponse est assez simple : Retirez le déclencheur
<quote>spécifique</quote> sur l'abonné avant de dérouler la restauration.
Dans le meilleur des cas, si le DBA est intrépide et réactif, il aurait fait cela 
<emphasis>avant</emphasis> que le message ait le temps d'arriver. </para>

<para> Si le DBA n'est pas intrépide, la réponse serait de se connecter au noeud
offensé, et de supprimer la version <quote>visible</quote> du déclencheur utilisant l'ordre 
 <acronym>SQL</acronym> <command>DROP
TRIGGER</command>. Ceci permet à l'évènement de se dérouler.
Si l'évènement était <xref linkend="stmtddlscript"/>, alors notre 
<quote>pas-tellement-intrépide </quote> DBA devra ajouter le trigger à la main,
ou, s'il y a plus de sagesse, de les réactiver avec 
<xref linkend="stmtstoretrigger"/>.</para>
</answer>
</qandaentry>

<qandaentry id="neededexecddl">

<question> <para> Comportement - tous les noeuds d'abonné, ainsi que le noeud maître,
commence à se planter, crachant le message d'erreur suivant dans le journal,
(lorsque j'ai rencontré ce problème, il y avait une longue requête SQL devant chaque message ):</para>

<screen>
ERROR remoteWorkerThread_1: helper 1 finished with error
ERROR remoteWorkerThread_1: SYNC aborted
</screen>
</question>

<answer> <para> Cause: you have likely issued <command>alter
table</command> statements directly on the databases instead of using
the slonik <xref linkend="stmtddlscript"/> command.</para>

<para>La solution consiste à  remettre le trigger sur la table affectée,
et de corriger les données afférentes dans <xref linkend="table.sl-log-1"/> by hand.</para>

<itemizedlist>

<listitem><para> Vous avez besoin d'extraire du journal soit de slon, soit
du &postgres; l'ordre sql exact qui a causé l'anomalie.</para></listitem>

<listitem><para> Vous avez besoin de corriger le déclencheur Slony-defined dans la table 
en question. Ceci peut se faire à l'aide de la procédure suivante :</para>

<screen>
BEGIN;
LOCK TABLE table_name;
SELECT _oxrsorg.altertablerestore(tab_id);--tab_id is _slony_schema.sl_table.tab_id
SELECT _oxrsorg.altertableforreplication(tab_id);--tab_id is _slony_schema.sl_table.tab_id
COMMIT;
</screen>

<para>Ensuite vous avez besoin de sélectionner les enregistrements dans  <xref
linkend="table.sl-log-1"/> qui sont incohérent pour les corriger. Il faudra ensuite arrêter
les processes de Slon pour l'ensemble des noeuds excepté celui du maître;
de cette manière vous évitez que l'erreur se propage immédiatement à travers tous les noeuds.</para>

<para> Voici un exemple:</para>

<screen>
BEGIN;

LOCK TABLE customer_account;

SELECT _app1.altertablerestore(31);
SELECT _app1.altertableforreplication(31);
COMMIT;

BEGIN;
LOCK TABLE txn_log;

SELECT _app1.altertablerestore(41);
SELECT _app1.altertableforreplication(41);

COMMIT;

--fixing customer_account, which had an attempt to insert a "" into a timestamp with timezone.
BEGIN;

update _app1.sl_log_1 SET log_cmddata = 'balance=''60684.00'' where pkey=''49''' where log_actionseq = '67796036';
update _app1.sl_log_1 SET log_cmddata = 'balance=''60690.00'' where pkey=''49''' where log_actionseq = '67796194';
update _app1.sl_log_1 SET log_cmddata = 'balance=''60684.00'' where pkey=''49''' where log_actionseq = '67795881';
update _app1.sl_log_1 SET log_cmddata = 'balance=''1852.00'' where pkey=''57''' where log_actionseq = '67796403';
update _app1.sl_log_1 SET log_cmddata = 'balance=''87906.00'' where pkey=''8''' where log_actionseq = '68352967';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125180.00'' where pkey=''60''' where log_actionseq = '68386951';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125198.00'' where pkey=''60''' where log_actionseq = '68387055';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125174.00'' where pkey=''60''' where log_actionseq = '68386682';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125186.00'' where pkey=''60''' where log_actionseq = '68386992';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125192.00'' where pkey=''60''' where log_actionseq = '68387029';

</screen>
</listitem>

</itemizedlist>
</answer>

</qandaentry>

<qandaentry> 

<question><para> Le noeud numéro 1 a été supprimé via <xref
linkend="stmtdropnode"/>, et le &lslon; d'un des noeuds fait cracher le message 
d'erreurs suivant:</para>

<screen>
ERROR  remoteWorkerThread_3: "begin transaction; set transaction isolation level
 serializable; lock table "_mailermailer".sl_config_lock; select "_mailermailer"
.storeListen_int(2, 1, 3); notify "_mailermailer_Event"; notify "_mailermailer_C
onfirm"; insert into "_mailermailer".sl_event     (ev_origin, ev_seqno, ev_times
tamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3
   ) values ('3', '2215', '2005-02-18 10:30:42.529048', '3286814', '3286815', ''
, 'STORE_LISTEN', '2', '1', '3'); insert into "_mailermailer".sl_confirm
(con_origin, con_received, con_seqno, con_timestamp)    values (3, 2, '2215', CU
RRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or updat
e on table "sl_listen" violates foreign key constraint "sl_listen-sl_path-ref"
DETAIL:  Key (li_provider,li_receiver)=(1,3) is not present in table "sl_path".
DEBUG1 syncThread: thread done
</screen>

<para> Evidemment une demande de  <xref linkend="stmtstorelisten"/> n'avait pas encore
été propagé avant que le noeud 1 soit éliminé.</para></question>

<answer id="eventsurgery"><para> Ceci indique le cas où vous avez besoin de 
<quote>opération chirurgicale</quote> sur l'un ou plusieurs noeuds.
Un évènement<command>STORE_LISTEN</command> demeure sans réponse lorsqu'il veut 
ajouter un port d'écoute qui <emphasis>ne peut pas</emphasis> être satisfait car 
le noeud 1 ainsi que tous les éléments indiquant ce noeud sont disparus.</para>

<para> Supposons que pour la démonstration, les noeuds encore en place
soient le 2 et le 3, ainsi le rapport d'erreur est remonté au noeud 3.</para>

<para> cela implique que l'évènement se généré sur le noeud 2, comme il ne peut être sur le 
noeud 3, si il n'a pas été traité avec succès. La manière la plus facile à faire face à cette situation,
est, de supprimer sur le noeud offensé, les données dans <xref linkend="table.sl-event"/> relatives au noeud 2.
Vous vous connectez à la base du noeud 2, et à l'aide de Sql suivant, de chercher l'évènement
<command>STORE_LISTEN</command>:</para>

<para> <command> select * from sl_event where ev_type =
'STORE_LISTEN';</command></para>

<para> L'ordre peut ramener plusieurs lignes, mais ne en supprimer que la partie nécessaire.</para>

<screen> 
-# begin;  -- Don't straight delete them; open a transaction so you can respond to OOPS
BEGIN;
-# delete from sl_event where ev_type = 'STORE_LISTEN' and
-#  (ev_data1 = '1' or ev_data2 = '1' or ev_data3 = '1');
DELETE 3
-# -- Seems OK...
-# commit;
COMMIT
</screen>

<para> La prochaine fois que <application>slon</application> pour le noeud 3 redémarre, 
il ne trouvera plus le <quote>souffrant</quote> évènement 
<command>STORE_LISTEN</command>, et la réplication peur se poursuivre.
(Vous pouvez par contre voir surgir un vieil évènement enregistré qui ne soit plus en phase 
avec la configuration existante...) </para></answer>

</qandaentry>
</qandadiv>

</qandaset>
