<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modifications
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<qandaset>
<indexterm><primary>Foire Aux Questions de &slony1;</primary></indexterm>

<qandadiv id="faqcompiling"><title> &slony1; FAQ: Compiler et Installer &slony1; </title>

<qandaentry>

<question><para> J'utilise <productname> Frotznik Freenix
4.5</productname>, avec son système de gestion de paquetages <acronym>FFPM</acronym> (Frotznik Freenix Package Manager).  Il existe des paquets
<acronym>FFPM</acronym> pour &postgres; 7.4.7, que j'utilise actuellement
comme base de données, mais il n'y a pas encore de paquetages &slony1;.
Comment puis-je rajouter &slony1; à cette distribution ?  </para>
</question>


<answer><para> <productname>Frotznik Freenix</productname> c'est nouveau pour moi,
alors il est un peu dangereux, de donner une réponse définitive, concise et rapide.  </para>

<para> Les réponses différent légèrement selon les diverses combinaisons de versions entre
&postgres; et &slony1; Il est légérement plus facile, avec les versions récentes, de faire face à ce genre de questions qu'avec les versions plus anciennes. En général, vous devez presque certainement recompiler &slony1; depuis les sources; selon les versions
des deux composants &slony1; et &postgres;, vous
<emphasis>devez</emphasis> également recompiler &postgres; à partir de zéro.
(Savoir si vous devez <emphasis> utilisez </emphasis> la version compilée de &postgres; 
est un autre problème; en général ce n'est pas le cas...) </para>

<itemizedlist>

<listitem><para> &slony1; la version 1.0.5 et ultérieur nécessite d'avoir une version  complètement configurées des sources de &postgres;, afin de recompiler
&slony1;.</para>

<para> <emphasis>Heureusement </emphasis> vous pouvez adapter la configuration pour qu'elle corresponde à la configuration utilisée nativement par la paquet d'origine, en vérifiant la 
version de &postgres; avec la commande
<command> pg_config --configure</command>. </para> </listitem>

<listitem> <para> &slony1; La version 1.1 simplifie considérablement les choses;
dans la mesure où vous êtes dispensé d'avoir la version complète de de sources de &postgres;, au lieu de cela, elle se réfère aux emplacements des librairies,
des binaires, de la configuration, et  <command> des fichiers #include </command>.
</para> </listitem>

<listitem><para> &postgres; 8.0 et supérieur est généralement plus facile car l'<quote>installation par défaut</quote> contient la totalité des fichiers d'inclusion <command> #include </command>.  </para>

<para> Si vous utilisez une version antérieure de &postgres;, il est préférable d'utiliser une version installée à partir des sources, 
en particulier si la version packagée ne contient  <quote> les fichiers d'inclusions<command>#include</command></quote> du serveur. Ces fichiers peuvent être installés par la commande <command> make install-all-headers </command>.</para>
</listitem>

</itemizedlist>

<para> En pratique, la <quote>pire situation</quote> est un scénario où 
vous utilisez une version de &slony1; antérieure à 1.1 avec une
<quote>vieille</quote> version de &postgres;, dans ce cas vous devez compiler &postgres;
à partir de zéro afin d'avoir tout les pré-requis de compilation de &slony1; même si  
vous utilisez une version<quote>packagée</quote> de &postgres;.</para>

<para> Si vous utilisez une version récente de &postgres; et une version récente de &slony1;,
alors les dependences peuvent être assez faibles, et vous n'avez pas  besoin de fichiers sources complémentaires.  Ces améliorations devraient soulager la mise en production des
paquets de &slony1;  de sorte que vous pourriez même pouvoir espérer éviter la compilation
de &slony1;.</para>

</answer>

<answer><para> </para> </answer>

</qandaentry>

<qandaentry id="missingheaders">
<question><para> J'essaie d'installer &slony1; 1.1 et j'obtiens le message d'erreur suivant:
<screen>
configure: error: Headers for libpqserver are not found in the includeserverdir.
   This is the path to postgres.h. Please specify the includeserverdir with
   --with-pgincludeserverdir=&lt;dir&gt;
</screen>
</para></question>

<answer><para> Vous exécutez certainement une version &postgres; 7.4
ou antérieure, où les en-têtes de serveur ne sont pas installés par défaut, il vous suffit dans ce cas de lancer la commande <command>make install</command> de &postgres;.</para>

<para> Vous devez installer les en-têtes du serveur lors d'installation de &postgres; via la commande <command>make install-all-headers</command>.

</para> </answer> </qandaentry>

<qandaentry id="threadsafety">

<question><para> &slony1; semble se compiler correctement; maintenant, lorsque j'exécute un &lslon;, certain évènements se déclenchent, mais la réplication ne se met pas 
route.</para>

<para> Les logs de Slony ressemble à ça :

<screen>
DEBUG1 remoteListenThread_1: connected to 'host=host004 dbname=pgbenchrep user=postgres port=5432'
ERROR  remoteListenThread_1: "select ev_origin, ev_seqno, ev_timestamp,
		  ev_minxid, ev_maxxid, ev_xip,
		  ev_type,
                  ev_data1, ev_data2,
		  ev_data3, ev_data4,
 	          ev_data5, ev_data6,
		  ev_data7, ev_data8 from "_pgbenchtest".sl_event e 
where (e.ev_origin = '1' and e.ev_seqno > '1') order by e.ev_origin, e.ev_seqno" - could not receive data from server: Operation now in progress
</screen>
</para>

<para> Parfois ils contiennent les lignes suivantes  ...

<screen>
ERROR  remoteListenThread_2: "select ev_origin, ev_seqno, ev_timestamp,
ev_minxid, ev_maxxid, ev_xip,        ev_type,        ev_data1, ev_data2,
ev_data3, ev_data4,        ev_data5, ev_data6,        ev_data7, ev_data8
from "_sl_p2t2".sl_event e where (e.ev_origin = '2' and e.ev_seqno >
'0') order by e.ev_origin, e.ev_seqno" - could not receive data from
server: Error 0
</screen> 
</para>
</question>

<answer><para>Sur AIX et Solaris (et probablement sur d'autre OS), 
&slony1; <emphasis>et &postgres;</emphasis> doivent être compilés avec l'option <option>--enable-thread-safety</option> .  Le message ci-dessus arrive lorsque la compilation
de &postgres; n'a pas fait appel à cette option.</para>

<para>Le disfonctionnement ici vient du fait que le libc (indépendant des threads) et libpq
(basés sur les threads) utilisent des emplacements de mémoire différente pour les codes d'erreur, c'est qui fait échouer les requêtes.</para>

<para>Des problèmes de ce genre surviennent avec des régularités surprenantes sur AIX et sur Solaris. Il sera probablement nécessaire
de réaliser un <quote>audit du code objet</quote> pour s'assurer que  <emphasis>tous</emphasis> les composants nécessaire ont été compilés et linkés avec l'option <option>--enable-thread-safety</option>.</para>

<para>Par exemple, on peut rencontrer un problème sur Solaris lorsque 
<envar>LD_LIBRARY_PATH</envar> est défini et  pointe sur les
librairies depuis d'une ancienne version compilée de &postgres;. Cela signifie que même si
la base de donnée <emphasis>avait été</emphasis> compilée avec l'option 
<option>--enable-thread-safety</option>, et même si 
<application>slon</application> a été recompilé pour cette version, lors de l'édition de lien dynamique de
<application>slon</application> pointait sur un 
<quote>ancienne mauvaise version compilée sans l'option thread-safe,</quote>, et donc slon ne fonctionne pas.  On ne peut s'apercevoir de cela qu'en exécutant <command>ldd</command>
sur <application>slon</application>.</para> </answer>

<answer><para> A noter que la version   7.4.2 de libpq sur Solaris nécessite <link linkend="threadpatch"> un patch supplémentaire pour les threads </link> ; Ce pré-requis est également demandé pour &postgres; version 8.0.
</para>
</answer>
</qandaentry>

<qandaentry id="pg81funs">

<question> <para> Je suis en train de migrer sur une nouvelle version de &slony1;
et je me débat avec un problème avec <xref
linkend="stmtupdatefunctions"/>.  Lors d'exécution de <xref
linkend="stmtupdatefunctions"/>, mon
<application>postmaster</application> plante avec le signal 11.
Le fichier log ne contient aucune erreur, exceptées celles relatives à
&postgres; les logs indiquent simplement que le postmaster est bel bien tombé.</para>

<para> En scrutant le fichier core avec un déboggueur, on constate que
l'incident survient lors de la validation d'une transaction. </para>

<para> Pour infos je suis sur &postgres; 8.1.[0-3]. </para>
</question>

<answer> <para> Malheureusement les anciennes versions de &postgres; 8.1 avait un problème lors de la re-définition d'une fonction ( par exemple <function>upgradeSchema(text)</function>), lorsque la fonction est appellée juste après, au sein de la même transaction,
, le
<application>postmaster</application> plante et la
transaction est annulée.  </para>

<para> La commande &lslonik; <xref linkend="stmtupdatefunctions"/>
fonctionne de cette manière; dans une même transaction elle effectue ceci :

<itemizedlist>
<listitem><para> Charger les nouvelles fonctions (depuis <filename>slony1_funcs.sql</filename>), notamment comprenant <function>upgradeSchema(text)</function>.
</para> </listitem>
<listitem><para> Lancer <function>upgradeSchema(text)</function> pour effectuer la migration nécessaire des schémas de la base. </para> </listitem>
<listitem><para> Avertir les processus &lslon; du changement de configuration.</para> </listitem>
</itemizedlist>
</para>

<para> Malheureusement, en &postgres; 8.1.0, 8.1.1, 8.1.2, et 8.1.3,
ceci est conflictuel avec un bug où l'utilisation et la modification d'une fonction plpgsql au sein de la même transaction
provoque un plantage. </para>

<para> Plusieurs contournements sont envisageables. </para>

</answer>

<answer> <para> La meilleur solution consiste à migrer &postgres; vers une version 8.1.4 ou supérieure. Les changements entre deux versions mineures ne nécessite pas la reconstruction de la base, il suffit simplement d'installer la nouvelle version puis de redémarrer le <application>postmaster</application> avec cette nouvelle version.  </para>
</answer>

<answer><para> Si cette solution ne convient pas, il est possible d'effectuer la mise à jour via une série de transaction  <quote>à la main</quote>, qui correspondent à ce que &lslonik; aurait fait pour cette migration. </para>

<itemizedlist>
<listitem><para> Prendre <filename>slony1_funcs.sql</filename> et faire trois remplacements dans ce fichier: </para> 

<itemizedlist>
<listitem><para> Remplacer <quote>@CLUSTERNAME@</quote>avec le nom du cluster</para> </listitem>
<listitem><para> Remplacer <quote>@MODULEVERSION@</quote> avec la version de &slony1; par exemple <quote>1.2.10</quote> </para> </listitem>
<listitem><para> Remplacer <quote>@NAMESPACE@</quote> avec le nom du namespace du cluster <quote>entre doubles quotes</quote> , par exemple "_monCluster" </para> </listitem>
</itemizedlist>
</listitem>
<listitem><para> Recharger dans la base cet ensemble de fonctions <quote>mise à jour</quote>.</para> </listitem>
<listitem><para> Exécuter la fonction stockée via <command>select <function>upgradeSchema('1.2.7')</function>; </command>, 
en supposant que la précédente version de &slony1; en cours était la 1.2.7. </para> </listitem>
<listitem><para> Le redémarrage de tous les processus &lslon; est probablement une sage décision après ce genre de <quote>chirurgie.</quote> </para> </listitem>
</itemizedlist>
</answer>
</qandaentry>

<qandaentry>
<question> <para> Problème d'installation sur Fedora/x86-64 </para>

<para> Lorsqu'on essaie de configurer &slony1; sur système Fedora x86-64,
où <application>yum</application> a été utilisé pour une installation du paquetage
<filename>postgresql-libs.x86_64</filename>, le message suivant se manifeste :

<screen>
configure: error: Your version of libpq doesn't have PQunescapeBytea
 this means that your version of PostgreSQL is lower than 7.3
 and thus not supported by Slony-I.
</screen></para>

<para> Ceci arrive avec &postgres; 8.2.5, ce qui est nettement plus récent que la version 7.3. </para>
</question>

<answer> <para> La fonction <application>configure</application> est à la recherche du symbole PQunescapeBytea, elle compile un petit programme qu'il l'appele et vérifie la compilation se passe bien. Dans la ligne de commande <command>gcc</command>, elle utilise <command>-lpq</command> pour chercher la librairie. </para>


<para> Malheureusement, ce paquetage n'a pas de lien symbolique, reliant <filename>/usr/lib64/libpq.so</filename> à
<filename>libpq.so.5.0</filename>; c'est pourquoi la fonction configure n'arrive pas à trouber libpq.  
Le <emphasis>vrai</emphasis> problème c'est que le compilateur n'arrive pas à trouver une librairie pour l'édition de lien, et non pas que libpq ait manqué à l'appel.
</para>

<para> Au final, ces informations doivent être envoyée vers ceux qui gèrent le paquet <filename>postgresql-libs.x86_64</filename>. </para>
</answer>

<answer> <para> Notez que ce même symptôme peut être révélateur d'autres problèmes de ce genre  au niveau de la configuration système. Les mauvais liens symboliques, les mauvaises permissions, le mauvais comportement de la part de votre compilateur C, tout peuvent potentiellement mener à ce même message d'erreur. </para> 

<para> Ainsi si vous rencontrez cette erreur, vous aurez besoin de regarder le fichier log
<filename>config.log</filename>.  Cherchez à partir du bas, et regardez quel est le souci <emphasis>réellement</emphasis> rencontré.
Ceci sera utile pour trouver la vrai racine de cet épineux problème.</para>
</answer>

</qandaentry>

</qandadiv>

<qandadiv id="faqconnections"> <title> &slony1; FAQ: Problèmes relatifs aux connections</title>
<qandaentry>

<question><para>Je cherche le namespace<envar>_clustername</envar>, et 
il est introuvable.</para></question>

<answer><para> Si le DNS sont erronés, alors l'instance &lslon;
ne pourra pas se connecter aux noeuds.</para>

<para>Ceci mène au fait que les noeuds seront introuvables.</para>

<para>Revérifier la configuration des connexions. D'ailleurs, puisque <xref linkend="slon"/> est lié à libpq, vous pouvez stocker le mot de passe dans <filename> $HOME/.pgpass</filename>, le problème vient peut-être d'une erreur dans ce fichier.</para>
</answer>
</qandaentry>

<qandaentry id="morethansuper">
<question> <para> J'ai créé un compte <quote>super-utilisateur</quote>,
<command>slony</command>, pour exécuter les activités de réplications. Comme suggéré,
je l'ai configuré comme super-user, avec la requête suivante : 
<command>
update pg_shadow set usesuper = 't' where usename in ('slony',
'molly', 'dumpy');
</command>
(Cette même commande permet d'autoriser autres utilisateurs d'exécuter vacuums et
sauvegarde).</para>

<para> Malheureusement, je suis tombé en erreur, à chaque fois où je voulais souscrire à un nouveau ensemble.</para>

<programlisting>
DEBUG1 copy_set 28661
DEBUG1 remoteWorkerThread_1: connected to provider DB
DEBUG2 remoteWorkerThread_78: forward confirm 1,594436 received by 78
DEBUG2 remoteWorkerThread_1: copy table public.billing_discount
ERROR  remoteWorkerThread_1: "select "_mycluster".setAddTable_int(28661, 51, 'public.billing_discount', 'billing_discount_pkey', 'Table public.billing_discount with candidate primary key billing_discount_pkey'); " PGRES_FATAL_ERROR ERROR:  permission denied for relation pg_class
CONTEXT:  PL/pgSQL function "altertableforreplication" line 23 at select into variables
PL/pgSQL function "setaddtable_int" line 76 at perform
WARN   remoteWorkerThread_1: data copy for set 28661 failed - sleep 60 seconds
</programlisting>

<para> Cela continue de planter, encore et toujours, jusqu'à ce que je redémarre <application>slon</application> pour qu'il se connecte avec le compte <command>postgres</command>.</para>
</question>

<answer><para> Le problème est assez évident en soi; la permission sur la table de système <envar>pg_class</envar> est ignorée.</para></answer>

<answer><para> La <quote>solution</quote> est la suivante:</para>
<programlisting>
update pg_shadow set usesuper = 't', usecatupd='t' where usename = 'slony';
</programlisting>
</answer>

<answer><para> En version 8.1 et supérieure, vous avez aussi besoin de:</para>
<programlisting>
update pg_authid set rolcatupdate = 't', rolsuper='t' where rolname = 'slony';
</programlisting>
</answer>
</qandaentry>

<qandaentry>
<question><para> Au moment d'enregistrer un esclave, j'obtiens le message suivant dans les logs :

<screen>
DEBUG1 copy_set 1
DEBUG1 remoteWorkerThread_1: connected to provider DB
WARN	remoteWorkerThread_1: transactions earlier than XID 127314958 are still in progress
WARN	remoteWorkerThread_1: data copy for set 1 failed - sleep 60 seconds
</screen></para></question>

<answer> <para> Il y a évidemment un certain nombre de vieilles transactions qui empêche &slony1; de traiter des synchronisations. Vous devriez jeter un coup d'oeil à pg_locks pour ce qu'il en est :</para>

<screen>
sampledb=# select * from pg_locks where transaction is not null order by transaction;
 relation | database | transaction |  pid    |     mode      | granted 
----------+----------+-------------+---------+---------------+---------
          |          |   127314921 | 2605100 | ExclusiveLock | t
          |          |   127326504 | 5660904 | ExclusiveLock | t
(2 rows)
</screen>

<para>Vous voyez ? la transaction 127314921 est en effet plus vieilles que la transaction 127314958, et elle est toujours en cours d'exécution.</para>

<para> Un long traitement de publi-postage, une requête <application>RT3</application> qui s'emballe, un
<application>pg_dump</application>, toutes ces opérations ouvrent des transactions pour une période importante.
Jusqu'à ce qu'elles soient complétées ou bien interrompues, on verra alors le message d'erreur suivant:
<quote> data copy
for set 1 failed - sleep 60 seconds </quote>.</para>

 
<para>Quoiqu'il en soit, s'il y a plus d'une base de données sur le cluster du &postgres; , et que la charge se situe sur une autre base, vous verrez apparaitre des <quote>transactions en cours avec un XID
antérieur</quote> à celle de &slony1;.  Le fait que la transaction se déroule sur une base de donnée dissociée ne change rien ; &slony1; attendra jusqu'à ce que ces vieilles transactions se terminent.</para>
</answer>
</qandaentry>


<qandaentry>
<question><para>Même question que précèdemment.  J'ai oublié de mentionner que j'essayais d'ajouter 
<emphasis>DEUX</emphasis> abonnés, simultanément.</para></question>

<answer><para> Cela ne peut pas marcher: &slony1; ne peut employer la commande
<command>COPY</command> de manière concurrente.  Voir  la fonction
<function>copy_set()</function> dans le fichier <filename>src/slon/remote_worker.c</filename></para>

<screen>
$ ps -aef | egrep '[2]605100'
postgres 2605100  205018	0 18:53:43  pts/3  3:13 postgres: postgres sampledb localhost COPY 
</screen>
 
<para>Une transaction <command>COPY</command> 
essaie d'installer l'abonnement pour un des noeuds. Tout a l'air bien; 
le système s'occupe de configurer le premier abonné; il ne vapas démarrer sur le second tant que le premier n'a pas fini son enregistrement. Cela représente une cause possible.</para>

<para>Ceci a comme (facheuse) conséquence que vous ne pouvez pas peupler deux esclaves simultanément à partir d'un même fournisseur. Vous devez souscrire un et un seul abonné à la fois,
une fois qu'il a accompli l'abonnement,( en copiant le contenu des table, etc.), on peut s'occuper de débuter l'enregistrement
du deuxième.</para></answer>
</qandaentry>

<qandaentry id="missingoids"> <question> <para> Nous avons rencontré un message inattendu en désinstallant entièrement un cluster de réplication slony sur le maître et l'esclave.</para>

<warning> <para><emphasis>MAKE SURE YOU STOP YOUR APPLICATION RUNNING
AGAINST YOUR MASTER DATABASE WHEN REMOVING THE WHOLE SLONY
CLUSTER</emphasis>, or at least re-cycle all your open connections
after the event!  </para></warning>

<para> The connections <quote>remember</quote> or refer to OIDs which
are removed by the uninstall node script. And you will get lots of
errors as a result...
</para>


</question>

<answer><para> Il y a deux mécanismes de 
&postgres; qui mettent en cache les plans d'interrogation et les OIDs:</para>
<itemizedlist>
<listitem><para> Les requêtes préparées ("prepared statements")</para></listitem>
<listitem><para> Les fonctions pl/pgSQL </para></listitem>
</itemizedlist>

<para>Ce problème n'est pas pas particulier à &slony1;; 
il se produit à chaque fois quand des modifications importantes sont apportées aux schémas de la base 
de données. Cela n'entaine pas de perte des données, mais cela provoque des vagues d'erreurs relatives aux OID.
</para></answer>

<answer><para> Le problème survient lorsque vous utilisez une sorte de 
<quote>pool de connexion</quote> qui recycle les vieilles connexions.
Si vous relancez l'application après ceci, les nouvelles connexions
vont produire de <emphasis>nouveau</emphasis>plan d'exécution et les erreurs disparaitront. Si votre pool de connexion tue les sessions, et en recrée de nouvelles, alors ces nouvelles sessions auront de <emphasis>nouveaux</emphasis> plans d'exécution, et que les erreurs disparaîtront. </para></answer>
 
<answer> <para> Dans notre code nous éliminons toutes connexions ayant des erreurs inattendues dans
le contexte. Ainsi, toutes les connexions devraient être renouvelées dès l'apparition d'une erreur
inattendue. Naturellement si l'erreur remonte une violation de contrainte, qui est une condition reconnue, ce va provoquer une renouvellement de connexion,  et si le problème persiste, les connexions sont recyclées en permanence, ce qui annulera l'effet du pool, dans ce cas, le pooler de connexion proposera probablement à l'administrateur de jeter un coup d'oeil à la situation. </para> </answer>

</qandaentry>

<qandaentry><question><para> J'ai migré mon  &slony1; en version
1.2.  J'ai maintenant cet avertissement dans les logs:</para>

<screen>NOTICE:  Slony-I: log switch to sl_log_2 still in progress - sl_log_1 not truncated</screen>

<para> Les tables <envar>sl_log_1</envar> et <envar>sl_log_2</envar> continue de prendre du volume, 
et <envar>sl_log_1</envar> n'est jamais vidée.
Quel est le souci?
</para> </question>

<answer><para> Ceci est un cas symptomatique du problème précèdent,
relatif à la suppression de réplication : s'il y a des vieilles connexions établies, qui continuent à utiliser des plan d'exécutions
basés sur des vieilles fonctions stockées, ce qui provoque des écritures dans  <envar>sl_log_1</envar> </para>

<para> La fermeture des vieilles connexions et l'ouverture des nouvelles connexions, résoudra ce problème.</para> </answer> 

<answer> <para> A plus long terme, il y a un item dans la TODO liste de &postgres; pour implémenter une vérification des dépendances, qui pourra supprimer un plan d'exécution caché, lorsque un objet lié à ce plan est modifié. </para> </answer>
</qandaentry>

<qandaentry>
<question><para>J'ai pointé un noeud abonné vers un noeud fournisseur différent, et il a cessé la réplication.</para></question>

<answer><para>
Nous avons constaté que ceci arrive lorsque on réinitialise un noeud dans la configuration suivante: 

<itemizedlist>
<listitem><para> Noeud 1 - fournisseur</para></listitem>
<listitem><para> Noeud 2 - abonné au noeud 1 - le noeud que l'on réinitialise</para></listitem>
<listitem><para> Noeud 3 - abonné au noeud 3 - le noeud qui doit continuer à répliquer</para></listitem>
</itemizedlist></para>

<para>L'abonnement du noeud 3 est changé pour que le noeud 1 soit
son fournisseur et on exécute <xref linkend="stmtdropset"/> /<xref
linkend="stmtsubscribeset"/> sur le noeud 2 pour qu'il soit repeuplé.</para>

<para>Malheureusement, la réplication s'arrête soudainement sur le noeud 3.</para>

<para>Le problème vient du fait qu'il n'y a pas d'ensemble approprié de
<quote>voies d'écoute</quote> dans la table <xref linkend="table.sl-listen"/> pour propager les évènements 
depuis le noeud 1 vers sur le noeud 3. Les événements sont transportés vers le noeud 2 et sont bloqués par l'événement  <xref linkend="stmtsubscribeset"/> que le noeud 2 est en train de traiter.</para>

<para>Le script suivant supprime les voies d'écoute qui font transiter les events par le noeud 2 et ajouter une voie d'écoute directe entre  les noeuds 1 et 3.

<programlisting>
cluster name = oxrslive;
 node 1 admin conninfo='host=32.85.68.220 dbname=oxrslive user=postgres port=5432';
 node 2 admin conninfo='host=32.85.68.216 dbname=oxrslive user=postgres port=5432';
 node 3 admin conninfo='host=32.85.68.244 dbname=oxrslive user=postgres port=5432';
 node 4 admin conninfo='host=10.28.103.132 dbname=oxrslive user=postgres port=5432';
try {
  store listen (origin = 1, receiver = 3, provider = 1);
  store listen (origin = 3, receiver = 1, provider = 3);
  drop listen (origin = 1, receiver = 3, provider = 2);
  drop listen (origin = 3, receiver = 1, provider = 2);
}
</programlisting></para>

<para>Juste après l'éxécution de ce script, les événements <command>SYNC</command> se propagent à nouveau vers le noeud 3.

Ceci souligne deux principes:
<itemizedlist>
<listitem><para>
Si vous avez plusieurs noeuds, et des abonnés en cascade,
vous devez faire attention en repeuplant les entrés <xref
linkend="stmtstorelisten"/>, et en modifiant si la structure de l'<quote>arbre</quote> de réplication a changé.</para></listitem>

<listitem><para> La version 1.1 fourni des meilleurs outils pour gérer ce cas.</para>
</listitem>

</itemizedlist></para>

<para>Les problèmes relatifs aux <quote>voies d'écoute</quote> sont discutés plus précisions dans la section <xref linkend="listenpaths"/> </para></answer>
</qandaentry>

<qandaentry id="multipleslonconnections">

<question><para> En redémarrant  &lslon;, j'obtiens
les messages <quote>FATAL</quote> suivants dans le log. Que se passe-t-il??? </para>
<screen>
2006-03-29 16:01:34 UTC CONFIG main: slon version 1.2.0 starting up
2006-03-29 16:01:34 UTC DEBUG2 slon: watchdog process started
2006-03-29 16:01:34 UTC DEBUG2 slon: watchdog ready - pid = 28326
2006-03-29 16:01:34 UTC DEBUG2 slon: worker process created - pid = 28327
2006-03-29 16:01:34 UTC CONFIG main: local node id = 1
2006-03-29 16:01:34 UTC DEBUG2 main: main process started
2006-03-29 16:01:34 UTC CONFIG main: launching sched_start_mainloop
2006-03-29 16:01:34 UTC CONFIG main: loading current cluster configuration
2006-03-29 16:01:34 UTC CONFIG storeSet: set_id=1 set_origin=1 set_comment='test set'
2006-03-29 16:01:34 UTC DEBUG2 sched_wakeup_node(): no_id=1 (0 threads + worker signaled)
2006-03-29 16:01:34 UTC DEBUG2 main: last local event sequence = 7
2006-03-29 16:01:34 UTC CONFIG main: configuration complete - starting threads
2006-03-29 16:01:34 UTC DEBUG1 localListenThread: thread starts
2006-03-29 16:01:34 UTC FATAL  localListenThread: "select "_test1538".cleanupNodelock(); insert into "_test1538".sl_nodelock values (    1, 0, "pg_catalog".pg_backend_pid()); " - ERROR:  duplicate key violates unique constraint "sl_nodelock-pkey"

2006-03-29 16:01:34 UTC FATAL  Do you already have a slon running against this node?
2006-03-29 16:01:34 UTC FATAL  Or perhaps a residual idle backend connection from a dead slon?
</screen>

</question>

<answer><para> La table <envar>sl_nodelock</envar> est utilisée comme un 
<quote>verrou partagé</quote>pour empêcher que deux processus &lslon; essaient de prendre le controle du même noeud en même temps. Le &lslon; essaie d'insérer un enregistrement dans la table; il ne peut réussier que si il est le seul à gérer le noeud. </para></answer>

<answer><para> Ce message d'erreur est typiquement un signe que vous avez démarrez un second processus  &lslon;  pour un noeud donné.  Le &lslon; pose la question évidente qui est :  <quote>Avez vous déjà un slon démarré pour gérer ce noeud?</quote> </para></answer>

<answer><para> En supposant que vous subissez une panne de réseau,
les connections entre &lslon; et la base de données peuvent échouer, et  &lslon; peut s'en apercevoir bien avant l'instance de &postgres; sur laquelle il est connecté.
La conséquence en est qu'un certain nombre de connexion pré-établie vont rester ouvertes sur la base de données jusqu'à ce que le timeout de TCP/IP arrive à échéance, chose qui nomallement arrive au bout de  
deux heures. Durant cette période de deux heures, le &lslon; va essayer de se reconnecter, encore et encore, et obtient le message d'erreur ci-dessous, encore et encore. </para>

<para> Un administrateur peut mettre fin à cette situation en se connectant sur
le serveur et en lançant <command>kill -2</command> pour terminer les connexions bloquantes.
Malheureusement , puisque le problème a eu lieu au niveau de la couche  réseau,  &postgres; et &slony1; 
n'ont aucun moyen direct de détecter ceci. </para> 

<para> Vous pouvez éviter ceci dans <emphasis>la plupart</emphasis> des cas en vous assurant que le processus &lslon; est hébergé à proximité des serveurs qu'il gère. Si le &lslon;
est hébergé sur le même serveur que la base de donnée qu'il gère, alors
toute <quote>panne de réseau</quote> qui peut interrompre les connexions
serait susceptible d'être assez sérieuse pour menacer le serveur entier. </para></answer>
</qandaentry>


<qandaentry>
<question><para> Quand est-ce que je peux arrêter les processus &lslon;?</para></question>

<answer><para> Généralement, il n'y a aucun risque à arrêter un processus &lslon;. Chacun d'eux est un <quote>simplement</quote> un client de &postgres;, gérant un noeud, qui déploie des threads pour gérer et recevoir des évènements
depuis d'autres noeuds.  </para>

<para>Les threads des<quote>évènements d'écoute</quote> ne sont pas 
très importants; ils ne font que vérifier de temps en temps les noeuds distants pour déterminer si il y a des taches à faire sur le noeud local. Si vous tuez le processus &lslon; ces threads de surveillance seront fermés, qui aura peu ou pas du tout d'impact. Les éventements produits pendant que &lslon; est arrêté seront récupérés 
lors de son redémarrage.</para>

<para> Le thread de <quote>gestion des noeuds</quote> est un peu plus intéressant;  la plupart du temps sur un abonné, on peut s'attendre à ce que le ce thread traite des évènements <command>SYNC</command>. Si vous arrêtez le &lslon; durant un évènement, la transaction va échouer, et s'annuler, et lorsque &lslon; 
redémarre, il reprendra l'évènement pour l'exécuter.</para>

<para> L'unique situation où cela peut provoquer des problèmes  <emphasis>particulièrs</emphasis> est lorsque l'évènement  en cours est un traitement de longue durée comme,
un <command>COPY_SET</command> pour une large ensemble de réplication.</para>

<para>L'autre chose qui <emphasis>pourrait</emphasis> poser problème relativement distant du noeud auxquel il est connecté;
vous pouvez découvrir que les connexions de la base de données sont laissées <command>disponible en transaction</command> ("idle in transaction"). 
Ceci peut peut arriver si les  connexions réseaux  sont supprimées sans que &lslon; ni la base en ait pris connaissance 
.Dans ce cas vous pouvez découvrir que des connexions <quote>zombies</quote> traînent encore durant deux long heures
si vous n'aller pas tuer à la main les processus &postgres;
.</para>

<para> Il y existe un autre cas qui peut poser problème : quand

le processus &lslon; qui administre le noeud origine ne fonctionne pas, 
aucun évènement <command>SYNC</command> ne s'exécute sur ce noeud. 
Si le &lslon; reste arrêté pendant une longue durée, et qu'aucun processus de type 
<xref linkend="gensync"/> n'est en cours, alors vous pouvez vous retrouvez avec  
<emphasis>un énorme <command>SYNC</command></emphasis> à effectuer
lorsque le processus &lslon; du noeud origine sera relancé.  
Toutefois ceci est vrai seulement si &lslon; est en arrêt pendant une période 
assez longue; un arrêt de quelques secondes ne génère pas de problèmes.</para> </answer>
</qandaentry>

<qandaentry>
<question><para> Y a-t-il des risques lorsque l'on arrête &lslon; ? Quels sont les avantages ?</para></question>

<answer><para> En bref, si un <command>COPY_SET</command> qui dure 18h n'est pas en cours d'exécution
, alors ce n'est pas un grand sacrifice d'arrêter un &lslon; pendant quelques instants, ni même
de relancer <emphasis>tous</emphasis> les  &lslon;s. </para> </answer>
</qandaentry>

</qandadiv>

<qandadiv id="faqconfiguration"> <title> &slony1; FAQ: Problèmes de configuration </title>
<qandaentry>
<question><para>Slonik tombe échoue lors du chargement des librairies &postgres; : 
<command>PGRES_FATAL_ERROR load '$libdir/xxid';</command></para>

<para> Lorsque j'exécute un simple script de configuration, j'obtiens un message similaire à :

<command>
stdin:64: PGRES_FATAL_ERROR load '$libdir/xxid';  - ERROR:  LOAD:
could not open file '$libdir/xxid': No such file or directory
</command></para></question>

<answer><para> Evidemment, vous n'avez pas accès à la librairie
<filename>xxid.so</filename> dans le répertoire <envar>$libdir</envar>
que l'instance &postgres; utilise. Notez que les composants &slony1; doivent être installés avec le noyau du &postgres;
sur <emphasis>chacun des noeuds</emphasis> et pas seulement sur le noeud d'origine.</para>

<para>Cela peut également venir du fait d'une disparité entre les binaires du noyau  &postgres; et celui du noyau de  &slony1;. Si vous avez manuellement compilé &slony1; par vous-même, sur une machine où il y a plusieurs versions de &postgres;, il est possible que les binaires slon ou lslonik demande de charger une librairie qui n'est pas accessible dans les répertoires des librairies de la version de &postgres; utilisée.</para>

<para>En deux mots : Ceci indique que vous devez <quote>auditer</quote>
comment ont été installés les instances &postgres; et de &slony1; qui sont en place sur la machine. Malheureusement, n'importe quelle incompatibilité peut faire remonter ce genre d'erreur.  Voir aussi <link linkend="threadsafety"> sécurité des threads </link> à propos de la gestion des threads sur Solaris.</para> 

<para> La situation est plus simple si vous avez une seule version de &postgres; installée par serveur; dans ce cas il n'y aura pas d' <quote>incompatibilité de chemins</quote> là ou les composants de &slony1; sont installés. Si vous avez une installation multiple,
vous devrez vous assurez que la bonne version de &slony1;  est associée
à la bonne version du noyau de &postgres;. </para></answer></qandaentry>

<qandaentry>
<question> <para>J'essaie de créer un cluster dont le nom contient un "-". Cela ne marche pas.</para></question>

<answer><para> &slony1; utilise les mêmes règles de nommage que &postgres;, donc vous ne devrize pas utiliser un "-"
dans les identifiants.</para>

<para> Vous pouvez tenter de mettre des simples <quote>quotes</quote> pour l'identifiant, mais vous allez vous exposer à des soucis, qui pourront surgir à tout moment.</para>
</answer>
</qandaentry>

<qandaentry>
<question><para>La commande ps affiche le mot de passe en clair</para>

<para> Avec la commande <command>ps</command>, tout le monde,
peut voir le mot de passe qui a été fourni à la ligne de commande.</para></question>

<answer> <para>Conservez le mot de passe en dehors de la configuration Slony, en les mettant dans le fichier <filename>$(HOME)/.pgpass.</filename></para>
</answer></qandaentry>

<qandaentry>
<question><para>Indexes dont le nom contient le namespace 

<programlisting>
set add table (set id = 1, origin = 1, id = 27, 
               full qualified name = 'nspace.ma_table', 
               key = 'clef_sur_une_colonne', 
               comment = 'une table ma_table dans le namespace nspace avec une clef primaire');
</programlisting></para></question>

<answer><para> Si vous avez <command> key =
'nspace.clef_sur_une_colonne'</command> la requête 
<emphasis>échoura</emphasis>.</para>
</answer></qandaentry>

<qandaentry>
<question> <para> La réplication est retardée, et il semble que les requêtes sur les tables 
<xref linkend="table.sl-log-1"/>/<xref
linkend="table.sl-log-2"/> prennent beaucoup de temps alors qu'il n'y a que quelques événements <command>SYNC</command>s. </para>
</question>

<answer> <para> Jusqu'à la version 1.1.1, les tables <xref
linkend="table.sl-log-1"/>/<xref linkend="table.sl-log-2"/>,possédaient seulement un index, et lorsque il y avait plusieurs ensembles de réplication, quelques colonnes dans l'index n'était pas assez très discriminantes.
Si l'index ne contient pas la colonne<function> log_xid</function>, il est conseillé de l'ajouter. Voir le script
<filename>slony1_base.sql</filename> pour regarder la manière de créer cet index.
</para>
</answer>
</qandaentry>

<qandaentry><question> <para> J'ai besoin de renommer une colonne qui figure dans la clef 
primaire pour l'une de mes tables répliquées. L'opération est un peu dangereuse, n'est-ce pas ? 
Je dois retirer la table de la réplication puis la replacer, c'est bien ça ?</para>
</question>

<answer><para> En fait, cette opération fonctionne proprement.  &slony1; fait un usage intensif des
clefs primaires, mais en pratique ce type d'opération peut se faire de manière transparente.</para>.

<para> Supposons que vous souhaiter renommez une colonne, avec la 
commande DDL suivante<command> alter table accounts alter column aid rename to cid; </command> Ceci
permet de renommer la colonne dans la table; elle permet de mettre à jour <emphasis>simultanément</emphasis> l'index de la clef primaire. Le résultat est que ce genre de changement s'effectue simultanément sur un noeud donné.</para>

<para> Dans l' <emphasis>ideal</emphasis> et pour bien faire les choses il aurait fallu utiliser <xref linkend="stmtddlscript"/> pour déployer la modification au moment sur chaque noeud.</para>

<para> Toutefois ce n'est pas forcément nécessaire. Tant que la modification est appliquée sur le noeud origine avant d'être effectuée sur les abonnés, il n'y aura pas de cassure irrémédiable. Certains évènements <command>SYNC</command> qui n'incluent pas la table sur laquelle il y a la modification, pourront fonctionner sans problème...  Par contre lorsqu'une mise à jour de la table est effectué sur un abonné, alors les événements <command>SYNC</command> vont échouer, puisque le fournisseur indiquera une <quote>nouvelle</quote>  colonne alors que l'abonné connait toujours les <quote>anciennes</quote>. Dès que l'on appliquera la modification de la clef chez l'abonné, les évenements
<command>SYNC</command> seront retraités et le <quote>nouveau</quote> nom de colonne sera présent et tout fonctionnera sans plantage .
</para> </answer></qandaentry>

<qandaentry id="v72upgrade">
<question> <para> J'ai un &postgres; version 7.2 et je souhaite 
<emphasis>vraiment</emphasis> utiliser  &slony1; le migrer en
version 8.0. Que faut-il faire pour que &slony1; fonctionne  ?</para>
</question>

<answer> <para> Voici Rod Taylor écrit sur le sujet ...
</para>

<para> Voici ce dont approximativement vous avez besoin:</para>
<itemizedlist>
<listitem><para>Prendre les templates 7.3 et de les copier en 7.2 -- ou bien écrire en dur la version de vos templates </para></listitem>
<listitem><para>Supprimer toute trace de schémas dans le code sql de vos templates. Concrètement j'ai remplacé les "." par "-". </para></listitem>
<listitem><para> Pas mal de travaux sur les types et fonctins XID. 
Par exemple, Slony crée des  CASTs pour  la conversion xid vers  xxid et vice versa -- mais la 7.2 ne peut pas créer de nouveaux casts et dans ce cas vous êtes obligé de le modifier à la main.
Je me rappelle avoir créé une classe d'opérateur et modifié certaines fonctions. </para></listitem>
<listitem><para>sl_log_1 aura de graves problèmes de performance quelque soit le volume de données.  Ceci exige qu'un certain nombre d'index soient positionnés pour optimiser les interrogations en 7.2, 7.3 et supérieur. </para></listitem>
<listitem><para> Ne pas s'embeter à essayer de faire fonctionner les séquences. Faites les à la main en utilisant pg_dump et grep. </para></listitem>
</itemizedlist>
<para> Bien sûr, une fois que ces pre-requis terminés, on n'est pas encore compatible avec le Slony standard. Ainsi ou bien, vous devez au moins modifier la version 7.2 de manière moins artisanale
, ou vous modifiez slony pour qu'il fonctionne sans les schémas  avec les nouvelles versions de &postgres; afin qu'ils puissent
dialoguer.
</para>
<para> Juste après le déroulement de la procédure de migration de 7.2 vers 7.4, 
on peut désinstaller la version bidouillée de Slony (à la main encore pour la majeure partie), et démarrer la migration
de  7.2 à 7.4 sur les différentes machines en utilisant un Slony standard. Ceci afin de s'assurer qu'on ne conserve pas les catalogues systèmes qui ont subi des changements manuels.
</para>

<para> Ceci étant dit, nous avons migré quelques centaines de Go de données,
de  7.2 à 7.4 avec une coupure de service de 30 minutes. (contre 48 heures de dump/restore) et sans pertes de données.
</para>
</answer>

<answer> <para> Ceci vous dresse un éventail assez laid des
<quote>bidouilles</quote> qu'il faut faire entrer dans le périmètre de production.
Si quelqu'un est intéressé pour  
<quote>industrialiser</quote> cette tache, il vaut mieux s'appuyer sur
&slony1; en version 1.0, avec un maître mot de ne 
<emphasis>pas</emphasis> essayer de le rendre pérenne, étant donnée sa durée de vie limitée.</para>

<para> Vous devriez seulement adapter cette solution que si vous êtes à l'aise avec
&postgres; et &slony1; et si mettre la main au code ne vous fait pas peur. </para> </answer>
</qandaentry>

<qandaentry>
<question> <para> J'ai subit une <quote>avarie réseau</quote> qui m'a obligé à utiliser
 <xref linkend="stmtfailover"/> pour basculer sur un noeud secondaire.
Le plantage n'était pas causé par un problème de corruption de donnée venant du disque,
Pourquoi serais-je obligé de reconstruire le noeud planté ? </para></question>

<answer><para> Le rôle de <xref linkend="stmtfailover"/> est d'
<emphasis>abandonner</emphasis> le noeud planté, et par conséquence il n'a plus de 
charge générée par l'activité de &slony1;. Plus le temps passe plus le serveur planté se désynchronise.</para></answer>

<answer><para> L'<emphasis>énorme</emphasis> problème pour restaurer le serveur planté,
est qu'il peut contenir des mises à jours qui n'ont pas eu le temps de se propager en dehors.
Vous ne pouvez pas non plus les rejouer, car elles vont être conflictuelles, car à moitié en place.
En tout cas vous avez une sorte de corruption <quote>logique</quote>de donnée, qui n'est jamais causée par une erreur disque.
dite <quote>physique.</quote>
</para></answer>

<answer><para> Comme cela a été abordé dans la section <xref linkend="failover"/>, <xref
linkend="stmtfailover"/> doit être utilisé en <emphasis>dernier
recourt</emphasis> car cela implique d'abandonner le noeud d'origine pour cette corruption.</para></answer>
</qandaentry>


<qandaentry> <question><para> Après notification d'un abonnement sur un 
<emphasis>autre</emphasis> noeud, la réplication échoue sur l'un des abonnés, avec le message d'erreur suivant:</para>

<screen>
ERROR  remoteWorkerThread_1: "begin transaction; set transaction isolation level serializable; lock table "_livesystem".sl_config_lock; select "_livesystem".enableSubscription(25506, 1, 501); notify "_livesystem_Event"; notify "_livesystem_Confirm"; insert into "_livesystem".sl_event     (ev_origin, ev_seqno, ev_timestamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3, ev_data4    ) values ('1', '4896546', '2005-01-23 16:08:55.037395', '1745281261', '1745281262', '', 'ENABLE_SUBSCRIPTION', '25506', '1', '501', 't'); insert into "_livesystem".sl_confirm      (con_origin, con_received, con_seqno, con_timestamp)    values (1, 4, '4896546', CURRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or update on table "sl_subscribe" violates foreign key constraint "sl_subscribe-sl_path-ref"
DETAIL:  Key (sub_provider,sub_receiver)=(1,501) is not present in table "sl_path".
</screen>

<para> Par la suite l'erreur est suivie par un ensemble de SYNCs en échec
tandis que <xref linkend="slon"/> s'arrête :</para>

<screen>
DEBUG2 remoteListenThread_1: queue event 1,4897517 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897518 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897519 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897520 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897521 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897522 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897523 SYNC
</screen>

</question>

<answer><para> Si vous constatez qu'un &lslon; s'arrête et que le jounal de log indique que 
des événements ont été ignorés, vous devez remonter dans le journal 
<emphasis>avant</emphasis> que ces erreurs apparaissent, pour trouver des indications
sur l'origine du problème.</para></answer>

<answer><para> Dans ce cas particulier, l'erreur est due à la commande
<xref linkend="stmtstorepath"/> qui n'est pas encore répercutée sur le noeud 4 en attendant la propagation 
de <xref linkend="stmtsubscribeset"/> command</para>

<para>Cet exemple démontre à nouveau qu'il ne faut pas se précipiter;
vous devez vous assurer que tout fonctionne correctement
<emphasis>avant</emphasis> de poursuivre les changements de configuration.
</para></answer>	

</qandaentry>

<qandaentry>

<question><para>J'ai juste utilisé <xref linkend="stmtmoveset"/> afin de déporter le noeud d'origine sur
un nouveau serveur. Malheureusement certains abonnés sont toujours attachés à l'ancien noeud que je viens de migrer,
or je ne peux les mettre hors service tant qu'il n'ont pas reçu le signalement de ce changement.
Que puis-je faire?  </para></question>

<answer><para> Vous avez besoin d'utiliser <xref linkend="stmtsubscribeset"/> afin de modifier les abonnements
 de ces serveurs abonnés et les réorienter vers un fournisseur qui <emphasis>sera</emphasis> disponible durant la période de maintenance.</para>

<warning> <para> Il  <emphasis>ne faut pas</emphasis> faire <xref
linkend="stmtunsubscribeset"/>; car vous seriez obligé de
recharger toutes les données à partir de zéro.

</para></warning>
</answer>
</qandaentry>

<qandaentry>
<question><para> Après la notification d'un abonnement auprès 
<emphasis>d'un autre</emphasis> serveur fournisseur, la réplication tombe en panne, et affiche des messages d'erreurs
du type :</para>

<screen>
ERROR  remoteWorkerThread_1: "begin transaction; set transaction isolation level serializable; lock table "_livesystem".sl_config_lock; select "_livesystem".enableSubscription(25506, 1, 501); notify "_livesystem_Event"; notify "_livesystem_Confirm"; insert into "_livesystem".sl_event     (ev_origin, ev_seqno, ev_timestamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3, ev_data4    ) values ('1', '4896546', '2005-01-23 16:08:55.037395', '1745281261', '1745281262', '', 'ENABLE_SUBSCRIPTION', '25506', '1', '501', 't'); insert into "_livesystem".sl_confirm      (con_origin, con_received, con_seqno, con_timestamp)    values (1, 4, '4896546', CURRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or update on table "sl_subscribe" violates foreign key constraint "sl_subscribe-sl_path-ref"
DETAIL:  Key (sub_provider,sub_receiver)=(1,501) is not present in table "sl_path".
</screen>

<para> Ceci est suivi plus tard par une série d'erreur de syncs tandis que le <xref
linkend="slon"/> s'arrête :

<screen>
DEBUG2 remoteListenThread_1: queue event 1,4897517 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897518 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897519 SYNC
DEBUG2 remoteListenThread_1: queue event 1,4897520 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897521 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897522 SYNC
DEBUG2 remoteWorker_event: ignore new events due to shutdown
DEBUG2 remoteListenThread_1: queue event 1,4897523 SYNC
</screen>

</para></question>

<answer><para> Si vous constatez qu'un &lslon; s'arrête et que le jounal de log indique que
des événements ont été ignorés, vous devez remonter dans le journal
<emphasis>avant</emphasis> que ces erreurs apparaissent, pour trouver des indications
sur l'origine du problème.</para></answer>

<answer><para> Dans ce cas particulier, le problème était que certaines commandes 
 <xref linkend="stmtstorepath"/> n'ont pas été transmises aux noeud 4 avant que
le commande <xref linkend="stmtsubscribeset"/> ne soit propagée. </para>

<para>C'est encore un exemple où il ne faut pas hâtivement modifier les choses
; vous devez être sur que tout fonctionne bien  
<emphasis>avant</emphasis> de faire de nouveau changement de configuration.
</para></answer>

</qandaentry>

<qandaentry>
<question> <para> Est-ce que l'ordre dans une ensemble de réplication est important ?</para>
</question>
<answer> <para> La plupart de temps il ne l'est pas. On pourrait imaginer qu'il faille
déclarer les tables <quote>mères</quote> avant leurs <quote>filles</quote>
en fonction des relations de clefs étrangères qui les relient; 
mais ce n'est <emphasis>pas nécessaire</emphasis> si sur le noeud abonné, 
on a pris le soin, de désactiver les déclencheurs.
</para>
</answer>


<answer> <para>(Les commentaires de Jan Wieck:) L'ordre des ID des tables
a une importance uniquement lors d'une opération de <xref linkend="stmtlockset"/> en préparation de basculement.
Si l'ordre est différent de celui selon lequel les applications obtiennent des verrous,
ces derniers peuvent se transformer en verrous interbloqués ("deadlock") et par conséquent faire tomber l'application ou bien
<application>slon</application>.
</para>
<answer><para> (David Parker) J'ai renconté un autre cas où l'ordre des
tables avait une importance : avec l'héritage.
Si une table fille se présente avant le table mère, alors l'abonnement initial provoquera la suppression du 
contenu de la table, alors qu'elle aura probablement reçue des données.
En effet la logique de la commande
<command>copy_set</command> effectue un <command>delete</command>,
et non pas un <command>delete only</command>, ce qui implique que  la suppression des données de la table maître provoquera  la suppression de celle
de la table fille.
</para>
</answer></answer>

</qandaentry>

<qandaentry>

<question><para> Si votre script  <xref linkend="slonik"/> ressemble à quelque chose à celui ci-dessous,
il peut tomber en erreur et ne jamais se terminer, car on ne peut pas utiliser
<command>wait for event</command> à l'intérieur d'un bloc 
<command>try</command>. Un bloc de <command>try</command> est exécuté comme une seule et même transaction,
et l'évènement pour lequel vous êtes en attente, peut ne jamais avoir lieu
dans le scope de la transaction.</para>

<programlisting>
try {
      echo 'Moving set 1 to node 3';
      lock set (id=1, origin=1);
      echo 'Set locked';
      wait for event (origin = 1, confirmed = 3);
      echo 'Moving set';
      move set (id=1, old origin=1, new origin=3);
      echo 'Set moved - waiting for event to be confirmed by node 3';
      wait for event (origin = 1, confirmed = 3);
      echo 'Confirmed';
} on error {
      echo 'Could not move set for cluster foo';
      unlock set (id=1, origin=1);
      exit -1;
}
</programlisting></question>

<answer><para> Vous ne devez pas invoquer<xref linkend="stmtwaitevent"/>
à l'intérieur d'un bloc <quote>try</quote>.</para></answer>

</qandaentry>

<qandaentry>
<question><para>Slony-I: cannot add table to currently subscribed set 1</para>

<para> J'ai essayé de rajouter une table à un jeu d'ensemble et j'ai le message
d'erreur suivant :

<screen>
	Slony-I: cannot add table to currently subscribed set 1
</screen></para></question>

<answer><para> Vous ne pouvez pas rajouter des tables à un ensemble pour lequel il y a des abonnées.
</para>

<para>Le contournement est de créer un <emphasis>AUTRE</emphasis>
ensemble de réplication, d'y rajouter les tables souhaitées, brancher les serveurs abonnés l'ensemble de réplication 1 sur le nouveau qu'on vient de créer,et en suite de
fusionner les 2 ensembles.</para>
</answer></qandaentry>

<qandaentry>
<question><para>
ERROR: duplicate key violates unique constraint "sl_table-pkey"</para>

<para>En essayant de monter un deuxième ensemble de réplication, j'ai ce message :

<screen>
stdin:9: Could not create subscription set 2 for oxrslive!
stdin:11: PGRES_FATAL_ERROR select "_oxrslive".setAddTable(2, 1, 'public.replic_test', 'replic_test__Slony-I_oxrslive_rowID_key', 'Table public.replic_test without primary key');  - ERROR:  duplicate key violates unique constraint "sl_table-pkey"
CONTEXT:  PL/pgSQL function "setaddtable_int" line 71 at SQL statement
</screen></para></question>

<answer><para> Les identifiants des tables utilisées dans  <xref linkend="stmtsetaddtable"/>
doivent être uniques <emphasis>A TRAVERS TOUT LES ENSEMBLES DE REPLICATION</emphasis>.  
En conséquence, vous en pouvez pas reprendre la numérotation à zéro à l'intérieur
d'un deuxième ensemble de réplication; Si vous les numérotez de manière
consécutive, le prochain ensemble de réplication doit commencer 
avec un identifiant supérieur à ceux de l'ensemble précédent.
</para> </answer>
</qandaentry>


<qandaentry>
<question><para> L'un de mes noeudss est tombé (&lslon; ou le postmaster était arrêté) et personne ne s'en est aperçu pendant plusieurs jours.
Maintenant lorsque &lslon; démarre sur ce noeud, il tourne durant cinq minutes, puis s'arrête,
avec l'erreur suivante : <command>ERROR: remoteListenThread_%d: timeout
for event selection</command> Quel est le problème ? Que faire ? </para> 
</question>

<answer><para> Le problème est que le port d'écoute de ce processus (dans
<filename>src/slon/remote_listener.c</filename>) arrive à une expiration de temps, lorsqu'il tente
de déterminer quel est l'évènement à reprendre sur ce noeud. Par défaut
le délai d'expiration de cette interrogation est de 5 minutes; si la reprise contient les évènements pour une durée de plusieurs jours, 
cela prendra beaucoup plus de temp.
 </para> </answer>

<answer><para> La réponse à cette question pour les versions de &slony1; antérieures à  1.1.7, 1.2.7, et à 1.3, serait de dire
d'augmenter le délai d'expiration dans
<filename>src/slon/remote_listener.c</filename>, de recompiler &lslon;, et enfin de ressayer.  </para> </answer>

<answer><para> Une autre réponse serait de conseiller de reconstruire entièrement le noeud ayant échoué, 
à l'aide de la commande &lslonik;  <xref linkend="stmtdropnode"/> en le supprimant d'abord et le recréer après.
Si les mises à jours sont volumineuses côté base de données, il vaut mieux reconstruir plutôt que d'essayer de rattraper.
</para> </answer>
  
<answer><para> Dans les version récentes de &slony1;, il y a une nouveau paramètre appelé :<xref
linkend="slon-config-remote-listen-timeout"/>; qui permet de modifier le délai d'expiration
et de relancer les mises à jour. Bien sûr, comme il a été mentionné ci-dessus, il est plus efficace dans ce cas
de supprimer et de recréer le noeud, que d'essayer de rattraper les mises à jours. </para> </answer>

</qandaentry>

</qandadiv>



<qandadiv id="faqperformance"> <title> &slony1; FAQ: Problèmes de Performances </title>

<qandaentry id="longtxnsareevil">


<question><para> La réplication ralentit, je vois des requêtes <command> FETCH 100 FROM LOG </command> très longues , la table <xref linkend="table.sl-log-1"/> grossit, et les performances se dégradent de manière continue. </para>
</question>

<answer> <para> Il y a beaucoup de causes possibles pour ce genre de choses.
Il s'agit de même genre de pathologies qui entrainent l'augmentation du volume dans
 <link linkend="pglistenerfull"> 
&pglistener; lorsque la purge via vacuum n'est pas exécutée.</link>
</para>

<para> Par rapprochement <quote> on peut avancer </quote>, que cette augmentation de volume,
est due à une session existante sur le serveur rend le noeud
 <command>
IDLE IN TRANSACTION </command> pour une durée très longue. </para>

<para> Cette transaction ouverte peut avoir de multiples effets négatifs,
chacun entrainant une dégradation de performances.</para>

<itemizedlist>

<listitem><para> Le fait de lancer un Vacuum sur la totalité des tables,
&pglistener; y compris, ne va pas nettoyer les tuples morts après après le début de la transaction en attente. </para> </listitem>

<listitem><para> Le processus de nettoyage ne pourra pas se supprimer les entrées dans <xref linkend="table.sl-log-1"/> et <xref
linkend="table.sl-seqlog"/>, qui entraîne par conséquence, une croissance 
de volume tant que la transaction persiste. </para>
</listitem>
</itemizedlist>
</answer>

<answer> <para> Vous pouvez surveiller cette situation, uniquement si
dans le fichier de configuration de &postgres; <filename> postgresql.conf </filename>
le paramètre <envar>stats_command_string</envar> est positionner à vrai.
Dans ce cas, vous pouvez lancer une intérrogation sql comme suit :
<command> select * from pg_stat_activity where current_query like '%IDLE% in transaction';
</command> dont le résultat vous donnent les transactions en activités.  </para> </answer>

<answer> <para> Vous pouvez également rechercher
les <quote> idle in transaction </quote> dans la table des processes 
ceux qui détiennent encore des transactions anciennes.
 </para> </answer>

<answer> <para> Il est aussi possible (quoique plus rare) que le problème soit causé par
une transaction, qui pour d'autres raisons, est conservée comme ouverte et ceci pour une longue durée.
La valeur <envar> query_start </envar> dans la table <envar>
pg_stat_activity </envar> vous présentra les longues requêtes qui s'exécutent depuis longtemps. </para> </answer>

<answer> <para> Il est prévu que &postgres; ait un paramètre d'expiration de 
délai, <envar> open_idle_transaction_timeout </envar>, qui permettrait de venir à bout des transactions après une certaine période.

Les pool de connexions peuvent engendrer ce genre de situation d'erreurs. Il est prévu des amélioration où <productname> <link linkend="pgpool"> pgpool
</link> </productname> devrait présenter des meilleurs alternatives afin de mieux gérer les connexions partagées. 
Il existe des pools de connexions plus ou moins buggués dans les applications
Java ou PHP;si un nombre restreint de <emphasis> vrai </emphasis>
connections sont conservées dans<productname>pgpool</productname>, ceci va faire croire à la base,
qu'en réalité  les connexions de l'application reste dans un statut disponible et en activité, pendant des heures.
</para> </answer>

</qandaentry> 

<qandaentry id="faq17">
<question><para>Après une suppression de noeud, la table  <xref linkend="table.sl-log-1"/>
n'est plus purgée.</para></question>

<answer><para> Ceci est un scénario commun dans les versions d'avant 1.0.5, en effet
le <quote>nettoyage</quote> du noeud oublie les vieilles entrées de la  table <xref linkend="table.sl-confirm"/>, pour le serveur qui vient de disparaître.</para>

<para> Le noeud n'est plus présent et n'envoie plus les confirmations annonçant les syncs qui viennent de s'effectuer sur ce serveur, 
et le processus de nettoyage estime qu'il ne peut supprimer sans risque les entrées plus récentes
que la dernière entrée de la <xref linkend="table.sl-confirm"/> , ce qui limite nettement la capacité de purge des anciens journaux.</para>

<para>Diagnostics: Exécuter les requêtes suivantes pour voir si il y a 
un résidus d'entrées en état <quote>fantôme/obsolète/bloqué</quote> dans la table <xref
linkend="table.sl-confirm"/>:

<screen>
oxrsbar=# select * from _oxrsbar.sl_confirm where con_origin not in (select no_id from _oxrsbar.sl_node) or con_received not in (select no_id from _oxrsbar.sl_node);
 con_origin | con_received | con_seqno |        con_timestamp                  
------------+--------------+-----------+----------------------------
          4 |          501 |     83999 | 2004-11-09 19:57:08.195969
          1 |            2 |   3345790 | 2004-11-14 10:33:43.850265
          2 |          501 |    102718 | 2004-11-14 10:33:47.702086
        501 |            2 |      6577 | 2004-11-14 10:34:45.717003
          4 |            5 |     83999 | 2004-11-14 21:11:11.111686
          4 |            3 |     83999 | 2004-11-24 16:32:39.020194
(6 rows)
</screen></para>

<para>Dans la version 1.0.5, la fonction <xref linkend="stmtdropnode"/> 
purges les données dans <xref linkend="table.sl-confirm"/> pour le noeud qui quitte la configuration.
Dans les versions plus anciennes, il faut faire cela à la main. Supposons que l'identifiant du noeud soit 3, alors la requête serait la suivante :


<screen>
delete from _namespace.sl_confirm where con_origin = 3 or con_received = 3;
</screen></para>

<para>Sinon, pour chasser <quote>tous les fantômes,</quote> vous pouvez utiliser 
<screen>
oxrsbar=# delete from _oxrsbar.sl_confirm where con_origin not in (select no_id from _oxrsbar.sl_node) or con_received not in (select no_id from _oxrsbar.sl_node);
DELETE 6
</screen></para>

<para>Une  <quote>raisonnable diligence</quote> dicterait de commencer par
<command>BEGIN</command> et vérifier le contenu des <command>SYNC</command> dans la table <xref linkend="table.sl-confirm"/> avant de les purger, puis de valider l'opération par un  <command>COMMIT</command>.  Si 
vous supprimer par erreur les données d'un autre noeud, votre journée est perdue le temps de rattraper l'erreur commise.</para>

<para>Vous aurez besoin d'exécuter cette opération, sur chaque noeud qui reste...</para>

<para>A noter qu'à partir de la version 1.0.5, ce n'est plus un problème, car il purge les entrées inutiles
de <xref linkend="table.sl-confirm"/> à deux instants :

<itemizedlist>
<listitem><para> Lorsque un noeud est supprimé</para></listitem>

<listitem><para> Au démarrage de chaque 
<function>cleanupEvent</function>, qui est l'évènement qui purge les vieilles données de
<xref linkend="table.sl-log-1"/> et de <xref
linkend="table.sl-seqlog"/></para></listitem> </itemizedlist></para>
</answer>
</qandaentry>

<qandaentry>

<question><para>Le <application>slon</application>  était éteint ce  week-end , et désormais il lui faut énormément de temps pour exécuter un 
sync.</para></question>

<answer><para> Jetez un coup d'oeil, sur les tables <xref
linkend="table.sl-log-1"/>/<xref linkend="table.sl-log-2"/>, 
 pour voir brièvement si il y a une énorme transaction 
en cours d'exécution. Jusqu'à la version  1.0.2, il faut qu'il y ait un 
&lslon; connecté au noeud origine pour que les événements <command>SYNC</command> soient générés.</para>

<para>Si aucun évènement n'est généré, alors toute les mises à jour jusqu'au prochain évènement seront aggrégées dans une énorme transaction &slony1;.</para>

<para>Conclusion: Même si il n'y a pas d'abonné dans votre réplication,
vous avez <emphasis>vraiment</emphasis> mettre en place un 
<application>slon</application> pour qu'il se connecte au  noeud origine.</para>

<para>&slony1; 1.1 fournit une procédure stockée qui permet aux SYNCs d'être 
mis à jour par le planificateur <application>cron</application>même si <xref
linkend="slon"/> ne tourne pas en tâche de fond.</para> </answer></qandaentry>

<qandaentry id="pglistenerfull">
<question><para>Quelques noeuds commencent à se ralentir constamment. </para>

<para>J'avais lancé, depuis un moment, &slony1; sur un noeud, et je vois que la machine est à
genoux.</para>

<para>Je vois des instructions en cours comme :
<screen>
	fetch 100 from LOG;
</screen></para></question>

<answer><para> Typiquement ceci peut se produire lorsque  &pglistener; (la table qui contient les données de 
<command>NOTIFY</command>) est rempplie de  tuple morts.


Ce qui fait que les évènements <command>NOTIFY</command> prend du temps,
et cause le ralentissement de plus en plus fort du noeud affecté.</para>

<para>Vous avez probablement besoin d'effectuer un <command>VACUUM FULL</command> sur
&pglistener;, pour le nettoyer vigoureusement, puis d'effectuer un vacuum simple sur  
&pglistener; vraiment fréquemment. Une planification tous les cinq minutes fera l'affaire.</para>

<para> Les démons Slon font déjà un vacuum sur beaucoup de tables ,et
<filename>cleanup_thread.c</filename> contient une liste de tables à nettoyer fréquemment de manière automatique.
Dans &slony1; 1.0.2,&pglistener; n'est pas inclus. Dans la version 1.0.5 et supérieure, il est purgé régulièrement,
du coup ce problème n'a plus le lieu d'être. Dans la version 1.2,
&pglistener; est seulement utilisé quand le noeud reçoit périodiquement l'évènement,
ce qui signifie que ce problème la plupart du temps disparaître même
en présence des transaction longues et lentes...</para>

<para>Il y a, cependant, toujours un scénario où ceci peut
<quote>surgir</quote>. Pour respecter le MVCC, les vacuums ne peuvent pas supprimer des tuples qui sont rendus 
<quote>obsolètes</quote> à n'importe quel moment après le démarrage de la transaction la plus ancienne
qui reste encore ouverte. Les transactions longues, devront être évitées, car elles sont sources de soucis, 
même sur les noeuds abonnés.</para> </answer></qandaentry>

<qandaentry> <question> <para> J'ai soumis une requête <xref
linkend="stmtmoveset"/> / <xref linkend="stmtddlscript"/>, et 
elle semble être coincée, sur mon serveur. Les journaux de &slony1; ne montre aucun avertissement et aucune erreur.
 </para> </question>

<answer> <para> Peut-être que 
<application>pg_autovacuum</application> est en cours d'exécution, et qu'il a posé
des verrous sur des tables dans l'ensemble de réplication ? Ceci entraine manière silencieuse le blocage de &slony1;
en l'empêchant d'effectuer les opérations qui exigent l'acquisition des <link
linkend="locking"> exclusifs. </link> </para>


<para> Vous pourriez vérifier la présence de ce genre de verrous à l'aide de cette requête :
<command> select l.*, c.relname from pg_locks l, pg_class c
where c.oid = l.relation ; </command> Un verrou
<envar>ShareUpdateExclusiveLock</envar> peut bloquer les opérations de &slony1;
qui nécessitent leurs propres verrous exclusifs, et les mettre en en attentes et  marquées comme non-validées. </para>
</answer> </qandaentry>

<qandaentry>

<question><para> Je remarque que dans les journaux, qu'un &lslon; change d'état fréquemment  : <quote>LISTEN - switch from polling mode to use
LISTEN</quote> et  <quote>UNLISTEN - switch into polling
mode</quote>. </para> </question>

<answer><para> Les seuils pour commuter entre ces modes sont commandés par 
les paramètres de configuration <xref
linkend="slon-config-sync-interval"/> et  <xref
linkend="slon-config-sync-interval-timeout"/>; si la valeur du temps d'expiration
(par défaut étant à 10000, impliquant 10s) est maintenu bas, cela encourage le &lslon; à retourner dans l'état  <quote>d'écoute</quote>.
Vous devriez augmenter cette valeur d'expiration de temps. </para>
</answer>
</qandaentry>


</qandadiv>
<qandadiv id="faqbugs"> <title> &slony1; FAQ: &slony1; Bugs dans les versions anciennes</title>
<qandaentry>
<question><para>Les processus &lslon; gérant mes abonnés devient énorme, mettant en danger la ressource du système en terme de swap ainsi que le risque d'atteindre la taille limite
de 2GB par processus . </para> 

<para> D'ailleurs, les données que je suis en train de répliquer,
ont une taille assez grande. Il y a des enregistrements dont la taille
dépasse des dizaine de megaoctets. Peut-être que c'est lié ? </para> </question>

<answer> <para> Oui, ces enregistrements volumineux sont à la racine du problème.
Le problème vient du fait que &lslon; normalement procède par paquet de
 100 enregistrements à la fois, lorsqu'un abonné charge des données depuis le fournisseur.
Ainsi si la taille moyenne des enregistrements est de 
is 10MB, ceci entraîne des paquets de données atteignant 1000MB qui sont ensuite transformés en 
 <command>INSERT</command> ou en <command>UPDATE</command>
dans la mémoire du processus &lslon;.</para>

<para> Cela mène évidemment &lslon; à des tailles gigantesques. </para>

<para> Le nombre d'enregistrement regroupés est controllé par la valeur <envar> SLON_DTA_FETCH_SIZE </envar>,
définie dans le fichier <filename>src/slon/slon.h</filename>. Voici un extrait de ce fichier contenant ce paramètre :
</para>
 
<programlisting>
#ifdef	SLON_CHECK_CMDTUPLES
#define SLON_COMMANDS_PER_LINE		1
#define SLON_DATA_FETCH_SIZE		100
#define SLON_WORKLINES_PER_HELPER	(SLON_DATA_FETCH_SIZE * 4)
#else
#define SLON_COMMANDS_PER_LINE		10
#define SLON_DATA_FETCH_SIZE		10
#define SLON_WORKLINES_PER_HELPER	(SLON_DATA_FETCH_SIZE * 50)
#endif
</programlisting>

<para> Si vous rencontrez ce problème, vous devriez définir
 <envar> SLON_DATA_FETCH_SIZE </envar>, peut-être le réduire par un facteur de 10, et recompiler ensuite  &lslon;.  
L'activation de <envar> SLON_CHECK_CMDTUPLES</envar> permet de faire une surveillance
supplémentaire pour s'assurer que les abonnés ne sont pas désynchronisés par
rapport au fournisseur. Par défaut, cette option est désactivée, donc la modification par défaut consiste réduire la seconde définition de 
<envar> SLON_DATA_FETCH_SIZE </envar> en remplaçant  10 par 1. </para> </answer>

<answer><para> Dans la version 1.2, la configuration des valeurs de<xref
linkend="slon-config-max-rowsize"/> et de <xref
linkend="slon-config-max-largemem"/> sont associées avec un nouvel algorithme 
qui change la logique des choses. Plutôt que de restituer 100
enregistrements à la fois :</para>

<itemizedlist>

<listitem><para> La lecture de <command>fetch from LOG</command> se fera
par paquet de 500 enregistrements à la fois, tant que la taille n'excède pas 
<xref linkend="slon-config-max-rowsize"/>.  Avec les valeurs par défaut, ceci limitera 
ce phénomène de consommation de mémoire à un plafond de 8MB.  </para>
</listitem>


<listitem><para> Les tuples sont lus jusqu'à ce que la taille n'excède pas
le paramètre  <xref linkend="slon-config-max-largemem"/>.  Par défaut, cette restriction
ne consommera pas plus de 5MB. Cette valeur n'est pas un seil de limitation stricte;
si vous avez des tuples dont la taille est de 50MB, il <emphasis>seront</emphasis>  forcément chargé en mémoire. Il n'est pas possible d'éviter cela.
Mais &lslon; au moins, n'essayera pas  de charger, à la fois 100 enregistrements coûte que coûte, dépassant les 10GB de 
mémoire consommée à cet effet.</para> </listitem>
</itemizedlist>

<para> Ceci devrait alléger des problèmes que les gens avaient éprouvé, quand ils ont chargés sporadiquement,
des séries de tuples très volumineux. </para>
</answer>
</qandaentry>

<qandaentry id="faqunicode"> <question> <para> Je suis en train de répliquer
les données de type <envar>UNICODE</envar> depuis la version 8.0 de &postgres; à la  version 8.1, 
et je rencontre des problèmes. </para>
</question>

<answer> <para> &postgres; 8.1 est un peu plus strict dans l'usage des codes caractères
UTF-8 et Unicode, comparé à la version 8.0.</para>

<para> Si vous êtes amené à utiliser &slony1; pour migrer depuis une plus vieille version vers la version  8.1, 
et que avez de valeur UTF-8 invalide, vous aurez une surprise déplaisante.</para>

<para> Supposons que votre version de base est 8.0, avec l'encodage en UTF-8.
La base va accepter des séquences  <command>'\060\242'</command> comme un valeur UTF-8 conforme, même si ce n'est pas le cas. </para>

<para> Si vous répliquez ceci dans des instances de &postgres; en version 8.1, il va se plaindre,
, soit lors de l'enregistrement d'un abonné, car &slony1; va râler 
à propos des codes caractères invalides qu'il vient de rencontrer durant la COPY des données,
ce qui empêchera que l'enregistrement se fasse, soit lors de l'ajout de données, plus tard, ce qui brisera irrémédiablement la réplication.
(Vous pouvez tricher sur le contenu de sl_log_1, mais rapidement 
cela deviendra <emphasis>vraiment</emphasis> intéressant...)</para>

<para>Il y a déjà eu des discussions sur ce sujet pour savoir ce qu'il faudra faire.
Pour le moment une stratégie attractive ne se dégage pas sur le sujet. </para>

<para>Si vous utilisez Unicode avec la version 8.0 de &postgres;, vous courrez un risque
considérable de corrompre vos données. </para>

<para> Si votre réplication a pour but de convertir une fois pour toutes vos données,
il y a le risque évoqué ci-dessus; si cela vous arrive, il voudra mieux de convertir vos données de la version 8.0
d'abord et de re-essayer après. </para>

<para> Au regard des risques encourus, exécuter la réplication en mettant en jeu des versions différentes,
semble être non pérenne à maintenir. </para>

<para> Pour plus d'information, voir la discussion <ulink url=
"http://archives.postgresql.org/pgsql-hackers/2005-12/msg00181.php">
sur le groupe de discussion postgresql-hackers. </ulink>.  </para>
</answer>
</qandaentry>

<qandaentry>
<question> <para> J'utilise  &slony1; 1.1 avec plus de 4 noeuds et deux ensemble de réplication,  1 et 2, qui ne partagent aucun noeuds. Je découvre que les confirmations pour l'ensemble 1
n'arrivent jamais aux noeuds souscrivant à l'ensemble 2, et inversement, celles de l'ensemble 2 n'arrivent pas non plus 
aux noeuds souscrivant à l'ensemble 1. En conséquence, <xref
linkend="table.sl-log-1"/> grossit et n'est jamais purgée. Ceci est mentionné dans le bug 1485 :
 <ulink
url="http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1485">
</ulink>.
</para>
</question>

<answer><para> Apparemment le code de la fonction <function>RebuildListenEntries()</function> ne suffit pas pour résoudre ce cas.</para>

<para> <function> RebuildListenEntries()</function> sera rectifié dans &slony1; version 1.2 
avec un algorithme couvrant ce cas. </para>
<para> 
Dans l'intérim, vous drevez ajouter manuellement quelques entrées dans <xref linkend="table.sl-listen"/> en utilisant <xref
linkend="stmtstorelisten"/> ou <function>storeListen()</function>,
basé sur les principes décrits dans <xref linkend="listenpaths"/>.
(apparemment pas aussi désuet que nous avons pensé) 
</para></answer>
</qandaentry>

<qandaentry>
<question> <para> Je trouve que quelques colonnes de multibyte (Unicode, Big5) sont tronqués un peu, il leur manque les derniers caractères. Pourquoi?
</para> </question>

<answer> <para> C'était un bug présent jusqu'à la version 1.1.0 de &slony1; ; les colonnes étaient capturées par la fonction <function>logtrigger()</function>, qui coupait les derniers byte d'une colonne représentée dans un format de multibyte. que votre version de <filename>src/backend/slony1_funcs.c</filename> est bien 1.34 ou suppérieur; le patch a été intégré dans la version  CVS de  1.34 de ce fichier.  </para> </answer>
</qandaentry>

<qandaentry id="sequenceset"><question><para> <ulink url=
"http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1226">
Le bug #1226 </ulink> indique une condition d'erreur qui peut survenir si
vous faites placer une réplication composée seulement de séquences.
</para>
</question>

<answer> <para> Une réponse courte consiste à dire qu'une réplication composée seulement de séquences, n'est pas une <link linkend="bestpractices">
bonne pratique.</link> </para>
</answer>


<!-- todo -->

<answer>
<para> Le problème avec un ensemble d'ordre  seulement si vous avez un cas pour lequel les seuls abonnements qui sont en activité pour un abonné particulier vis à vis d'un fournisseur particulier, sont pour les jeux <quote>sequence-only</quote>. Si un noeud entre dans cet état,
la réplique échouera, étant donnée la requête qui collectera les données depuis <xref
linkend="table.sl-log-1"/> n'aura plus de tables à trouver et par conséquence la requête tombera en erreur.  S'un jeu de réplication de nouveau <emphasis>avec</emphasis>
des tables reapparît, tout va fonctionner correctement; il 
 <emphasis>paraîtra</emphasis> tout simplement effrayant.
</para>

<para> Ce problème devrait être résolu un certaine temps après &slony1;
1.1.0.</para>
</answer>
</qandaentry>

<qandaentry>
<question><para>Je dois supprimer une table d'un ensemble de réplication</para></question>
<answer><para>
Ceci peut être accompli de plusieurs manières, pas toutes également souhaitables;-).

<itemizedlist>

<listitem><para> Vous pourriez supprimer tout  le jeu de réplication, et les recréer avec juste les tables dont vous avez besoin.  Hélas, ce signifie reproduire un tas de données, et tue l'intérêt du cluster sur lequel cela se produit.</para></listitem>

<listitem><para> Si vous êtes en version 1.0.5 ou supérieur, il y a une commande SET DROP TABLE, qui fera  "l'affaire."</para></listitem>

<listitem><para> Si vous employez toujours 1.0.1 ou 1.0.2, l'
<emphasis>essentiel de la fonctionnalité de <xref linkend="stmtsetdroptable"/>
impliquant <function>droptable_int()</function> est présent.
Vous pouvez feuilleter cela à la main en trouvant l'identification de la table à supprimer, et que vous pouvez trouver dedans<xref
linkend="table.sl-table"/>, et après lancer les trois requêtes suivantes sur chaque noeud :</emphasis>

<programlisting>
  select _slonyschema.alterTableRestore(40);
  select _slonyschema.tableDropKey(40);
  delete from _slonyschema.sl_table where tab_id = 40;
</programlisting></para>

<para>Le schéma dépendra évidemment de la façon dont vous avez défini le cluster &slony1;. L'identifiant de la table, dans cet exemple, 40, sera à vous de remplacer par celui que vous voulez vous en débarrasser.</para>

<para> Vous devrez lancer ces trois interrogations sur tous les noeuds, de préférence premièrement sur le noeud d'origine, de sorte que la réplique de ses propagations soit correcte.
Implémenter ceci à travers un ordre de <xref linkend="slonik"/>
avec un nouveau &slony1; pourra se faire. La soumission des trois requêtes utilisant <xref linkend="stmtddlscript"/> peut le faire aussi.
Également il sera possible de se connecter à chaque base de données et de lancer les requêtes à la main.</para></listitem> </itemizedlist></para>
</answer>
</qandaentry>

<qandaentry>
<question><para>Je dois supprimer un ordre dans une séquence pour un ensemble de réplication</para></question>

<answer><para></para><para>Si vous êtes en version 1.0.5 ou supérieur, il y a une commande <xref linkend="stmtsetdropsequence"/> dans Slonik vous permettant de le faire en paralelle <xref linkend="stmtsetdroptable"/>.</para>

<para>Si vous êtes en version 1.0.2 ou antérieur, l'opération sera un peu plus manuel.</para>

<para>À supposer que je veux me débarrasser des deux ordres énumérés ci-dessous,<envar>whois_cachemgmt_seq</envar> and
<envar>epp_whoi_cach_seq_</envar>, we start by needing the
<envar>seq_id</envar> values.

<screen>
oxrsorg=# select * from _oxrsorg.sl_sequence  where seq_id in (93,59);
 seq_id | seq_reloid | seq_set |       seq_comment				 
--------+------------+---------+-------------------------------------
     93 |  107451516 |       1 | Sequence public.whois_cachemgmt_seq
     59 |  107451860 |       1 | Sequence public.epp_whoi_cach_seq_
(2 rows)
</screen></para>

<para>Les données à supprimer, afin d'éviter que soit propager, nécessite l'arrêt de Slony :

<programlisting>
delete from _oxrsorg.sl_seqlog where seql_seqid in (93, 59);
delete from _oxrsorg.sl_sequence where seq_id in (93,59);
</programlisting></para>

<para>Ces deux interrogations peuvent être soumises à l'ensemble des noeud via la fonction &funddlscript; / <xref
linkend="stmtddlscript"/>, éliminant l'ordre partout en 
<quote>même temps.</quote> Ou bien appliquer à la main à chacun des noeuds.</para>

<para>Similarly to <xref linkend="stmtsetdroptable"/>, this is
implemented &slony1; version 1.0.5 as <xref
linkend="stmtsetdropsequence"/>.</para></answer></qandaentry>

</qandadiv>

<qandadiv id="faqobsolete"> <title> &slony1; FAQ: Hopefully Obsolete Issues </title>

<qandaentry>
<question><para> &lslon; ne se remet pas en marche après un incident</para>

<para> Après un après brutal de &postgres; (en simulant une panne système)
dans &pglistener; un tuplets existe avec  <command>
relname='_${cluster_name}_Restart'</command>. slon ne démarre pas car 
il considère quune autre processe sert le  cluster sur ce noeud. Que puis-je faire? 
Le tuplet ne peut pas être supprimé dans la relation.</para>

<para> Le journal prétend que  <blockquote><para>un autre slon en tâche de fond
sert ce noeud déjà</para></blockquote></para></question>

<answer><para> Le problème est que la table système  &pglistener;, utilisée par
&postgres; à gérer l'évènement de notification, contiens quelques entrées pointant vers le central,
n'existent plus. La nouvelle instance de <xref
linkend="slon"/> se  connecte à la base, et elle est convaincue, par la
présence de ces entrées qu'un ancien
<application>slon</application> est toujours en activité pour s'occuper de ce noeud de &slony1;.</para>

<para> Le <quote>détritus</quote> dans cette table doit être nettoyer.</para>

<para>Il sera utile de maintenir un script manuel pour ce genre de situation:

<programlisting>
twcsds004[/opt/twcsds004/OXRS/slony-scripts]$ cat restart_org.slonik 
cluster name = oxrsorg ;
node 1 admin conninfo = 'host=32.85.68.220 dbname=oxrsorg user=postgres port=5532';
node 2 admin conninfo = 'host=32.85.68.216 dbname=oxrsorg user=postgres port=5532';
node 3 admin conninfo = 'host=32.85.68.244 dbname=oxrsorg user=postgres port=5532';
node 4 admin conninfo = 'host=10.28.103.132 dbname=oxrsorg user=postgres port=5532';
restart node 1;
restart node 2;
restart node 3;
restart node 4;
</programlisting></para>

<para> <xref linkend="stmtrestartnode"/> nettoie les notifications mortes
pour en suite redémarrer le noeud.</para>

<para>Comme en version 1.0.5, au démarrage de slon, les processes cherche ce genre de données obsolètes et les nettoient
le cas échéant.</para>

<para> Comme en version 8.1 de &postgres;, la  fonction manipulant
&pglistener; ne supporte pas cet usage, alors pour la version de &slony1; après 
1.1.2 (<emphasis>e.g. - </emphasis> 1.1.5), ce 
<quote>couplage</quote> est manipulé par l'intermédiaire d'une autre table, et l'issu de la situation est
rendu un peu plus transparent. <quote>.</quote> </para>

</answer></qandaentry>

<qandaentry><question><para> J'ai essayé la requête suivante qui ne marche pas:</para> 

<programlisting>
sdb=# explain select query_start, current_query from pg_locks join
pg_stat_activity on pid = procpid where granted = true and transaction
in (select transaction from pg_locks where granted = false); 

ERROR: could not find hash function for hash operator 716373
</programlisting>

<para> Il semble que &slony1; <function>xxid</function> les fonctions vont être 
dôtées de brouillage(hashing), qu'elles n'ont pas actuellement.</para>


<para> Que se passe-t-il ? </para>

</question>

<answer><para> &slony1; a défini un nouveau type de données et d'opérateurs XXID
ce type afin de permettre la manipulation des IDs de transaction qui sont employés
pour grouper ensemble, les mises à jour qui sont associées à la même transaction.
</para>

<para> Opérateurs qui n'étaient pas disponible pour &postgres; version 
7.3 et inférieur; afin de le rendre opérationnelle en 7.3, les fonctions spécifiques
doivent être ajoutées. L'opérateur <function>=</function>  
a été marqué comme soutenant
le hachage, mais pour que celui-ci travaille correctement, l'opérateur de jointure doit 
apparaître dans une classe d'opérateur d'index haché. Cela n'a pas été défini, 
et en conséquence, les requêtes (comme celle ci-dessus) qui décident d'employer 
le hash-joins échoueront. </para> </answer>

<answer> <para> Ceci  <emphasis> n'a pas </emphasis> 
été considéré comme bug <quote>release-critical</quote>, comme &slony1; 
ne produit probablement pas des intérrogations intérnes employant des hash-join. Ce problème ne devrait 
pas entacher &slony1; devant la capacité qu'il a de gérer la  réplication. </para> </answer>

<answer> <para> La nouvelle version de &slony1; (<emphasis>e.g.</emphasis>
1.0.6, 1.1) omettra l'indicateur <command>HASHES</command>, donc ceci
</para> </answer>

<answer> <para> Supposons que vous souhaitez réparer une instance existante, et vous constatez 
que vos propres scripts ne fonctionneront pas bien, vous pouvez suivre la démarche suivante : </para>

<programlisting>
/* cbbrowne@[local]/dba2 slony_test1=*/ \x     
Expanded display is on.
/* cbbrowne@[local]/dba2 slony_test1=*/ select * from pg_operator where oprname = '=' 
and oprnamespace = (select oid from pg_namespace where nspname = 'public');
-[ RECORD 1 ]+-------------
oprname      | =
oprnamespace | 2200
oprowner     | 1
oprkind      | b
oprcanhash   | t
oprleft      | 82122344
oprright     | 82122344
oprresult    | 16
oprcom       | 82122365
oprnegate    | 82122363
oprlsortop   | 82122362
oprrsortop   | 82122362
oprltcmpop   | 82122362
oprgtcmpop   | 82122360
oprcode      | "_T1".xxideq
oprrest      | eqsel
oprjoin      | eqjoinsel

/* cbbrowne@[local]/dba2 slony_test1=*/ update pg_operator set oprcanhash = 'f' where 
oprname = '=' and oprnamespace = 2200 ;
UPDATE 1
</programlisting>
</answer>

</qandaentry>
<qandaentry> <question><para> Je peux faire un <command>pg_dump</command>
et chargez les données en les sauvegardant, beaucoup plus rapidement que si <command>SUBSCRIBE
SET</command> les exécutait lui-même. Pourquoi c'est ainsi?  </para></question>

<answer><para> &slony1; dépend des index, supposons qu'il soit sur un  clef primaire, dont les feuilles se trouvant isolées (sans branches), en utilisant la commande
 &postgres; <command>COPY</command> les données sont lues rapidement.
Alors que il peut y avoir une dégradation de performance, provoquée par l'évènement <command>COPY SET</command> (un 
évènement généré par le souscripteur) dans la mesure où l'opération dans ce cas démarre par d'abord une suppression des contenus des tables, et rien que cela laisse des tuplets morts.</para>

<para> Lorsque vous utilisez <command>pg_dump</command> pour exporter le contenus de la base, et que vous les re-importez après, les indexes ne sont crées qu'à la fin. Ceci est <emphasis>beaucoup</emphasis> plus performant des reconstruire les indexes sur une table entièrement re-importée, plutôt que de refaire les indexes à la volet lorsque les enregistrement sont rajoutés un à un à la table.</para></answer>

<answer><para> Si d'emblée, vous pouvez supprimer des indexes inutiles, lorsque <command>COPY</command> se met en marche, les performances sont sensiblement améliorée. Encore mieux, si vous pouvez<command>TRUNCATER</command> les tables dont le contenu devra disparaître, les performance vont augmenter d'<emphasis>avantage.</emphasis> </para></answer>

<answer><para> &slony1; en version 1.1.5 et supérieur, fait cela automatiquement; il <quote>cogne</quote> sur les indexes dans le catalogue de &postgres; afin de les inhiber, de plus, de la même façon il désactive les déclencheurs, tout en les <quote>réactivant</quote> à la fin sans oublier de reconstruire les indexes des tables en question. </para> </answer>
</qandaentry>

<qandaentry id="dupkey">
<question><para>La réplication échoue - Violation des Constraintes unique</para>

<para>Alors que la Réplication se déroule correctement, depuis un bout de temps, lorsque le noeud rencontre <quote>intempestivement,</quote> des erreurs suivant envoyées dans le journal:

<screen>
DEBUG2 remoteWorkerThread_1: syncing set 2 with 5 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 1 with 41 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 5 with 1 table(s) from provider 1
DEBUG2 remoteWorkerThread_1: syncing set 3 with 1 table(s) from provider 1
DEBUG2 remoteHelperThread_1_1: 0.135 seconds delay for first row
DEBUG2 remoteHelperThread_1_1: 0.343 seconds until close cursor
ERROR  remoteWorkerThread_1: "insert into "_oxrsapp".sl_log_1          (log_origin, log_xid, log_tableid,                log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '34', '35090538', 'D', '_rserv_ts=''9275244''');
delete from only public.epp_domain_host where _rserv_ts='9275244';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '34', '35090539', 'D', '_rserv_ts=''9275245''');
delete from only public.epp_domain_host where _rserv_ts='9275245';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090540', 'D', '_rserv_ts=''24240590'''); 
delete from only public.epp_domain_contact where _rserv_ts='24240590';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090541', 'D', '_rserv_ts=''24240591''');
delete from only public.epp_domain_contact where _rserv_ts='24240591';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '26', '35090542', 'D', '_rserv_ts=''24240589''');
delete from only public.epp_domain_contact where _rserv_ts='24240589';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '11', '35090543', 'D', '_rserv_ts=''36968002''');
delete from only public.epp_domain_status where _rserv_ts='36968002';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '11', '35090544', 'D', '_rserv_ts=''36968003''');
delete from only public.epp_domain_status where _rserv_ts='36968003';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090549', 'I', '(contact_id,status,reason,_rserv_ts) values (''6972897'',''64'','''',''31044208'')');
insert into public.contact_status (contact_id,status,reason,_rserv_ts) values ('6972897','64','','31044208');insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090550', 'D', '_rserv_ts=''18139332''');
delete from only public.contact_status where _rserv_ts='18139332';insert into "_oxrsapp".sl_log_1	  (log_origin, log_xid, log_tableid,		log_actionseq, log_cmdtype,		log_cmddata) values	  ('1', '919151224', '24', '35090551', 'D', '_rserv_ts=''18139333'''); 
delete from only public.contact_status where _rserv_ts='18139333';" ERROR:  duplicate key violates unique constraint "contact_status_pkey"
 - qualification was: 
ERROR  remoteWorkerThread_1: SYNC aborted
</screen></para>

<para>La transaction s'annule, et &slony1; essaie à nouveau sans cesse.
Le problème est dû à une des <emphasis>dernière</emphasis> requête SQL
précisant  <command>log_cmdtype = 'I'</command>. Ce n'est pat tout à fait évident; ce qui se passe est que &slony1; regroupe 10 opérations de mise à jour, ensemble, afin de diminuer les aller-retour réseau.</para></question>

<answer><para> Une origine <emphasis>certaine</emphasis>  pour ceci est difficile à déterminer.</para>

<para>En même temps, nous notons qu'il y a un problème de transactions manquées concernant les suppressions qui sont déjà nettoyées dans <xref
linkend="table.sl-log-1"/>, et on constate qu'un recouvrement est impossible. A ce stade, ce qui semble nécessaire, est de supprimer le jeu de réplication (ou même carrément le noeud), est de redémarrer la réplication de début pour le noeud.</para>

<para>Dans &slony1; 1.0.5, l'opération de purge de <xref
linkend="table.sl-log-1"/> devient plus prudente, en refusant 
de purger des entrées qui n'ont pas encore été synchronisées. pour au moins 10 minutes sur l'ensemble des noeuds. Il n'est pas certain que ceci empêche que
<quote>le problème</quote> ait lieu, mais il paraît plausible que  cela laisse assez de volume dans <xref linkend="table.sl-log-1"/> permettant un recouvrement ou bien de permettre d'au moins de diagnostiquer plus exactement la situation. Et peut-être que le problème venait du fait que <xref linkend="table.sl-log-1"/> a été brutalement purgée, donc cette solution permet de résoudre complètement ce genre d'incident.</para>

<para> C'est une honte de reconstruire un réplication volumineuse sur un noeud,
si vous découvrez que le problème pérciste. La bonne idée serai de diviser la réplication
en plusieurs morceaux afin de dimin<envar>tgrelid</envar> en les pointant sur l'identifiant OID of the <quote>primary
key</quote> index on the table rather than to the table
uer la charge de travail lors de redémarrage de réplication.
Si un seul jeu est cassé, vous n'auriez qu'à désabonner et supprimer celui-ci.
</para>

<para> Dans un cas, nous avons trouvé deux lignes dans le journal d'erreur des requêtes sql
qui sont  <emphasis> identique </emphasis> concernant l'insertion dans
 <xref linkend="table.sl-log-1"/>. Ceci <emphasis> doit
</emphasis> être impossible d'autant plus qu'il s'agit d'une clef primaire sur <xref
linkend="table.sl-log-1"/>.  La dernière théorie, moins forte, laisserait à penser que cette situation
viendrait que <emphasis>cette</emphasis> clé serait peut-être corrompue (présence d'un bug de &postgres;), et afin de soulever ce doute, 
on peut exécuter l'ordre suivant:</para>

<programlisting>
# reindex table _slonyschema.sl_log_1;
</programlisting>

<para> Au moins dans une occasion cette solution s'est révélée efficace, alors cela sera dommage de ne pas suivre l'exemple.</para>
</answer>

<answer> <para> Ce problème s'est avéré comme un bug dans &postgres; par opposition à un autre dans &slony1;. La version 7.4.8 avait intégré deux solutions qui permettent de résoudre ce cas. Or si vous avez un noyau de &postgres; antérieur à 7.4.8,
vous devriez migrer d'abord pour éviter l'erreur.
</para>
</answer>
</qandaentry>
<qandaentry> <question><para>J'ai commencé à faire une sauvegarde via
<application>pg_dump</application>, et Slony
s'arrête soudainement</para></question>

<answer><para>Ouf. Ce qui se passe dans ce cas est à cause d'un conflit entre:
<itemizedlist>

<listitem><para> <application>pg_dump</application>, qui sort un <command>AccessShareLock</command> pour toutes les tables de la base, y compris celle de &slony1; et</para></listitem>

<listitem><para> Une synchronisation de &slony1; qui veut saisir
<command>AccessExclusiveLock</command> sur la table <xref
linkend="table.sl-event"/>.</para></listitem> </itemizedlist></para>

<para>La requête initiale qui est bloquée est :

<screen>
select "_slonyschema".createEvent('_slonyschema, 'SYNC', NULL);	  
</screen></para>

<para>(vous pouvez voir ceci dans<envar>pg_stat_activity</envar>, si votre paramètre d'affichage des requête est positionné à vrai dans
<filename>postgresql.conf</filename>)</para>

<para>L'interrogation encours qui cause ce verrous vient de la fonction  <function>Slony_I_ClusterStatus()</function>, que vous trouverez dans 
<filename>slony1_funcs.c</filename>, localisé dans un bloc de code qui est :

<programlisting>
  LOCK TABLE %s.sl_event;
  INSERT INTO %s.sl_event (...stuff...)
  SELECT currval('%s.sl_event_seq');
</programlisting></para>

<para>Le <command>VERROUS</command> se poste à ce moment et dure jusqu'à ce que 
<command>pg_dump</command> (ou le temps que les verrous bloquent les accès à <xref linkend="table.sl-event"/>)
se términe.</para>

<para>Chaque lecture touchant 
<xref linkend="table.sl-event"/> sera bloqué derrière les appels à 
<function>createEvent</function>.</para>

<para>Les réponses à cette question sont multiples:
<itemizedlist>

<listitem><para> Faire spécifier à <application>pg_dump</application> d'exporter le schéma en utilisant l'option <option>--schema=whatever</option>, et ne pas essayer d'exporter le schéma du cluster entièrement.</para></listitem>

<listitem><para> Il sera utile aussi d'ajouter une option 
<option>--exclude-schema</option> à 
<application>pg_dump</application> afin d'exclure le schéma du cluster de &slony1;. A rêver que dans 8.2...</para></listitem>

<listitem><para>Notez que 1.0.5 utilise des verrous plus précis et moins exclusifs qui soulage ce problème.</para></listitem>
</itemizedlist></para>
</answer></qandaentry>

</qandadiv>

<qandadiv id="faqoddities"> <title> &slony1; FAQ: Singularité des vulnérabilité dans Slony-I </title>
<qandaentry><question><para> Que se produit à propos des règles et des déclencheurs pour des tables répliquées  par 
&slony1;?</para>
</question>

<answer><para> Premièrement regardons comment elle  est gérée
<emphasis>l'absence</emphasis> de gestion spécifique de  la commande Slonik<xref
linkend="stmtstoretrigger"/>.  </para>

<para> La fonction <xref
linkend="function.altertableforreplication-integer"/> prépare chacune des tables
pour la réplication.</para>

<itemizedlist>

<listitem><para> Sur le noeud maître, ceci implique l'ajout d'un déclencheur
qui utilise la fonction <xref linkend="function.logtrigger"/> à la table.</para>

<para> Le déclencheur a pour action d'enregistrer, toutes les mises à jours dans 
la table <xref linkend="table.sl-log-1"/> de &slony1;.
</para></listitem>

<listitem><para> Sur un noeud d'abonné, répliquer une table, revient à désactiver les déclencheurs,
puis, via un déclencheur, de restreindre le droit d'accès en écriture sur celle-ci en
utilisant la fonction <function>denyAccess()</function>.</para>

<para> Jusqu'à la version 1.1 (et peut-être avant), le
<quote>désactivation</quote> est faite en modifiant
<envar>pg_trigger</envar> ou <envar>pg_rewrite</envar>
<envar>tgrelid</envar> en pointant l'identifiant OID sur 
la  <quote>clé primaire</quote> de l'index du catalogue, plutôt qu'une action directe sur la table
elle-même.</para></listitem>

</itemizedlist>

<para> Un effet secondaire quelque part malheureu de ces actions sur les règles et les déclencheurs
donne un effet de les <quote>piétiner</quote>. Dans la mesure où les règles et les déclencheurs sont toujours là, 
mais ne plus correctement attachés à leurs tables. Si vous faite un <command>pg_dump</command> sur 
<quote>le noeud d'abonné</quote>, il ne trouvera pas les contraintes  ni les déclencheur, et surtout il ne s'attend pas
à les voir associés à un indexe.</para>

</answer>

<answer> <para> Maintenant observer comment  <xref linkend="stmtstoretrigger"/>
entre en jeu.</para>

<para> Mettez simplement cette commande  pour que 
&slony1; restore les déclencheurs :
<function>alterTableRestore(table id)</function>, qui restaure l'identifiant OID 
de la table dans <envar>pg_trigger</envar> ou 
<envar>pg_rewrite</envar> <envar>tgrelid</envar> sur le noeud affecté.</para></answer> 

<answer><para> Ceci implique que le jour où vous souhaitez lancer une sauvegarde directement
sur un abonné, vous devrez reprendre le schéma depuis un noeud d'origine. Clairement il faudra faire : </para>

<screen>
% pg_dump -h originnode.example.info -p 5432 --schema-only --schema=public ourdb > schema_backup.sql
% pg_dump -h subscribernode.example.info -p 5432 --data-only --schema=public ourdb > data_backup.sql
</screen>

</answer>
</qandaentry>

<qandaentry> <question> <para> J'essaie de demander  <xref
linkend="stmtddlscript"/> ou <xref linkend="stmtmoveset"/>, et trouves
les messages suivants sur l'un des abonnés :</para>

<screen>
NOTICE: Slony-I: multiple instances of trigger defrazzle on table frobozz
NOTICE: Slony-I: multiple instances of trigger derez on table tron
ERROR: Slony-I: Unable to disable triggers
</screen>
</question>

<answer> <para> La  difficulté semble venir du fait que 
vous ajouter un déclencheur à une table dont le nom rentre en conflit,
avec le déclencheur que &slony1; cache. </para>

<para> &slony1; cache des déclencheurs (sauf ceux marqués comme <quote>unhidden</quote>
via <xref linkend="stmtstoretrigger"/>) en les attachant à la clé primaire de leur table.
Dans le cas d'une clef étrangère, d'autre déclencheurs sont rajoutés afin de garantir la cohérence des données.
Il est complètement inutile des les lancer depuis un abonné, ainsi ces déclencheurs doivent être provoquer 
depuis le noeud d'origine. En revanche, les déclencheurs de type
<quote>cache invalidation</quote> sont ceux que vous devrez lancer depuis l'abonné.</para>

<para> La <emphasis>bonne manière</emphasis> de manipuler ce genre de déclencheurs est d'utiliser
 <xref linkend="stmtstoretrigger"/>, qui indique à 
&slony1; de ne pas désactiver des déclencheurs. </para> </answer>

<answer> <para> Mais il peut y avoir quelques DBA intrépides, qui vont assumer individuellement ce travail on
installant les déclencheur à la main sur l'abonné, et donc capable de  créer ce genre de situation. Que faire?
</para>

<para> La réponse est assez simple : Retirez le déclencheur
<quote>spécifique</quote> sur l'abonné avant de dérouler la restauration.
Dans le meilleur des cas, si le DBA est intrépide et réactif, il aurait fait cela 
<emphasis>avant</emphasis> que le message ait le temps d'arriver. </para>

<para> Si le DBA n'est pas intrépide, la réponse serait de se connecter au noeud
offensé, et de supprimer la version <quote>visible</quote> du déclencheur utilisant l'ordre 
 <acronym>SQL</acronym> <command>DROP
TRIGGER</command>. Ceci permet à l'évènement de se dérouler.
Si l'évènement était <xref linkend="stmtddlscript"/>, alors notre 
<quote>pas-tellement-intrépide </quote> DBA devra ajouter le trigger à la main,
ou, s'il y a plus de sagesse, de les réactiver avec 
<xref linkend="stmtstoretrigger"/>.</para>
</answer>
</qandaentry>

<qandaentry id="neededexecddl">

<question> <para> Comportement - tous les noeuds d'abonné, ainsi que le noeud maître,
commence à se planter, crachant le message d'erreur suivant dans le journal,
(lorsque j'ai rencontré ce problème, il y avait une longue requête SQL devant chaque message ):</para>

<screen>
ERROR remoteWorkerThread_1: helper 1 finished with error
ERROR remoteWorkerThread_1: SYNC aborted
</screen>
</question>

<answer> <para> Cause: you have likely issued <command>alter
table</command> statements directly on the databases instead of using
the slonik <xref linkend="stmtddlscript"/> command.</para>

<para>La solution consiste à  remettre le trigger sur la table affectée,
et de corriger les données afférentes dans <xref linkend="table.sl-log-1"/> by hand.</para>

<itemizedlist>

<listitem><para> Vous avez besoin d'extraire du journal soit de slon, soit
du &postgres; l'ordre sql exact qui a causé l'anomalie.</para></listitem>

<listitem><para> Vous avez besoin de corriger le déclencheur Slony-defined dans la table 
en question. Ceci peut se faire à l'aide de la procédure suivante :</para>

<screen>
BEGIN;
LOCK TABLE table_name;
SELECT _oxrsorg.altertablerestore(tab_id);--tab_id is _slony_schema.sl_table.tab_id
SELECT _oxrsorg.altertableforreplication(tab_id);--tab_id is _slony_schema.sl_table.tab_id
COMMIT;
</screen>

<para>Ensuite vous avez besoin de sélectionner les enregistrements dans  <xref
linkend="table.sl-log-1"/> qui sont incohérent pour les corriger. Il faudra ensuite arrêter
les processes de Slon pour l'ensemble des noeuds excepté celui du maître;
de cette manière vous évitez que l'erreur se propage immédiatement à travers tous les noeuds.</para>

<para> Voici un exemple:</para>

<screen>
BEGIN;

LOCK TABLE customer_account;

SELECT _app1.altertablerestore(31);
SELECT _app1.altertableforreplication(31);
COMMIT;

BEGIN;
LOCK TABLE txn_log;

SELECT _app1.altertablerestore(41);
SELECT _app1.altertableforreplication(41);

COMMIT;

--fixing customer_account, which had an attempt to insert a "" into a timestamp with timezone.
BEGIN;

update _app1.sl_log_1 SET log_cmddata = 'balance=''60684.00'' where pkey=''49''' where log_actionseq = '67796036';
update _app1.sl_log_1 SET log_cmddata = 'balance=''60690.00'' where pkey=''49''' where log_actionseq = '67796194';
update _app1.sl_log_1 SET log_cmddata = 'balance=''60684.00'' where pkey=''49''' where log_actionseq = '67795881';
update _app1.sl_log_1 SET log_cmddata = 'balance=''1852.00'' where pkey=''57''' where log_actionseq = '67796403';
update _app1.sl_log_1 SET log_cmddata = 'balance=''87906.00'' where pkey=''8''' where log_actionseq = '68352967';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125180.00'' where pkey=''60''' where log_actionseq = '68386951';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125198.00'' where pkey=''60''' where log_actionseq = '68387055';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125174.00'' where pkey=''60''' where log_actionseq = '68386682';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125186.00'' where pkey=''60''' where log_actionseq = '68386992';
update _app1.sl_log_1 SET log_cmddata = 'balance=''125192.00'' where pkey=''60''' where log_actionseq = '68387029';

</screen>
</listitem>

</itemizedlist>
</answer>

</qandaentry>

<qandaentry> 

<question><para> Le noeud numéro 1 a été supprimé via <xref
linkend="stmtdropnode"/>, et le &lslon; d'un des noeuds fait cracher le message 
d'erreurs suivant:</para>

<screen>
ERROR  remoteWorkerThread_3: "begin transaction; set transaction isolation level
 serializable; lock table "_mailermailer".sl_config_lock; select "_mailermailer"
.storeListen_int(2, 1, 3); notify "_mailermailer_Event"; notify "_mailermailer_C
onfirm"; insert into "_mailermailer".sl_event     (ev_origin, ev_seqno, ev_times
tamp,      ev_minxid, ev_maxxid, ev_xip, ev_type , ev_data1, ev_data2, ev_data3
   ) values ('3', '2215', '2005-02-18 10:30:42.529048', '3286814', '3286815', ''
, 'STORE_LISTEN', '2', '1', '3'); insert into "_mailermailer".sl_confirm
(con_origin, con_received, con_seqno, con_timestamp)    values (3, 2, '2215', CU
RRENT_TIMESTAMP); commit transaction;" PGRES_FATAL_ERROR ERROR:  insert or updat
e on table "sl_listen" violates foreign key constraint "sl_listen-sl_path-ref"
DETAIL:  Key (li_provider,li_receiver)=(1,3) is not present in table "sl_path".
DEBUG1 syncThread: thread done
</screen>

<para> Evidemment une demande de  <xref linkend="stmtstorelisten"/> n'avait pas encore
été propagé avant que le noeud 1 soit éliminé.</para></question>

<answer id="eventsurgery"><para> Ceci indique le cas où vous avez besoin de 
<quote>opération chirurgicale</quote> sur l'un ou plusieurs noeuds.
Un évènement<command>STORE_LISTEN</command> demeure sans réponse lorsqu'il veut 
ajouter un port d'écoute qui <emphasis>ne peut pas</emphasis> être satisfait car 
le noeud 1 ainsi que tous les éléments indiquant ce noeud sont disparus.</para>

<para> Supposons que pour la démonstration, les noeuds encore en place
soient le 2 et le 3, ainsi le rapport d'erreur est remonté au noeud 3.</para>

<para> cela implique que l'évènement se généré sur le noeud 2, comme il ne peut être sur le 
noeud 3, si il n'a pas été traité avec succès. La manière la plus facile à faire face à cette situation,
est, de supprimer sur le noeud offensé, les données dans <xref linkend="table.sl-event"/> relatives au noeud 2.
Vous vous connectez à la base du noeud 2, et à l'aide de Sql suivant, de chercher l'évènement
<command>STORE_LISTEN</command>:</para>

<para> <command> select * from sl_event where ev_type =
'STORE_LISTEN';</command></para>

<para> L'ordre peut ramener plusieurs lignes, mais ne en supprimer que la partie nécessaire.</para>

<screen> 
-# begin;  -- Don't straight delete them; open a transaction so you can respond to OOPS
BEGIN;
-# delete from sl_event where ev_type = 'STORE_LISTEN' and
-#  (ev_data1 = '1' or ev_data2 = '1' or ev_data3 = '1');
DELETE 3
-# -- Seems OK...
-# commit;
COMMIT
</screen>

<para> La prochaine fois que <application>slon</application> pour le noeud 3 redémarre, 
il ne trouvera plus le <quote>souffrant</quote> évènement 
<command>STORE_LISTEN</command>, et la réplication peur se poursuivre.
(Vous pouvez par contre voir surgir un vieil évènement enregistré qui ne soit plus en phase 
avec la configuration existante...) </para></answer>

</qandaentry>
</qandadiv>

</qandaset>
