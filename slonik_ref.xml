<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<article id="slonikref">
<title>Tour d'horizon des commandes Slonik</title>
  <sect1><title>Introduction</title>    
    <para><application>Slonik</application> est un utilitaire en ligne de commande
    conçu spécifiquement pour mettre en place et modifier la configuration 
    du système de réplication &slony1;.</para>
    <sect2 id="outline">
      <title>Considérations générales</title>
      <para>
      L'utilitaire en ligne de commande <application>slonik</application>
      est supposé être intégré dans des scripts shell et lit 
      les commandes à partir d'un fichier ou de stdin (voir plus 
      bas pour des exemples). Presque tout le travail de configuration
      <emphasis>réel</emphasis> est effectué en appelant des procédures
      stockées après avoir chargé la base de support &slony1; dans 
      la base de données. Vous pouvez trouver de la documentation sur
      ces procédures dans le chapitre <ulink url="schemadoc">Documentation
      du schéma de &slony1;</ulink>, ainsi que dans les commentaires
      qui sont associés aux procédures dans la base de données.
      </para>
      <para>
        <application>Slonik</application> a été créé car&nbsp;:
        <itemizedlist>
        
          <listitem><para>Les procédures stockées ont des besoins d'informations
	        spécifiques telles que l'identifiant du n&oelig;ud de réplication 
	        sur lequel elles sont appelées&nbsp;;</para></listitem>
          
          <listitem><para>L'absence de paramètres nommés dans les 
	        procédures stockées rend difficile de faire cela depuis
	        l'invite de commande <application>psql</application>&nbsp;;
	        </para></listitem>
        
          <listitem><para><application>psql</application> n'a pas la possibilité
	        de maintenir plusieurs connexions avec des transactions ouvertes.
	        </para></listitem>
        </itemizedlist>
      </para>
      <para>
     
      </para>
      <sect3><title>Commandes</title>
        <para>Le format du langage de commande slonik est libre.
        Les commandes commencent par des mots-clefs et sont terminées
        par un point-virgule. La plupart des commandes ont une liste de 
        paramètres, certains ont une valeur par défaut et sont donc 
        facultatifs. Les paramètres de commandes sont entourés par des
        parenthèses. Chaque option est constituée d'un ou plusieurs
        mots-clefs, suivis d'un symbole égal, suivi d'une valeur. Les 
        options multiples à l'intérieur de parenthèses sont séparées par
        des virgules. Tous les mot-clefs sont sensibles à la casse. Le
        langage devrait rappeler le SQL.</para>
        <para>Les valeurs d'option peuvent être&nbsp;:</para>
          <itemizedlist>
            <listitem><para>des entiers&nbsp;;</para></listitem>
            <listitem><para>des chaînes de caractères entourés de guillemets&nbsp;;</para></listitem>
            <listitem><para>des valeurs booléennes {TRUE|ON|YES} ou {FALSE|OFF|NO}&nbsp;;</para></listitem>
            <listitem><para>des mots-clefs dans des cas spécifiques.</para></listitem>
          </itemizedlist>

      </sect3>
      <sect3><title>Commentaires</title>
        <para>Les commentaires commencent par un dièse (#) et vont jusqu'à la fin de la ligne.</para>
      </sect3>
      <sect3><title>Groupes de commandes</title>
        <para>Les commandes peuvent être combinées par groupes de commandes avec une 
        éventuellement une condition <command>on error</command> et 
        <command>on success</command>. 
        La syntaxe est la suivante&nbsp;:
        <programlisting>
         try {
         commands;
         } 
         [on error { commands; }
         [on success { commands; }
        </programlisting></para>

         <para>Ces commandes sont regroupées ensemble au sein d'une transaction
           pour chaque n&oelig;ud participant.</para>
      </sect3>
    </sect2>
  </sect1>
</article>
<!-- ************************************************************ -->
<reference id="metacmds">
  <title>Méta-commandes Slonik</title>
  <partintro>
    <para>Les commandes suivantes sont utilisées pour séparer
    les définitions des composants des scripts Slonik&nbsp;;
    <xref linkend="stmtinclude"/> regroupe la configuration 
    dans des fichiers centraux qui peuvent être réutilisés, et 
    <xref linkend="stmtdefine"/> permet de remplacer les identifiants
    numériques et ésotériques des objets par des identifiants mnémotechniques.</para>
  </partintro>
  <!-- **************************************** -->
  <refentry id ="stmtinclude">
    <refmeta><refentrytitle>INCLUDE</refentrytitle><manvolnum>7</manvolnum></refmeta>
    <refnamediv>
      <refname>INCLUDE</refname>
      <refpurpose>insérer du code slonik à partir d'un autre fichier</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>include </command>
        <arg><replaceable class="parameter">&lt;chemin&gt;</replaceable></arg>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>Description</title>
      <para>Ceci injecte le script slonik spécifié à l'intérieur du script actuel.
      Si le <option>chemin</option> est relatif, <xref linkend="slonik"/> 
      cherchera à partir du répertoire de travail.</para>
      <para>Les inclusions imbriquées sont supportées. Le scanner et l'analyseur
      retournent le bon nom de fichier et le numéro ligne correcte en cas
      d'erreur.</para>
    </refsect1>
    <refsect1><title>Exemple</title>
      <programlisting>
        include &lt;/tmp/preamble.slonik&gt;;
      </programlisting>
    </refsect1>
    <refsect1><title>Note de version</title>
      <para>Cette commande fut introduite dans &slony1; 1.1.</para>
    </refsect1>
  </refentry>
  <!-- **************************************** -->
  <refentry id ="stmtdefine"><refmeta><refentrytitle>DEFINE</refentrytitle><manvolnum>7</manvolnum></refmeta>
    <refnamediv><refname>DEFINE</refname>
      <refpurpose>Définir un nom symbolique</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>define </command>
        <arg><replaceable class="parameter">nom</replaceable></arg>
        <arg><replaceable class="parameter">valeur</replaceable></arg>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>Description</title>
      <para>Ceci définit un nom symbolique. Les noms symboliques doivent
      respecter les règles de slonik en matière de construction d'identifiants,
      en commençant par une lettre, suivie de lettres, de nombres et de soulignés
      («&nbsp;_&nbsp;»).</para>
      <para>Les valeurs des noms symboliques peuvent contenir des espaces et peuvent contenir
      des références à des noms symboliques, de manière récursive.</para>
      <para>Les symboles sont référencés en utilisant une arobase <quote>@</quote> suivi
      du nom symbolique. Notons que le référencement d'un symbole est annulé
      à l'intérieur des chaînes de caractères.</para>
    </refsect1>
    <refsect1><title>Exemple</title>
      <programlisting>
        define    cluster films;
        define    sakai   1;
        define    chen    2;
        define    fqn     fully qualified name;

        cluster name = @cluster;
        node @sakai admin conninfo = 'service=sakai-replication';
        node @chen  admin conninfo = 'service=chen-replication';
        define setFilms    id = 1;
        define sakaiFilms  @setFilms, origin = @sakai;

        create set ( @sakaiFilms, comment = 'films' );

        set add table( set @sakaiFilms, id = 1, @fqn = 'public.clients', 
               comment = 'sakai customers' );
        set add table( set @sakaiFilms, id = 2, @fqn = 'public.cassettes',     
               comment = 'sakai cassettes' );
        echo '@sakaiFilms sera affiché comme une chaîne, et ne sera pas interprété';
      </programlisting>
    </refsect1>

    <refsect1> <title>Note de version</title>
      <para>Cette commande fut introduite dans &slony1; 1.1.</para>
    </refsect1>
  </refentry>
</reference>  
  
<!-- **************************************** -->

<reference id="hdrcmds"> 
  <title>Commandes slonik préliminaires</title>
  <partintro>
    <para>Les commandes suivantes doivent apparaître en <quote>préambule</quote>
    de chaque script de commande <application>slonik</application>. 
    Ils ne provoquent aucune action directement sur les n&oelig;uds du
    système de réplication, mais affecte l'exécution du script tout entier.</para>
  </partintro>
  <refentry id ="clustername">
    <refmeta><refentrytitle>CLUSTER NAME</refentrytitle><manvolnum>7</manvolnum></refmeta>
    <refnamediv>
      <refname>CLUSTER NAME</refname>
      <refpurpose>préambule - identifier le cluster &slony1;</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>CLUSTER NAME = </command>
        <arg><replaceable class="parameter">nom</replaceable></arg>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>Description</title>
      <para>Ceci doit être la toute première ligne de chaque script
      <application>slonik</application>. Elle définit le schéma
      dans lequel toutes les fonctions spécifiques, les procédures,
      les tables et les séquences de &slony1; sont déclarées.
      Le nom du schéma est construit en préfixant la chaîne
      de caractères fournie par un souligné. Ce schéma sera 
      identique sur toutes les bases de données qui participent 
      au même groupe de réplication.</para>
    
      <para>Aucun objet utilisateur n'est supposé être placé dans ce schéma,
      et ce schéma ne doit pas exister avant l'ajout de la base de données
      dans le système de réplication. Ainsi, si vous ajoutez un nouveau n&oelig;ud
      en utilisant <command>pg_dump -s</command> sur une base qui est déjà 
      dans le cluster de réplication, vous devrez supprimer le schéma
      avec la commande SQL <command> DROP SCHEMA _testcluster CASCADE;</command>.</para>
    </refsect1>
    <refsect1><title>Exemple</title>
      <programlisting>
        CLUSTER NAME = testcluster;
      </programlisting>
    </refsect1>
    <refsect1> <title>Note de version</title>
      <para>Cette commande fut introduite dans &slony1; 1.0.</para>
    </refsect1>
  </refentry>
  <refentry id ="admconninfo">
    <refmeta><refentrytitle>ADMIN CONNINFO</refentrytitle><manvolnum>7</manvolnum></refmeta>
    <refnamediv>
      <refname>ADMIN CONNINFO</refname>
      <refpurpose>preambule - identifier la base &postgres;</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>NODE ival ADMIN CONNINFO = 'DSN';</command>
        <arg><replaceable class="parameter">ival</replaceable></arg>
        <arg><replaceable class="parameter">'conninfo'</replaceable></arg>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>Description</title>
      <para>Décrit comment l'utilitaire <application>slonik</application> peut
      atteindre les bases des n&oelig;uds du cluster à partir de l'endroit
      où il se trouve (en général le poste de travail de l'administrateur).
      La chaîne connifo est l'argument passé à la fonction 
      libpq <function>PQconnectdb()</function>. L'utilisateur qui se connecte
      doit être un super-utilisateur spécifique à la réplication car certaines
      actions réalisées par la suite comprennent des opérations strictement réservées
      aux super-utilisateurs du serveur &postgres;.</para>

      <para>L'utilitaire <application>slonik</application> n'essaie de se connecter
      à une base de donnée que si une commande nécessite une connexion.</para>

      <note><para>Comme indiqué dans les document originaux, &slony1; est conçu comme
      un système de réplication d'entreprises pour centres de données. Lors du développement
      du logiciel, on présuppose que les serveurs de bases de données et les postes
      de travail impliqués dans la réplication et/ou dans les activités de mise en place et 
      de configuration peuvent utiliser des méthodes simples d'authentification telle que
      <quote>trust</quote>. Cependant, libpq peut lire les mots de passe dans le fichier
      <filename>.pgpass</filename>.</para></note>
      <note><para>Si vous devez changer les informations DSN pour un n&oelig;ud, par exemple si 
      l'adresse IP d'un hôte est modifiée, vous devez soumettre cette nouvelle
      information avec la commande <xref linkend="stmtstorepath"/>,
      et la configuration sera propagée. Certains processus 
      <application>slon</application> existant devront être relancés afin qu'ils
      soient avertis de ce changement de configuration.</para></note>

      <para>Pour plus de détails sur la distinction entre ceci et <xref
      linkend="stmtstorepath"/>, consultez le chapitre &rplainpaths;.</para>
    </refsect1>
    <refsect1><title>Exemple</title>
      <programlisting>
        NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
      </programlisting>
    </refsect1>
    <refsect1> <title>Note de version</title>
      <para>Cette commande fut introduite dans &slony1; 1.0.</para>
    </refsect1>
  </refentry>
</reference>

<!-- ************************************************************ -->
<reference id="cmds">
  <title>Commande de configuration et d'action</title>  
  <refentry id ="stmtecho">
    <refmeta>
      <refentrytitle>ECHO</refentrytitle><manvolnum>7</manvolnum></refmeta>
      <refnamediv>
        <refname>ECHO</refname>
        <refpurpose>Outil générique de sortie</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
          <cmdsynopsis>
            <command>echo</command>
            <arg><replaceable class="parameter">'message'</replaceable></arg>
          </cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
        <title>Description</title>
        <para>Affiche un message littéral sur la sortie standard.</para>
      </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     ECHO 'N&oelig;ud 1 initialisé correctement';
    </programlisting>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
  
  <!-- **************************************** -->
  
  <refentry id ="stmtexit"><refmeta><refentrytitle>EXIT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXIT</refname>
    
    <refpurpose>Termine un script Slonik avec un signal</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>exit</command>
     <arg><replaceable class="parameter"> [-]ival</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Termine immédiatement un script d'exécution, annulant toute
     les transactions ouvertes (ROLLBACK) sur toutes les bases de données
     connectées. L'utilitaire <application>slonik</application> retournera
     la valeur indiquée comme code de terminaison du programme.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     EXIT 0;
    </programlisting>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

  <!-- **************************************** -->
  <refentry id="stmtinitcluster">
   <refmeta>
    <refentrytitle>INIT CLUSTER</refentrytitle>
     <manvolnum>7</manvolnum>
   </refmeta>
   <refnamediv>
    <refname>INIT CLUSTER</refname>
    <refpurpose>Initialise le cluster &slony1;</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>INIT CLUSTER</command> 
     <arg>ID = <replaceable class="parameter">entier</replaceable></arg>
     <arg>COMMENT = <replaceable class="parameter">'chaîne'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title> 

    <para> Initialise le premier n&oelig;ud d'un nouveau cluster de réplication &slony1;.
    Le processus d'initialisation consiste à créer le schéma du cluster, à
    charger toutes les tables, les fonctions, les procédures et à initialiser le n&oelig;ud
    avec  &funinitializelocalnode; et &funenablenode;.
     
     <variablelist>
      <varlistentry><term><literal>ID</literal></term>
       <listitem><para>L'identifiant numérique et unique du n&oelig;ud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal>COMMENT = 'commentaire'</literal></term> 
	<listitem><para>Un texte descriptif ajouté à la ligne du  n&oelig;ud dans
	    la table &slnode;. 
      </para></listitem>
      </varlistentry>
     </variablelist>
     
    </para>
    
    <para>Pour que ce processus fonctionne, les scripts SQL du système
      &slony1; doivent être installés sur le poste de travail de l'administrateur
      (l'ordinateur utilisé pour exécuter l'utilitaire <application>slonik</application>),
      tandis que sur le serveur qui héberge le n&oelig;ud de base de donnée contenant les
      objets partagés, &slony1; doit être installé dans le répertoire qui contient 
      les bibliothèques de &postgres;. De plus le langage procédural
    PL/pgSQL doit être installé au préalable sur la base de données cible.
    </para>
   </refsect1>
   <refsect1>
    <title>Exemple</title>
    <programlisting>
INIT CLUSTER (
   ID = 1,
   COMMENT = 'N&oelig;ud 1'
);
    </programlisting>

   <note> <para> Cette commande fonctionne de manière similaire à 
       <xref linkend="stmtstorenode"/>, la différence étant que <command>INIT
   CLUSTER</command> n'a pas besoin de récupérer la configuration des autres n&oelig;uds.
   </para> </note>
   <note> <para>Soyez conscients que certains objets qui sont créés contiennent
       le nom du cluster à l'intérieur de leur nom (notamment, les index
       partiels sur <envar>sl_log_1</envar> et <envar>sl_log_2</envar>).
       Ceci implique que les noms de cluster <emphasis>très longs</emphasis>
       sont une mauvaise idée car ils entraînent un dépassement des noms
       d'objets au delà de la limite de 63 caractères.
     </para> </note> 
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette commande crée un nouveau schéma et configure les
      tables à l'intérieur&nbsp;; aucun objet public ne doit être verrouillé
      pendant l'exécution de cette commande.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id ="stmtstorenode"><refmeta><refentrytitle>STORE NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE NODE</refname>
    <refpurpose>Initialise un n&oelig;ud &slony1;</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Initialise un nouveau n&oelig;ud et l'ajoute dans la configuration du 
      cluster existant.</para>

    <para>Le processus d'initialisation consiste à la création du schéma
      sur le nouveau n&oelig;ud (la base elle-même doit déjà exister), au
      chargement des tables, des fonctions, des procédures et à l'initialisation 
      du n&oelig;ud. La configuration existante du reste du n&oelig;ud est copiée
      à partir d'un <quote>n&oelig;ud d'événement</quote>.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para>L'identifiant numérique et unique du nouveau n&oelig;ud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal> COMMENT = 'description' </literal></term>
       <listitem><para>Un texte descriptif ajouté à la ligne du n&oelig;ud dans
	   la table &slnode;</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal>SPOOLNODE = booléen</literal></term>
       
       <listitem><para>Spécifie qu'un n&oelig;ud est un n&oelig;ud virtuel de récupération
	   pour l'archivage de journaux de réplication. Si ce paramètre est à true,
	   <application>slonik</application> n'essaiera pas d'initialiser la base de 
	   donnée avec le schéma de réplication.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>EVENT NODE = ival</literal></term>
       
       <listitem><para>L'identifiant du n&oelig;ud utilisé pour créer l'événement de configuration,
	   qui prévient tous les n&oelig;uds existants de l'arrivée du nouveau n&oelig;ud.
	   La valeur par défaut est 1.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>Ceci utilise &funinitializelocalnode; et &funenablenode;.</para>
    
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     STORE NODE ( ID = 2, COMMENT = 'N&oelig;ud 2');
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette commande crée un nouveau schéma et configure les tables
      à l'intérieur&nbsp;; aucun objet public ne doit être verrouillé
      pendant l'exécution de cette commande.</para>
   </refsect1>

   <refsect1> <title>Note de version</title> 
     <para>Cette commande fut introduite dans &slony1; 1.0. Le paramètre <envar>SPOOLNODE</envar>
     fut introduit dans la version 1.1 mais n'était pas implémentée dans cette version.
     La fonctionnalité <envar>SPOOLNODE</envar> est arrivée dans la
   version 1.2.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtdropnode"><refmeta><refentrytitle>DROP NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP NODE</refname>
    
    <refpurpose>Supprime un n&oelig;ud de la réplication</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un n&oelig;ud. Cette commande retire complètement le n&oelig;ud spécifié 
     de la configuration du système de réplication.
     Si le démon de réplication est toujours en fonctionnement sur ce n&oelig;ud
     (et qu'ils traitent les événements), il tentera de désinstaller le système
     de réplication et s'arrêtera de lui-même.

     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para>L'identifiant du n&oelig;ud à supprimer.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       <listitem><para>L'identifiant du n&oelig;ud qui génère l'événement. La valeur par défaut est 1.
       </para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>Cette commande utilise &fundropnode;.</para>

    <para>Quand vous invoquez <command>DROP NODE</command>, une des étapes
      consiste à lancer <command>UNINSTALL NODE</command>.</para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Lorsqu'on supprime des triggers d'une table de l'application,
      cela nécessite un accès exclusif à chaque table répliquée sur le n&oelig;ud
      que l'on supprime.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para>Si vous utilisez des connexions qui cachent les plans d'exécution
   (ce qui est particulièrement commun pour les frameworks applicatifs Java utilisant
   des pools de connexions), les connexions peuvent cacher des plans
   de requêtes qui se basent sur une vision pré-<command>DROP NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>

   <para>Ainsi après avoir supprimé un n&oelig;ud, il est préférable de réinitialiser
     les connexions de votre applications.</para>

   <para>Vous ne pouvez pas soumettre cela à un <command>EVENT
   NODE</command> ayant le même numéro que le n&oelig;ud que vous supprimez&nbsp;;
   la requête doit aller vers un n&oelig;ud qui restera dans le cluster.
   </para>
   </refsect1>

   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  <refentry id="stmtuninstallnode"><refmeta><refentrytitle>UNINSTALL NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNINSTALL NODE</refname>
    
    <refpurpose>Désinstaller un n&oelig;ud &slony1;</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNINSTALL NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Restaure toutes les tables dans leur état non verrouillé, avec 
      les triggers d'origines, les contraintes et les règles. Les éventuelles colonnes
      spécifiques de &slony1; contenant des clefs SERIAL sont supprimées.
      Enfin, le schéma  &slony1; est effacé. Le n&oelig;ud redevient une base de données
      indépendante. Les données ne sont pas modifiées.   
     <variablelist>
      <varlistentry><term><literal>ID  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud à désinstaller.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>Cette commande utilise &fununinstallnode;.</para>

    <para>La  différence entre <command>UNINSTALL NODE</command>
    et <command>DROP NODE</command> est que <command>UNINSTALL
    NODE</command> se contente de supprimer la configuration &slony1;&nbsp;;
    il ne retire la configuration du n&oelig;ud sur l'ensemble de réplication.
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  UNINSTALL NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Lorsqu'on supprime les triggers des tables de l'application,
      cela nécessite un accès exclusif à chaque table répliquée sur le n&oelig;ud
      que l'on désinstalle.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para>Si vous utilisez des connexions qui cachent les plans d'exécution
   (ce qui est particulièrement commun pour les frameworks applicatifs Java utilisant
   des pools de connexion), les connexions peuvent cacher des plans
   de requêtes qui se basent sur une vision pré-<command>UNINSTALL NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>   

   <para>Ainsi après avoir désinstallé un n&oelig;ud, il est préférable de réinitialiser
     les connexions de votre applications.</para>   
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrestartnode"><refmeta><refentrytitle>RESTART NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>RESTART NODE</refname>

    <refpurpose>Redémarre un n&oelig;ud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>RESTART NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Provoque l'arrêt et le redémarrage d'un démon 
      de réplication sur le n&oelig;ud spécifié.
      Théoriquement, cette commande est obsolète. En pratique,
      les délais TCP peuvent retarder les changements critiques 
      de configuration jusqu'à ce qu'il soit effectué alors que le
      n&oelig;ud expéditeur est en échec et doit être ignoré par les 
      n&oelig;uds abonnés.
     <variablelist>
      <varlistentry><term><literal>ID  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud à redémarrer.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  RESTART NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>


    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0&nbsp;;
      Elle ne devrait plus être nécessaire à partir de la version 1.0.5.</para>
   </refsect1>
  </refentry>
  

  <!-- **************************************** -->

  <refentry id="stmtstorepath"><refmeta><refentrytitle>STORE
     PATH</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE PATH</refname>
    
    <refpurpose>Configure la connexion d'un n&oelig;ud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Configure la connexion d'un démon de réplication d'un n&oelig;ud
      à la base de données d'un autre n&oelig;ud. Si le système
      de réplication est supposé utiliser un segment spécial de réseau,
      c'est ici qu'on définit les adresses IP ou les noms d'hôtes.
      Une configuration existante peut se trouver écrasée.
      </para>
    
    <para>Le paramètre conninfo doit contenir toutes les informations
      pour se connecter à la base en tant super-utilisateur de la réplication.
      Les termes <quote>serveur</quote> et <quote>client</quote> n'ont
      rien à voir avec le rôle particulier d'un n&oelig;ud dans la configuration
      d'un cluster. On peut simplement voir cela comme un
      <quote>serveur</quote> ayant un message or une donnée qu'un 
      <quote>client est supposé obtenir</quote>.
      Pour une installation simple avec deux n&oelig;uds, les chemins dans les deux 
      directions doivent être configurés.
    </para>
    <para>Il ne pose aucun problème de configurer un chemin entre chaque 
      n&oelig;ud (produit en croix complète). Les connexions ne sont établis que 
      si cela est nécessaire pour transférer un événement ou une confirmation
      à cause des entrées <emphasis>listen</emphasis> ou une donnée à cause de
     <emphasis>souscriptions</emphasis>.
     
     <variablelist>
      <varlistentry><term><literal>SERVER  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>CLIENT  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud du démon de réplication qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>CONNINFO  = string</literal></term>
       <listitem><para>Argument <function>PQconnectdb()</function> pour établir la connexion.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>CONNRETRY  = ival</literal></term>
       <listitem><para>Nombre de secondes d'attente avant qu'un autre tentative
	   de connexion soit faite dans le cas où le serveur est indisponible. 
	   La valeur par défaut est 10.
	</para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &funstorepath;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
STORE PATH ( SERVER = 1, CLIENT = 2, 
             CONNINFO = 'dbname=testdb host=serveur1 user=slony'
           );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>


    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
    </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdroppath"><refmeta><refentrytitle>DROP PATH</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP PATH</refname>
    
    <refpurpose>Supprime un chemin de connexion &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Supprime les informations de connexion entre un <quote>serveur</quote> et un
     <quote>client</quote>.</para>
     
     <variablelist>
      <varlistentry><term><literal>SERVER  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>CLIENT  = ival</literal></term>
       <listitem><para>Identifiant du n&oelig;ud du démon qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>EVENT NODE = ival</literal></term>
       
       <listitem><para> L'identifiant du n&oelig;ud utilisé pour créer l'événement de configuration
	qui annonce à tous les n&oelig;uds existants que le chemin a été supprimé. 
	La valeur par défaut est l'identifiant du n&oelig;ud <quote>client</quote>.
	</para></listitem>
      </varlistentry>
      </variablelist>
      </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP PATH ( SERVER = 1, CLIENT = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtstorelisten"><refmeta><refentrytitle>STORE LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE LISTEN</refname>
    
    <refpurpose>Configure un n&oelig;ud &slony1; en lui indiquant où il 
      doit écouter les événements</refpurpose></refnamediv>
    
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Pour chaque entrée <quote>listen</quote>, le n&oelig;ud récepteur demande
      à un n&oelig;ud fournisseur de lui envoyer les événements d'un autre n&oelig;ud
      ainsi que les confirmations en provenance de tous les autres n&oelig;uds existants.
      Un <quote>chemin</quote> doit exister pour
      que le récepteur (le client) puisse se connecter au fournisseur (le serveur).</para>

    <para>Chaque n&oelig;ud du système doit écouter les événements
      de tous les autres n&oelig;uds. En règle générale, un abonné
        (voir <xref linkend="stmtsubscribeset"/>) doit écouter les événements
    d'un ensemble origine sur un fournisseur unique, qui lui envoie
    les données. En retour, l'origine de l'ensemble de réplication
    doit écouter les événements dans la direction opposée.
    Un n&oelig;ud peut écouter simultanément les événements d'un même ensemble d'origine
    en provenance de différents fournisseurs. Cependant, pour traiter les 
    événements <command>SYNC</command> de cet ensemble d'origine, tous les
    fournisseurs de données doivent avoir un niveau de synchronisation égal 
    ou supérieur, afin d'éviter des comportements de réplication trop 
    rapide.
    </para>

    <variablelist>
     <varlistentry><term><literal>ORIGIN  = ival</literal></term>
      <listitem><para>L'identifiant du n&oelig;ud d'origine que le récepteur écoute.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>PROVIDER = ival</literal></term>
     <listitem><para>L'identifiant du n&oelig;ud qui envoie au récepteur les événements 
	 produits par le n&oelig;ud origine. Si cette valeur n'est pas spécifiée,
	 il s'agit du n&oelig;ud origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>RECEIVER = ival</literal></term>
      
      <listitem><para>L'identifiant du n&oelig;ud recevant les événements.</para></listitem>
     </varlistentry>
    </variablelist>

    <para>Cette commande utilise &funstorelisten;.</para>
    <para>Pour plus de détails, consultez &rlistenpaths;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     STORE LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title> <para>Cette commande fut introduite 
   dans &slony1; 1.0. À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroplisten"><refmeta><refentrytitle>DROP LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP LISTEN</refname>
    
    <refpurpose>Élimine la configuration qui décrit comment un n&oelig;ud
    &slony1; écoute les  événements
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Supprime une <quote>voie d'écoute</quote> de la configuration.</para>
    
    <variablelist>
     <varlistentry><term><literal>ORIGIN  = ival</literal></term>
      <listitem><para>Identifiant du n&oelig;ud origine que le récepteur écoute.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>PROVIDER = ival</literal></term>
     <listitem><para>Identifiant du n&oelig;ud qui envoie au récepteur les événements
	 produits par l'origine. Si cette valeur n'est pas spécifiée, alors il 
	 s'agit de l'origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>RECEIVER = ival</literal></term>
      
      <listitem><para>L'identifiant du n&oelig;ud qui reçoit les événements.</para></listitem>
     </varlistentry>
    </variablelist>
    
    <para>Cette commande utilise &fundroplisten;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title> <para>Cette commande fut introduite 
   dans &slony1; 1.0. À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

<refentry id="stmttableaddkey"><refmeta><refentrytitle>TABLE ADD KEY</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>TABLE ADD KEY</refname>
    
    <refpurpose> Ajoute une clef primaire pour 
    &slony1; dans une table qui n'en possède pas
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>TABLE ADD KEY (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans un système de réplication &slony1;, chaque table répliquée 
     doit avoir au moins une contrainte
     <command>UNIQUE</command> dont les colonnes sont déclarées
     <command>NOT NULL</command>. N'importe quel clef primaire
     respecte ces pré-requis.
    </para>

    <para>
     En dernier recours, <emphasis>dans les versions de &slony1; antérieures
       à la 2.0</emphasis>, cette commande peut être utilisée pour ajouter 
     un attribut à une table qui ne possède par de clef primaire.
     Sachant que cette modification peut avoir des effets secondaires
     indésirables, <emphasis>il est très fortement recommandé que les 
       utilisateurs ajoutent les attributs unique et not null par 
       leurs propres moyens</emphasis>.
    </para>

   <para>Si vous comptez utilisez &slony1; version 2.0, vous
   <emphasis>devez</emphasis> vous débrouiller pour définir
   une clef primaire plus adéquate.
   &slony1; ne vous en fournira pas une et si vous 
   avez des clefs créées via <command>TABLE ADD KEY</command>,
   ne vous attendez pas à ce que &slony1; fonctionne correctement.</para>
    <variablelist>
     <varlistentry><term><literal>NODE ID = ival</literal></term>
      <listitem><para>Identifiant du n&oelig;ud de l'ensemble de réplication d'origine
	  où l'on ajoute la table dans l'ensemble (voir <xref linkend="stmtsetaddtable"/>).</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>FULLY QUALIFIED NAME  = 'string'</literal></term>
      <listitem><para>Le nom complet de la table composé du nom du schéma
	  et du nom de la table, au format SQL suivant 
	<command>quote_ident(nspname)
	 || '.' || quote_ident(relname)</command>.</para></listitem>
     </varlistentry>
    </variablelist>

    <note><para>Pour le moment il existe des limitations; vous pouvez
	créer une table &postgres; avec aucune colonne, par exemple 
	<command>create table table_vide ();</command>.  
	&slony1; refusera de manipuler une telle table.
	Ce n'est pas vraiment une limitation gênante car il est 
	n'est pas très intéressant de répliquer des tables qui ne contiennent
	aucune information.</para> </note>

    <caution><para><command>TABLE ADD KEY</command> <emphasis>ne doit
    pas être utilisée</emphasis> si vous pouvez vous en passer.
    C'est un <emphasis>élément</emphasis> des &bestpracticelink;.</para>

    <para>L'absence d'une clef primaire adéquate est
      une indication très sérieuse que le schéma est 
    <emphasis>défectueux</emphasis>. La
    <emphasis>bonne</emphasis> méthode pour le réparer est d'introduire
    un clef primaire adéquate, et non pas de demander à &slony1; d'en <quote>bricoler</quote> une.</para> 

    <para>Cette commande n'est <emphasis>pas</emphasis> supportée par le &logshiplink;,
    et nous n'avons pas l'intention de développer ce support.</para> </caution>
    
    <para>Cette commande utilise &funtableaddkey;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     TABLE ADD KEY ( NODE ID = 1, 
     FULLY QUALIFIED NAME = 'public.history' );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Sur le n&oelig;ud origine, la commande posera un verrou exclusif
      sur la table modifiée tant que ces opérations ne seront pas terminées&nbsp;:
     </para>
    <itemizedlist>
    <listitem><para>Modifier la table, ajouter la colonne&nbsp;;</para></listitem>
    <listitem><para>Modifier chaque ligne de la table, attacher la valeur de la séquence&nbsp;;</para></listitem>
    <listitem><para>Ajouter un nouvel index unique à la table.</para></listitem>
    </itemizedlist>

    <para>Sur les n&oelig;uds abonnés, ces modifications sont
      réalisées sur la table lorsqu'elle est TODO, et perturbe 
      pas particulièrement l'abonnement au cours du verrouillage
      sur le n&oelig;ud abonné.</para> 

    <para>Si la table est volumineuse et fréquemment mise à jour
      par vos applications, cela imposera une coupure de service
      significative qui correspond au temps de modification de la
      table sur le n&oelig;ud d'origine. C'est pourquoi il est recommandé
      que cette commande ne soit pas utilisée quand c'est possible.</para>      
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
<warning>    <para>Cette commande n'est <emphasis>plus supportée</emphasis>
    à partir de &slony1; version 2.0. Dans la version 2, les différentes
    <quote>modifications du catalogue</quote> réalisée sur les
    versions de &postgres; antérieures à la 8.3 sont éliminées
    afin que les exports de schéma puissent être utilisés sur n'importe
    quel n&oelig;ud. Ainsi les colonnes <quote>bricolées</quote> par
    <command>TABLE ADD KEY</command> sont la chose qui empêche la commande
    <xref linkend="stmtuninstallnode"/> d'être équivalente à 
    la commande SQL  <command>drop schema _nom_du_cluster 
    cascade;</command>.</para> </warning>    
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtcreateset"><refmeta><refentrytitle>CREATE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CREATE SET</refname>
    
    <refpurpose>Crée un ensemble de réplication &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>CREATE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans le système de réplication &slony1;, les tables répliquées sont 
     regroupées en ensembles. En règle générale, un ensemble contient 
     des tables reliées pour une application donnée. Dans une application
     correctement conçue, toutes ces tables sont regroupées dans un
     schéma.
    </para>
    <para>
     L'ensemble de réplication est la plus petite unité qu'un n&oelig;ud peut répliquer vers un autre n&oelig;ud.
     Un ensemble de réplication a toujours une origine. En terme classique,
     c'est ce qu'on appelle le <quote>maître</quote>.
     Puisqu'avec &slony1; un n&oelig;ud peut être simultanément <quote>maître</quote> pour un ensemble,
     et tenir le rôle  d'<quote>esclave</quote> pour un autre, cette terminologie peut 
     rapidement prêter à confusion et doit par conséquent être remplacée par 
      <quote>ensemble d'origine</quote> et <quote>abonné</quote>.
    </para>
    
    <variablelist>
     <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para>Identifiant de l'ensemble qu'il faut créer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>ORIGIN = ival</literal></term>
      <listitem><para>N&oelig;ud d'origine initial de cet ensemble.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>COMMENT = 'chaîne'</literal></term>
      <listitem><para>Un texte descriptif peut être ajouté pour l'ensemble de réplication.</para>
                <para>Si aucun commentaire n'est fourni, la valeur par défaut est  <command>A replication set so boring no one thought to give it a name</command> (NdT&nbsp;: <quote>Un ensemble de réplication tellement
		  ennuyeux que personne n'a pensé à lui donner un nom</quote>)
	      </para>
      </listitem>
     </varlistentry>
    </variablelist>
    
    <para>Cette commande utilise &funstoreset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     CREATE SET ( ID = 1, 
               ORIGIN = 1,
               COMMENT = 'Tables du système de réservation' );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
    <para>Jusqu'à la version 1.2, la commande échoue si aucun commentaire n'est fourni.</para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdropset"><refmeta><refentrytitle>DROP SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>DROP SET</refname>
    
    <refpurpose>Enlever un ensemble de réplication &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un ensemble de tables de la configuration &slony1;. 
     Cette commande désabonne automatiquement tous les n&oelig;uds qui 
     hébergent cet ensemble et rétablit les règles et les triggers 
     originaux sur tous les abonnés.
    </para>
    
    <variablelist>
     <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para>Identifiant de l'ensemble qu'il faut supprimer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>ORIGIN = ival</literal></term>
      <listitem><para>N&oelig;ud d'origine actuel de l'ensemble de réplication.</para></listitem>
     </varlistentry>
    </variablelist>
    
       <para>Cette commande utilise &fundropset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP SET ( ID = 5, 
             ORIGIN = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Sur chaque n&oelig;ud, la commande pose un verrou exclusif sur 
      chaque table répliquée afin de modifier le schéma de la table
      pour nettoyer les triggers et les règles.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
 
<!-- **************************************** -->

  <refentry id="stmtmergeset"><refmeta><refentrytitle>MERGE
     SET</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MERGE SET</refname>
    
    <refpurpose>Fusionne plusieurs ensembles de réplication &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MERGE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Fusionne un ensemble de tables et de séquences dans un autre ensemble.
      Cette fonction est un contournement face à l'impossibilité
      d'ajouter des tables/séquences à des ensembles en cours de
      réplication. On peut alors créer un ensemble temporaire, y ajouter
      les nouveaux objets, abonner tous les n&oelig;uds à ce nouvel ensemble,
      puis fusionner l'ensemble courant et l'ensemble temporaire, ce qui supprime
      l'identifiant de l'ensemble temporaire.
    </para>

    <para>
     Cette opération ne fonctionnera si les deux ensembles ne sont pas 
     répliqués <emphasis>exactement</emphasis> sur les mêmes n&oelig;uds abonnés.
     </para>
    
    <variablelist>
     <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para>Identifiant unique de l'ensemble qui contiendra les deux ensembles distincts.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>ADD ID = ival</literal></term>
      <listitem><para>Identifiant unique de l'ensemble de l'ensemble dont les objets vont être transférés.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal>ORIGIN = ival</literal></term>
      <listitem><para>N&oelig;ud d'origine actuel des deux ensembles.</para></listitem>
     </varlistentry>
    </variablelist>
    
       <para>Cette commande utilise &funmergeset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     # Supposons que l'ensemble 1 est répliqué sur les n&oelig;uds 2 et 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>

   <para>La fusion se déroule suivant la configuration sur le n&oelig;ud origine.
   Si une fusion est demandée alors que les abonnements sont toujours
   en cours de traitement, cela peut briser les réplications en cours
   sur les n&oelig;uds abonnés car ils chercheront la configuration de cet
   ensemble alors qu'il vient d'être supprimé. Ne soyez pas trop 
   rapide lorsque vous fusionnez des ensembles.
   </para>

   </refsect1>
   <refsect1> <title>Note de version</title> <para>Cette commande
       fut introduite dans &slony1; 1.0.5. Dans la version 1.2.1, 
       une condition de concurrence («&nbsp;race condition&nbsp;») a été corrigée.
       Elle apparaissait lorsque la requête de fusion était soumise
       alors que les demande d'abonnement étaient traitées.
       Cela empêche les fusions avant que les abonnements ne soient 
       complètement réalisés.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddtable"><refmeta><refentrytitle>SET ADD TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD TABLE</refname>
    
    <refpurpose>Ajoute une table dans un ensemble de réplication &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Ajoute une table existante dans un ensemble de réplication. L'ensemble ne doit 
    pas être répliqué sur un autre n&oelig;ud, cette fonctionnalité est assurée par la commande 
    <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal>SET ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble dans lequel la table doit être ajoutée.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>N&oelig;ud origine de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>

       <listitem><para>Identifiant unique de la table. Ces identifiants ne sont 
       pas seulement utilisés pour désigner une table dans l'ensemble de réplication.
       Cette valeur numérique détermine également l'ordre de verrouillage des tables,
       notamment lors de la commande <xref linkend="stmtlockset"/>.
       Cet identifiant doit donc suivre une certaine hiérarchie afin que les scripts
       <application>slonik</application> ne provoquent de situation d'inter-blocage («&nbsp;deadlocks&nbsp;»).
       </para>

         <para>Cet identifiant doit être unique pour tous les ensembles de réplication&nbsp;;
	 vous ne devez pas avoir deux tables du même cluster avec le même identifiant.
	  </para></listitem>
      </varlistentry>
      <varlistentry><term><literal>FULLY QUALIFIED NAME = 'string'</literal></term>
       <listitem><para>Le nom complet de la table tel que décrit dans
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>KEY = { 'string' | SERIAL }</literal></term> <listitem><para>
	 <emphasis>(Facultatif)</emphasis> Le nom de l'index relatif à la colonne unique et 
	 NOT NULL qui est utilisée comme identifiant de ligne lors de la réplication.
	 Si le mot-clef SERIAL est utilisé, cela indique qu'il faut utiliser la colonne 
	 spéciale ajoutée avec la commande <xref linkend="stmttableaddkey"/>.
	 Par défaut, on utilise la clef primaire de la table. Le nom de l'index n'est 
	 <emphasis>pas</emphasis> un nom complet&nbsp;; vous devez omettre le schéma.</para></listitem>

      </varlistentry>
      <varlistentry><term><literal>COMMENT = 'string'</literal></term>
       <listitem><para>Un texte décrivant la table.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &funsetaddtable;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET ADD TABLE (
    SET ID = 1,
    ORIGIN = 1,
    ID = 20,
    FULLY QUALIFIED NAME = 'public.tracker_ticket',
    COMMENT = 'Ticket de Support'
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Messages d'erreur</title>

    <para>Voici quelque messages d'erreurs que vous rencontrerez en cas d'utilisation incorrecte&nbsp;:</para>

   <variablelist>    
       <varlistentry><term><literal>Slony-I: setAddTable_int: table public.ma_table PK column id nullable</literal></term>

        <listitem><para>Les clefs primaires (ou les clefs candidates) doivent être composées 
	de colonnes <command>NOT NULL</command>. Si vous avez une clef primaire candidate dont une
	colonne n'est pas déclarée ainsi, alors &slony1; rejettera la table et produira ce message.</para> 
	</listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int: table id 14 has already been assigned!</literal></term>

        <listitem><para>L'identifiant de la table, stocké dans 
        <envar>sl_table.tab_id</envar>, doit être unique pour tous les n&oelig;uds/tables/ensembles.
	Ce message indique que vous avez tenté de déclarer un identifiant qui est déjà utilisé.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): table public.ma_table has no index mt_idx_14</literal></term>

        <listitem><para>Ceci se produit en général avec les clefs primaires candidates&nbsp;;
	le message indique que l'index spécifié n'est pas disponible sur ce n&oelig;ud.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): table public.ma_table not found</literal></term>

        <listitem><para>Pire que l'absence d'un index, c'est la table qui est manquante.
	Le message indique que le processus que vous avez utilisé pour mettre en place le schéma n'a pas
	fonctionné correctement.</para>
        </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): public.ma_vue is not a regular table</literal></term>

        <listitem><para>Vous ne pouvez répliquer que des tables (en tout cas avec 
        <command>SET ADD TABLE</command>). Cela n'inclut pas les vues et les index
	(les index sont répliqués de facto, mais on peut pas demander explicitement la réplication d'un index).
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): set 4 not found</literal></term>

        <listitem><para>Vous devez défini l'ensemble de réplication avant de lui assigner des tables.
        </para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable(): set 4 has remote origin</literal></term>

        <listitem><para>Ceci se produit lorsque l'ensemble de réplication #4 est configuré
	sur une origine, le n&oelig;ud 1, et que vous lancez une commande <command>SET ADD
        TABLE</command> qui spécifie un autre n&oelig;ud que le n&oelig;ud 1. Ceci se produit généralement
	lorsque la configuration <command>admin conninfo</command> est confuse à l'intérieur du
	préambule du script slonik...</para>
        </listitem>
        </varlistentry>

       <varlistentry><term><literal>Slony-I: cannot add table to currently subscribed set 1</literal></term>

        <listitem><para>&slony1; ne peut pas ajouter des tables dans un ensemble qui est 
	en cours de réplication. Pour contourner ce problème, vous devez définir un nouvel ensemble
	qui contiendra les nouvelles tables.</para> </listitem> </varlistentry>

   </variablelist>    

   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Sur le n&oelig;ud origine, cette opération demande un verrou exclusif très bref sur la table
    afin de lui ajouter les triggers de réplication. Sur les n&oelig;uds abonnés, les verrous 
    correspondant sont réalisés au moment de l'événement <command>SUBSCRIBE_SET</command>.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddsequence"><refmeta><refentrytitle>SET ADD SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD SEQUENCE</refname>
    
    <refpurpose>Ajoute une séquence dans un ensemble de réplication</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
<refsect1>
    <title>Description</title>
    
    <para>
     Ajoute une séquence existante dans un ensemble de réplication. L'ensemble ne 
     doit pas être répliqué sur un autre n&oelig;ud. Cette fonctionnalité est supportée 
     par la commande <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal>SET ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble dans lequel on ajoute la séquence.
	</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>N&oelig;ud d'origine de l'ensemble. Les prochaines version de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>
       
       <listitem><para>Identifiant unique de la séquence.
        <note><para> Notons
	   que cet identifiant doit être unique parmi <emphasis>toutes les séquences</emphasis>
	   du cluster&nbsp;; la numérotation des tables est indépendante, donc il est possible 
	   de donner l'identifiant 20 à une table et à une séquence, sans que cela ne crée de confusion.
	   </para> </note></para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>FULLY QUALIFIED NAME = 'string'</literal></term>
       <listitem><para>Le nom complet de la séquence telle que décrit dans 
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>COMMENT = 'string'</literal></term>
       <listitem><para>Un texte décrivant la séquence.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise la fonction &funsetaddsequence;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET ADD SEQUENCE (
     SET ID = 1,
     ORIGIN = 1,
     ID = 20,
     FULLY QUALIFIED NAME = 'public.tracker_ticket_id_seq',
     COMMENT = 'Séquence d'identifiants des tickets de support'
     );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdroptable"><refmeta><refentrytitle>SET DROP TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP TABLE</refname>
    
    <refpurpose>Supprime une table d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une table d'un ensemble de réplication.
    </para>
    <para>
     Notez que cette action ne supprimera <emphasis>pas</emphasis> une clef primaire
     candidate créée avec la commande <xref linkend="stmttableaddkey"/>.
     
     <variablelist>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>N&oelig;ud d'origine de l'ensemble de réplication.
         Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>
       
  <listitem><para>Identifiant unique de la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise la fonction &funsetdroptable;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET DROP TABLE (
     ORIGIN = 1,
     ID = 20
     );
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette opération pose un verrou exclusif sur la table qui est supprimée afin 
    de retirer les triggers de réplication. Sur les n&oelig;uds abonnées, cela implique également
    le rétablissement des règles et des triggers qui ont été désactivés.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.5.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdropsequence"><refmeta><refentrytitle>SET DROP SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP SEQUENCE</refname>
    
    <refpurpose>Supprime une séquence d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une séquence existante dans un ensemble de réplication.
     <variablelist>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>N&oelig;ud d'origine de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>
       
       <listitem><para>Identifiant unique de la séquence.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise la fonction &funsetdropsequence;.</para>
   </refsect1>
<refsect1><title>Exemple</title>
    <programlisting>
     SET DROP SEQUENCE (
     ORIGIN = 1,
     ID = 20,
     );
</programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.5.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  
  <refentry id="stmtsetmovetable"><refmeta><refentrytitle>SET MOVE
     TABLE</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE TABLE</refname>

    <refpurpose>Déplace une table d'un ensemble de réplication vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Change l'ensemble de réplication dans lequel se trouve la table. L'ensemble courant et le 
     nouveau doivent avoir le même n&oelig;ud origine et les même n&oelig;uds abonnés.
     
     <caution><para>La méthode d'abonnement d'un nouvel ensemble de réplication est 
		     particulière.Vous devez vous assurer que l'abonnement est complètement effectué sur tous les n&oelig;uds
     avant de déplacer les tables. Déplacer une table trop tôt vers un nouvel ensemble
     implique que le n&oelig;ud abonné va essayer d'ajouter la table pendant le processus d'abonnement
     de l'ensemble de réplication, ce qui échoue suite à une erreur de clef dupliquée et provoque 
     l'arrêt de la réplication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>Origine actuelle de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>

       <listitem><para>Identifiant unique de la table.</para></listitem></varlistentry>
      <varlistentry><term><literal>NEW SET = ival</literal></term>
       
  <listitem><para>Identifiant unique de l'ensemble dans lequel il faut ajouter la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise la fonction &funsetmovetable;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE TABLE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.5.</para>
   </refsect1>
</refentry>
  

<!-- **************************************** -->

  <refentry id="stmtsetmovesequence"><refmeta><refentrytitle>SET MOVE SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE SEQUENCE</refname>
    
    <refpurpose>Déplace une séquence d'un ensemble de réplication &slony1; vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para>
	Change l'ensemble de réplication dans lequel se trouve la séquence.
	L'ensemble courant et le nouveau doivent avoir le même n&oelig;ud d'origine
	et les mêmes n&oelig;uds abonnés.
	
     <caution><para>La méthode d'abonnement à un nouvel ensemble est particulière.
	Vous devez vous assurer que l'abonnement est complètement effectué
	avant de déplacer les séquences. Déplacer une séquence top tôt peut impliquer
	une tentative d'ajout de la séquence pendant le processus d'abonnement,
	ce qui échouera en émettant une erreur à cause d'une clef dupliquée et
	provoquera l'arrêt de la réplication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       <listitem><para>N&oelig;ud d'origine de l'ensemble de réplication. Les
	futures versions de <application>slonik</application> devraient
	deviner toutes seules cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal>ID = ival</literal></term>
       
       <listitem><para>Identifiant unique de la séquence.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>NEW SET = ival</literal></term>
       
       <listitem><para>Identifiant unique de l'ensemble de réplication dans lequel
	la séquence doit être déplacée.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &funsetmovesequence;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE SEQUENCE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.5.</para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtstoretrigger"><refmeta><refentrytitle>STORE TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>STORE TRIGGER</refname>
    
    <refpurpose>Indique qu'un trigger ne doit pas être désactivé par &slony1; 
sur un n&oelig;ud abonné.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Par défaut, tous les triggers définis par l'utilisateur sont
désactivés sur tout les n&oelig;uds abonnés lorsque la table est répliquée.
Cette commande peut être utilisée pour empêcher explicitement la désactivation
d'un trigger.
     <variablelist>
      <varlistentry><term><literal>TABLE ID = ival</literal></term>
       <listitem><para> L'identifiant numérique et unique de la table concernée par le trigger.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>TRIGGER NAME = 'string'</literal></term>
       
       <listitem><para>Le nom du trigger tel qu'on le trouve dans le catalogue système
	 <envar>pg_trigger</envar>.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>EVENT NODE = ival</literal></term>
       
       <listitem><para>(Optionnel) L'identifiant du n&oelig;ud utilisé pour 
créer l'événement de configuration qui annonce aux n&oelig;uds existants la
présence d'un trigger spécial. Par défaut, cette valeur est 1.
	 </para></listitem>

      </varlistentry>
     </variablelist>
    </para>
    <note><para>Une astuce consiste à lancer <command>STORE
    TRIGGER</command> <emphasis>avant que le trigger ne soit installé
    </emphasis>, ce qui ne provoquera pas d'erreurs. Vous pouvez
    ainsi définir la gestion d'un trigger par &slony1;
    <emphasis>avant</emphasis> qu'il ne soit installé. Vous êtes alors
    certain que le trigger est actif sur tous les n&oelig;uds immédiatement
    après son installation via <xref linkend="stmtddlscript"/>&nbsp;; il n'y a 
    aucun risque de voir un événement passer entre les événements
    <command>EXECUTE SCRIPT</command> et <command>STORE TRIGGER</command>.
    </para>
    </note>    
    <para>Cette commande utilise &funstoretrigger;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
STORE TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette opération pose brièvement un verrou exclusif sur la table spécifiée
sur chaque n&oelig;ud auquel elle s'applique, afin de modifier le schéma de la table
et y ajouter de nouveau le trigger.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>

    <para>Avec &slony1; version 2.0, cette commande est supprimée car
obsolète. En effet, les triggers ne sont plus <quote>trafiqués</quote> 
dans le catalogue système.</para>    
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroptrigger"><refmeta><refentrytitle>DROP TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP TRIGGER</refname>
    
    <refpurpose>Cette commande redonne à un trigger son comportement par défaut&nbsp;:
c'est-à-dire qu'il ne se déclenche pas sur les n&oelig;uds abonnés.</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
  <para>Supprime la gestion particulière du trigger spécifié.
    <variablelist>
      <varlistentry>
        <term><literal>TABLE ID = ival</literal></term>
        <listitem>
          <para>L'identifiant numérique et unique de la table pour laquelle le 
          trigger est défini.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>TRIGGER NAME = 'string'</literal></term>
        <listitem><para>Le nom du trigger tel qu'on le trouve dans le catalogue système
          <envar>pg_trigger</envar>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>EVENT NODE = ival</literal></term>
        <listitem>
          <para>(Optionnel) L'identifiant du n&oelig;ud utilisé pour
          créer l'événement de configuration qui annonce aux n&oelig;uds existants la
          présence d'un trigger spécial. Par défaut, cette valeur est 1.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>
    <para>Cette commande utilise  &fundroptrigger;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
DROP TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette opération pose brièvement  un verrou exclusif sur la table spécifiée
sur chaque n&oelig;ud auquel elle s'applique, afin de modifier le schéma de la table
et y ajouter de nouveau le trigger.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>

    <para>Avec &slony1; version 2.0, cette commande est supprimée car
obsolète. En effet, les triggers ne sont plus <quote>trafiqués</quote>
dans le catalogue système.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtsubscribeset"><refmeta><refentrytitle>SUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SUBSCRIBE SET</refname>
    
    <refpurpose>Lance la réplication d'un ensemble donné</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande réalise une des deux opérations suivantes&nbsp;:</para>

    <itemizedlist>
 
    <listitem><para>Initie la réplication pour un ensemble de réplication.</para>
    <para>Ceci déclenche la réplication sur un n&oelig;ud (abonné) soit à partir
de l'origine soit à partir du fournisseur, qui doit être lui-même un n&oelig;ud
abonné actif et transmetteur («&nbsp;forwarding subscriber&nbsp;»).</para>
    
    <para>Les tables de l'application contenues dans l'ensemble de réplication 
doivent déjà exister et, idéalement, elles sont vides. La version courante de 
&slony1; ne tente <emphasis>pas</emphasis> de copier le schéma de l'ensemble 
de réplication. Le démon de réplication démarre et commence à copier le contenu 
de l'ensemble de réplication à partir du fournisseur spécifié, puis essaie
de rattraper son retard en rejouant les mises à jour qui se sont produites
lors du processus de copie. Un fois que l'abonnement a réussi, les tables 
sont protégées avec des triggers contre les mises à jour en provenance de 
l'application.
    </para>
    
    <para>Si les tables sur l'abonné ne sont 
    <emphasis>pas</emphasis> vides, alors l'événement <command>COPY
    SET</command> (qui fait partie du processus d'abonnement)
    devra effectuer quelques taches supplémentaires&nbsp;:</para>
     <itemizedlist>

      <listitem><para>Il tente d'effectuer une <command>TRUNCATE</command>
     sur la table, ce qui devrait être efficace.</para> </listitem>
      
      <listitem><para>Si cela ne fonctionne pas (une relation sur une 
clef étrangère empêche peut-être le fonctionnement de TRUNCATE), il 
utilise la commande <command>DELETE</command> pour effacer toutes les 
<quote>anciennes</quote>
entrées de la table.</para></listitem>

      <listitem><para>Ces anciennes données encombrent encore l'espace
disque jusqu'à ce qu'un <command>VACUUM</command> soit effectué <emphasis>après</emphasis>
la fin du processus d'abonnement.</para></listitem>
      
      <listitem><para>Les index de la table contiendront des références
aux anciennes données, ce qui ralentira l'insertion de nouvelles données
dans les index.</para></listitem>
     </itemizedlist>

     <warning><para>Le temps d'exécution de cette opération n'est pas 
négligeable. Si vous avez un grand volume de données dans un ensemble 
particulier de tables, cela peut prendre plusieurs heures, voire plusieurs
jours pour que l'opération aboutisse (ici <quote>un grand volume</quote>
signifie <quote>des dizaines ou des centaines de gigaoctets de données</quote>).</para>

     <para>Cependant, la requête <command>SUBSCRIBE SET</command> se terminera
presque immédiatement, même si les travaux, gérés par l'événement
<command>COPY SET</command>, sont encore en cours. Si vous devez configurer
les abonnements sur des n&oelig;uds en cascade, vous devez attendre que chaque
abonné ait terminé son abonnement avant de soumettre des requête d'abonnement
qui utilisent ce n&oelig;ud comme fournisseur. Si vous ne le faites pas, ce n'est pas
très grave&nbsp;: <command>slonik</command> va vérifier le n&oelig;ud, découvrir qu'il 
n'est pas encore un fournisseur actif et reporter l'erreur suivante&nbsp;:
</para>

<programlisting>
 Slony-I: provider 2 is not an active forwarding node for replication set 1
</programlisting>

     <para>En pratique, de telles requêtes d'abonnement seront ignorées
jusqu'à ce que le fournisseur soit prêt.</para>
</warning>

     </listitem>

     <listitem><para>Modifier les informations d'abonnement pour les 
n&oelig;uds qui sont déjà abonnés.</para>

     <para>Si vous devez modifier les informations d'abonnement pour un 
n&oelig;ud donné, vous devez <emphasis>également</emphasis> soumettre les 
nouvelles informations avec cette commande, et la nouvelle configuration sera
propagée à travers le réseau de réplication. En général, on modifie
les informations d'abonnement lorsqu'on veut abonner un n&oelig;ud à un fournisseur
<emphasis>différent</emphasis> ou transformer un n&oelig;ud en <quote>transmetteur</quote>
afin qu'il puisse à son tour devenir le fournisseur d'un autre abonné.
</para>

     </listitem>
     </itemizedlist>

     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble auquel on s'abonne</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>PROVIDER = ival</literal></term>
       
       <listitem><para>Identifiant du n&oelig;ud fournisseur qui transmet les données
à ce n&oelig;ud</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>RECEIVER = ival</literal></term>
       
       <listitem><para>Identifiant du nouveau n&oelig;ud abonné</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>FORWARD = boolean</literal></term>
       
       <listitem><para>Indique si le nouvel abonné doit stocker les logs
pendant la réplication afin de pouvoir devenir fournisseur pour de futurs 
n&oelig;uds.</para></listitem>

      </varlistentry>
     </variablelist>
    <para>Cette commande utilise &funsubscribeset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SUBSCRIBE SET (
   ID = 1,
   PROVIDER = 1,
   RECEIVER = 3,
   FORWARD = YES
);
    </programlisting>
   </refsect1>

   <refsect1> <title>Transmission</title>

    <para>Le paramètre <command>FORWARD=boolean</command> indique si le
l'abonné doit conserver les informations dans les tables &sllog1; et &sllog2;.
Ceci implique plusieurs choses...</para>

    <para>Stocker les données dans ces tables sur l'abonné représente
une charge supplémentaire. Si vous êtes certain(e) que vous n'effectuerez 
jamais les opérations <xref linkend="stmtmoveset"/> ou <xref
linkend="stmtfailover"/> sur un abonné particulier, il vaut mieux 
désactiver la transmission sur ce n&oelig;ud.</para>

    <para>Cela étant dit, dans certains cas, le fait de désactiver cette option
peut poser des problèmes lorsqu'on se trouve dans une situation inattendue.
De manière empirique, on considère qu'il est préférable que <emphasis>tout 
n&oelig;ud connecté directement à l'origine</emphasis> soit 
un <quote>n&oelig;ud transmetteur </quote>. Il est possible que ce n&oelig;ud
soit perdu lors d'une bascule d'urgence. Le problème survient lorsque
ce n&oelig;ud est en avance sur les autres n&oelig;uds.</para>

    <para>Supposons que l'origine, le n&oelig;ud 1, est au numéro de SYNC
88901, un n&oelig;ud non-transmetteur, le n&oelig;ud 2 en est arrivé au numéro
88897, tandis que les autres n&oelig;uds transmetteur, 3, 4, et 5, en sont
seulement au SYNC numéro  88895. À ce moment, le disque système sur le
n&oelig;ud origine prend feu. Le n&oelig;ud 2 possède les <emphasis>données</emphasis> à jour 
jusqu'à 88901, mais aucun n&oelig;ud transmetteur ne dispose, dans les tables
&sllog1; ou &sllog2;, des données correspondant
aux événements SYNCs numérotés 88896 et 88897. Il n'y a donc 
aucun moyen de ramener les n&oelig;uds 3-5 à ce niveau.</para>

    <para>À ce stade, vous avez deux choix&nbsp;: supprimer le n&oelig;ud2 car il
n'existe aucun moyen de le maintenir, ou supprimer tous les n&oelig;uds 
<emphasis>sauf</emphasis> le n&oelig;ud 2, car il n'existe aucun moyen de les 
amener jusqu'à l'événement SYNC 88897.</para>

    <para>Ce dilemme peut être évité en s'assurant que tous les n&oelig;uds directement 
abonnés à l'origine sont des transmetteurs.</para>

   </refsect1>
   <refsect1> <title>Comportement dangereux et non-intuitif</title>

   <itemizedlist>

     <listitem><para>Le fait que la requête se termine immédiatement
même si l'abonnement prend un temps considérable est parfois surprenant.
 </para> 

     <para>Le traitement des abonnements implique 
     <emphasis>deux</emphasis> événements&nbsp;; l'opération
     <command>SUBSCRIBE_SET</command>, initié sur le n&oelig;ud fournisseur,
et une opération <command>ENABLE_SUBSCRIPTION</command>, qui est 
initiée sur le n&oelig;ud abonné. Cela signifie que <xref
     linkend="stmtwaitevent"/> ne peut pas attendre la fin d'une souscription.
Si vous souhaitez attendre la fin d'un abonnement, alors vous devez soumettre une
requête <xref linkend="stmtsync"/> et attendre que <emphasis>cet</emphasis> événement
s'achève.</para>
     </listitem>

     <listitem><para> Cette commande a <emphasis>deux</emphasis>
objectifs&nbsp;: mettre en place des abonnements (ce qui n'est très surprenant)
et <emphasis>modifier des abonnements</emphasis>, ce qui n'est pas forcément
intuitif.</para> </listitem>

 <listitem><para>Les nouveaux abonnements sont définis en utilisant 
<command>DELETE</command> ou <command>TRUNCATE</command> pour vider
les tables sur l'abonné. Si vous avez créé un nouveau n&oelig;ud en 
recopiant les données à partir d'un n&oelig;ud existant, il peut <quote>paraître
évident</quote> que ces données seront conservées. Ce n'est pas le cas,
l'ancien contenu est détruit et le n&oelig;ud est re-peupler <emphasis>à partir
de zéro</emphasis>.</para> </listitem>

   </itemizedlist>

   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Cette opération ne nécessite <emphasis>pas</emphasis> de verrous
sur le n&oelig;ud fournisseur.</para>

    <para>Sur le n&oelig;ud abonné, l'opération placera un verrou
sur toutes les table de l'ensemble de réplication. Dans la version
1.2, les verrous exclusifs sont placés au début du processus&nbsp;; dans les
versions antérieures, les verrous sont placés implicitement uniquement lorsque
qu'une activité le demande, ce qui laisse une possibilité d'inter-blocage
(«&nbsp;deadlock&nbsp;») si d'autres applications peuvent accéder à la base à ce moment-là.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtunsubscribeset"><refmeta><refentrytitle>UNSUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNSUBSCRIBE SET</refname>

    <refpurpose>Arrête la réplication d'un ensemble de réplication &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNSUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para>Cette commande interrompt la réplication d'un ensemble sur un abonné.
Les tables sont alors ouvertes en accès total aux applications clientes sur l'ancien
abonné. Les tables ne sont ni détruites ni modifiées. Tous les triggers originaux, les règles
et les contraintes sont restaurées.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble à désabonner</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>RECEIVER = ival</literal></term>
       
       <listitem><para>Identifiant du n&oelig;ud de l' (ancien) abonné</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &fununsubscribeset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNSUBSCRIBE SET (
   ID = 1,
   RECEIVER = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Des verrous exclusifs sont posés sur chaque table répliquée
de l'abonné afin de supprimer les triggers de réplication et de restaurer 
les anciens triggers/règles.</para>
   </refsect1>

   <refsect1><title>Comportement dangereux et non-intuitif</title>

     <para>Ré-abonner un ensemble désabonné nécessite une 
     <emphasis>copie fraîche et complète</emphasis> des données obtenue à partir
du n&oelig;ud fournisseur car les tables ont pu être soumises à des modifications
indépendantes.</para>

   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

  
<!-- **************************************** -->

  <refentry id ="stmtlockset"><refmeta><refentrytitle>LOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>LOCK SET</refname>
    
    <refpurpose>Protège un ensemble de réplication &slony1; pour le 
préparer à un <command>MOVE SET</command></refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>LOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande protège un ensemble de réplication des mises à 
jour en provenance des applications clientes, en préparation d'une 
commande <xref linkend="stmtmoveset"/>.
    </para>

    <para>Cette commande doit être la première dans un groupe de commande <command>try</command>.
En effet, il faut <quote>committer</quote> les changements faits sur les tables
 (ajout d'une fonction trigger spéciale) avant d'attendre que toutes les 
transactions concurrentes se termine. En même temps, il ne faut pas
non plus garder une transaction ouverte sur la base elle-même car cela
cela signifierait qu'elle se bloque elle-même.
    </para>

    <para>Notons qu'il s'agit d'une opération &rlocking;, ce qui signifie qu'elle peut être
bloqué derrière d'autres activités de la base.</para>

    <para>L'opération attend que les identifiants de transaction avancent
afin qu'aucune donnée ne soit oubliée sur la nouvelle origine. Ainsi,
si vous avez des transactions très longues en cours sur le n&oelig;ud source, 
cette opération attendra que ces transactions aboutissent.
Malheureusement, si vous avez une autre base de données sur le même 
    postmaster du n&oelig;ud origine, les transactions longues en cours
sur cette base seront aussi prises en compte même si elles sont par définition
indépendantes.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble à bloquer</para></listitem>
	 
      </varlistentry>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       
       <listitem><para>Identifiant du n&oelig;ud de l'ensemble d'origine</para></listitem>
	 
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &funlockset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Des verrous exclusifs sont posés sur chaque table répliquée sur le n&oelig;ud origine
    et des triggers qui rejettent les mises à jour sont ajoutés su chacune de ces tables.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtunlockset"><refmeta><refentrytitle>UNLOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNLOCK SET</refname>
    
    <refpurpose>Déverrouille un ensemble &slony1; qui est bloqué</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNLOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> 
     Cette commande déverrouille un ensemble préalablement verrouillé.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble à déverrouiller</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>ORIGIN = ival</literal></term>
       
       <listitem><para>Identifiant du n&oelig;ud origine de l'ensemble</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &fununlockset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNLOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Des verrous exclusifs sont placés sur chaque table répliquée sur le n&oelig;ud origine
    car les triggers qui rejetent les mises à jour sont retirés de chacune des tables.
     </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtmoveset"><refmeta><refentrytitle>MOVE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MOVE SET</refname>
    
    <refpurpose>Change l'origine d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MOVE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande déplace l'origine d'un ensemble de réplication d'un n&oelig;ud
    vers un autre. La nouvelle origine doit être un abonné de cet ensemble. L'ensemble
    doit être verrouillé sur l'ancien n&oelig;ud origine.
    </para>
    
    <para>Après cette commande, l'ensemble ne peut plus être déverrouillé sur 
    l'ancienne origine. Celle-ci va continuer comme un n&oelig;ud transmetteur
    de l'ensemble et la chaîne d'abonnement entre l'ancienne et la nouvelle origine
    sera inversée. Dès que la nouvelle origine a terminé le traitement de l'événement
    (ce qui inclue tous les événements SYNC qui se sont produit avant la commande),
    elle prend le contrôle et ouvre toutes les tables de l'ensemble de réplication 
    aux mises à jour en provenance de l'application.
    </para>

    <para>Ceci n'est <emphasis>pas</emphasis> une bascule d'urgence car cela nécessite
    que l'ancienne origine fonctionne correctement (vous devez verrouiller l'ensemble 
    de réplication sur l'ancienne origine). Il est préférable d'utiliser 
    <command>MOVE SET</command> au lieu de <command>FAILOVER</command> si c'est possible
    car la commande <command>FAILOVER</command> transforme le n&oelig;ud origine en un 
    n&oelig;ud corrompu. Avant d'effectuer un <command>MOVE SET</command>, il faut lancer la 
    commande <command>LOCK SET</command>.
</para>
     
    <para>Notez qu'il s'agit d'une opération &rlocking;, ce qui signifie qu'elle peut être bloquée
    derrière l'activité des autres bases.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       <listitem><para>Identifiant de l'ensemble à transférer</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>OLD ORIGIN = ival</literal></term>
       
       <listitem><para>Identifiant du n&oelig;ud origine actuel</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>NEW ORIGIN = ival</literal></term>
       
  <listitem><para>Identifiant du futur n&oelig;ud origine</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para>Cette commande utilise &funmoveset;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 1
);
MOVE SET (
   ID = 1,
   OLD ORIGIN = 1,
   NEW ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Des verrous exclusifs sont posés sur chaque table répliquée,
à la fois sur l'ancien n&oelig;ud origine et le nouveau n&oelig;ud origine, car 
les triggers de réplication sont changés sur les deux n&oelig;uds&nbsp;:
sur l'ancienne origine, chaque table supprime deux triggers 
(logtrigger et lockset) et ajoute un trigger denyaccess&nbsp;;
sur la nouvelle origine, le trigger denyaccess est supprimé et
le trigger logtrigger est ajouté.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtfailover"><refmeta><refentrytitle>FAILOVER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>FAILOVER</refname>
    
    <refpurpose>Cette commande bascule un ensemble de réplication 
en échec vers un n&oelig;ud de secours.
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>FAILOVER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     La commande <command>FAILOVER</command> transfert tous les ensembles dont
l'origine est en panne vers le n&oelig;ud de secours.
     <application>slonik</application> va contacter tous les autres n&oelig;uds directement
abonnés au n&oelig;ud en panne pour déterminer le n&oelig;ud qui a le meilleur niveau de synchronisation
pour chacun des ensembles de réplication. Si un autre n&oelig;ud a un niveau de synchronisation
plus élevé que le n&oelig;ud de secours, la réplication sera d'abord redirigée pour que le n&oelig;ud
de secours rattrape son retard sur l'autre n&oelig;ud, puis pour qu'il assume le rôle d'origine
et reçoive les mises à jour.
    </para>

    <para>
     Après une bascule d'urgence réussie, tous les anciens n&oelig;uds abonnés directement 
au n&oelig;ud en panne deviennent des abonnés direct du n&oelig;ud de secours.
Le n&oelig;ud en panne est abandonné et doit être retiré de la configuration avec 
<xref linkend="stmtdropnode"/>.
    </para>
    
    <variablelist>
     <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para>Identifiant du n&oelig;ud en panne</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal>BACKUP NODE = ival</literal></term>
      
      <listitem><para>Identifiant du n&oelig;ud de secours qui va prendre en charge
les ensembles de réplication dont l'origine est le n&oelig;ud en panne</para></listitem>

     </varlistentry>
    </variablelist>
    
    <para>Cette commande utilise &funfailednode;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
FAILOVER (
   ID = 1,
   BACKUP NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Des verrous exclusifs sont posés sur chaque table répliquée sur
le nouveau n&oelig;ud origine car les triggers de réplication sont changés.
Si la nouvelle origine n'est pas tout à fait à jour et que des données 
doivent être rapatriées depuis à partir d'un autre n&oelig;ud qui est mieux synchronisé,
alors la nouvelle origine ne sera pas utilisable avant que ces mises à jour
soient terminées.
     </para>
   </refsect1>
   <refsect1><title>Comportement dangereux et non-intuitif</title>
    <para>Cette commande va abandonner le n&oelig;ud en panne.
Il n'y a pas de possibilité de réintégrer le n&oelig;ud en panne
sans le reconstruire à partir de zéro en tant qu'esclave.
Si c'est possible, il est préférable d'utiliser la commande
     <xref linkend="stmtmoveset"/> car elle n'abandonne
    <emphasis>pas</emphasis> le n&oelig;ud en panne.
    </para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtddlscript"><refmeta><refentrytitle>EXECUTE SCRIPT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXECUTE SCRIPT</refname>
    
    <refpurpose>Exécute un script SQL/DDL</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>EXECUTE SCRIPT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
      <title>Description</title>
      <para>Cette commande exécute un script contenant des ordres SQL sur
      tous les n&oelig;uds qui sont abonnés à un ensemble de réplication à un 
      point précis dans le flux des transactions.</para>
 
    <para>L'origine de l'événement doit être l'origine de l'ensemble
de réplication. Le fichier de script ne doit pas contenir d'ordres 
<command>START</command> ou <command>COMMIT TRANSACTION</command>.
  (Ceci change un peu avec &postgres; 8.0 puisque les transactions imbriquées,
appelée également <quote>points de sauvegarde</quote> (<quote>
    savepoints</quote>), sont supportés.
De plus, les ordres DML non déterministes (par exemple mettre à jour un 
champ avec la valeur <function>CURRENT_TIMESTAMP</function>) doivent
être évitées car les changements effectués par ce script ne sont pas
explicitement répliqués.</para>

    <variablelist>
     <varlistentry><term><literal>SET ID = ival</literal></term>

      <listitem><para>Le numéro unique de l'ensemble affecté par le script</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal>FILENAME = '/chemin/vers/le/fichier'</literal></term>
      
      <listitem><para>Le nom du fichier contenant le script SQL à exécuter.
Il peut s'agir d'un chemin relatif à l'emplacement de l'instance <application>slonik</application>
que vous avez lancé ou, de préférence, un chemin absolu sur le système où 
 <application>slonik</application> est lancé.</para>
       
       <para>Le <emphasis>contenu</emphasis> de ce fichier est propagé dans un
événement, donc il n'est pas nécessaire que le fichier soit accessible depuis
les autres n&oelig;uds.
	</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal>EVENT NODE = ival</literal></term>
      <listitem><para>(Optionnel) L'identifiant de l'origine courante de l'ensemble. La valeur par défaut est 1.</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal>EXECUTE ONLY ON = ival</literal></term>
     <listitem><para>(Optionnel) L'identifiant du seul n&oelig;ud qui
doit exécuter le script. Cette option implique que le script sera propagé
sur tous les n&oelig;uds mais exécuté sur un seul.
Par défaut, on exécute le script sur tous les n&oelig;uds abonnés à l'ensemble de réplication.
	</para></listitem> 
      
     </varlistentry>
    </variablelist>
    
    <para>Voir également les avertissements dans la section &rddlchanges;.</para>

    <para>Notons qu'il s'agit d'une opération &rlocking;, ce qui signifie qu'elle peut être
bloquée par l'activité d'une autre base.</para>
     
    <para>Au démarrage de cet événement, toutes les tables répliquées sont
déverrouillées par la fonction <function>alterTableRestore(tab_id)</function>. 
Une fois le script SQL exécuté, elles sont remises en <quote>mode réplication
</quote> avec <function>alterTableForReplication(tab_id)</function>.  
Cela implique que toutes les tables sont verrouillées par ce processus 
&slon; pendant la durée du script SQL.</para>

    <para>Si les colonnes d'une table sont modifiées, il est très
important que les triggers soient régénérés, sinon ils peuvent 
être inadaptés à la nouvelle forme du schéma.
    </para>

    <para>Notez que si vous devez faire référence au nom du cluster,
vous pouvez utiliser l'alias <command>@CLUSTERNAME@</command>&nbsp;;
si vous devez faire référence au schéma &slony1;,
vous pouvez utiliser l'alias <command>@NAMESPACE@</command>&nbsp;;
les deux seront remplacés par la valeur appropriée. </para>

    <para>Cette commande utilise &funddlscript;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
EXECUTE SCRIPT (
   SET ID = 1,
   FILENAME = '/tmp/changes_2008-04-01.sql',
   EVENT NODE = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Sur les versions antérieures à la  branche 2.0, un verrou exclusif est posé 
sur chaque table répliquée sur le n&oelig;ud origine, afin de retirer les triggers
de réplication. Une fois le script DDL achevé, ces verrous sont enlevés.
     </para>
  
    <para>Une fois le script DDL exécuté sur le n&oelig;ud origine, il est lancé sur les n&oelig;uds
abonnés. Des verrous similaires sont posés sur tous les n&oelig;uds pour altérer 
les triggers des tables répliquées.
    </para>

    <para>À partir de la branche 2.0, &slony1; utilise un GUC qui contrôle
le comportement des triggers, ce qui permet de désactiver les triggers créés par 
&slony1; pendant l'opération <emphasis>sans</emphasis> poser de verrous exclusifs sur
toutes les tables. Désormais, les seules tables qui sont verrouillées sont les tables
qui sont effectivement modifiées par le script DDL.
    </para>  
  
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>

    <para>Avant la version 1.2, l'ensemble du script DDL était soumis 
dans une requête <function>PQexec()</function>, ce qui impliquait que
le script <emphasis>tout entier</emphasis> était traité en se basant sur 
l'état de la base avant l'invocation du script. Cela signifie que 
des ordres placés à la fin d'un script ne pouvaient pas dépendre d'un ordre
situé au début de ce même script. Ainsi, il n'était pas possible
d'ajouter une colonne dans une table, puis une contrainte sur cette 
colonne au sein du même script.
    </para>

    <para>Dans &slony1; version 1.2, le script DDL est découpé ordre par ordre,
et chaque ordre est soumis séparément. Cela implique que les ordres de la fin
du script peuvent se référer aux objets ou aux attributs créés et modifiés au début
du script.
De plus, dans la version 1.2, le résultat de sortie de <command>slonik</command>
contient la liste des ordre au fur et à mesure de leur traitement sur le n&oelig;ud
d'origine de l'ensemble de réplication. De même, les ordres traités sont listés
dans les logs de slon sur les autres n&oelig;uds.
    </para>

    <para>Dans &slony1; version 1.0, cette commande verrouille uniquement les tables
de l'ensemble spécifié. À partir de la version 1.1, <emphasis>toutes
les tables répliquées</emphasis> sont verrouillées (<emphasis>c'est-à-dire</emphasis>
que les triggers sont retirés au départ et restaurés à la fin).
Ceci couvre les risques lorsqu'on lance une requête de changements DDL
sur des tables appartenant à plusieurs ensemble de réplication.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtupdatefunctions"><refmeta><refentrytitle>UPDATE FUNCTIONS</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>UPDATE FUNCTIONS</refname>
    
    <refpurpose>Recharge les procédures stockées</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UPDATE FUNCTIONS (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande recharge les procédures stockées pour un n&oelig;ud.</para>
    
    <para>Elle restaure toutes les procédures stockées et les définitions de fonctions dans 
le schéma &slony1; pour un n&oelig;ud donné. Cette commande fait habituellement partie des
procédure de mise à jour logicielles.
    </para>

     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       
       <listitem><para>Le n&oelig;ud à rafraîchir.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UPDATE FUNCTIONS (
    ID = 3        # Update functions on node 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
   <refsect1> <title>Bizarreries</title>

    <para>Toute incohérence entre <xref linkend="slonik"/> et la bibliothèque C
    <quote>résidant</quote> dans l'installation de &postgres; empêchera le
bon fonctionnement de l'ensemble et provoquera probablement une panne.
Vous pouvez <emphasis>penser</emphasis> que vous mettez à jour avec la version
1.1.5, mais si vous êtes en train d'utiliser la version 1.1.2, ou si vous
n'avez pas redémarré la base avec une version qui a les bibliothèques 1.1.5,
et que vous référencez des procédures stockées en C de la version 1.1.1,
la tentative de mise à jour va échouer car les fonctionss C
sont régulièrement modifiées entre les versions majeures.
    </para>

    <para>Avant &slony1; 1.2, le message d'erreur affiché n'était pas 
très informatif. Ce qu'on trouvait dans les traces de  &postgres; était une
erreur signalant l'impossibilité de charger des procédures stockées implémentées
en C. À partir de la version 1.2, une des premières actions effectuées est 
le chargement d'une procédures stockées pour vérifier les numéros de versions&nbsp;;
Un message bien plus clair est affiché si vous utilisez des versions non 
cohérentes.
     </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtwaitevent"><refmeta><refentrytitle>WAIT FOR EVENT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>WAIT FOR EVENT</refname>
    
    <refpurpose>Demander à un script Slonik d'attendre que l'événement précédent s'achève</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>WAIT FOR EVENT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande attend une confirmation d'événement.</para>
    
    <para><application>Slonik</application> se souvient du dernier événement 
généré sur chaque n&oelig;ud pendant l'exécution d'un script (les événements produits 
lors des appels précédents ne sont pas vérifiés). Dans certaines situations,
il est nécessaire que des événements générés sur un n&oelig;ud (tel que 
 <command>CREATE SET</command>) soient traités sur un autre n&oelig;ud avant de 
lancer d'autres commandes (par exemple <xref linkend="stmtsubscribeset"/>).  
<command>WAIT FOR EVENT</command> peut être utilisé pour demander à un 
script <application>slonik</application> d'attendre jusqu'à ce que le n&oelig;ud abonné
soit prêt pour l'action suivante.
    </para>
    
    <para><command>WAIT FOR EVENT</command> doit être appelée en dehors d'un
bloc <command>try</command> car les nouveaux messages de confirmation ne sont 
pas visibles à l'intérieur d'une transaction.

     <variablelist>
      <varlistentry><term><literal>ORIGIN = ival | ALL</literal></term>
       <listitem><para>L'origine de l'événement qu'il faut attendre.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>CONFIRMED = ival | ALL</literal></term>
       
       <listitem><para>L'identifiant du n&oelig;ud récepteur qui doit confirmer le(s)
événement(s).
</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>WAIT ON = ival</literal></term>
       <listitem><para>L'identifiant du n&oelig;ud où la table  &slconfirm; est vérifiée.
La valeur par défaut est 1.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>TIMEOUT = ival</literal></term>
       
       <listitem><para>Le nombre de secondes d'attente. La valeur par défaut est 600
       (10 minutes). <command>TIMEOUT = 0</command> implique que le script attend 
indéfiniment.</para></listitem>
       
      </varlistentry>
     </variablelist></para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
WAIT FOR EVENT (
  ORIGIN = ALL,
  CONFIRMED = ALL,
  WAIT ON = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.0.</para>
   </refsect1>
   
   <refsect1> <title>Bizarreries</title> 
<para>Tous les événements ne retournent pas forcément des résultats intéressants.
Par exemple, beaucoup de gens ont rencontré énormément de problèmes avec
<xref linkend="stmtsubscribeset"/> lorsqu'ils abonnaient un nouvel ensemble.
Soyez conscient que  la requête <xref linkend="stmtsubscribeset"/> va retourner
la confirmation d'événement presque immédiatement, même s'il reste plusieurs heures 
de travail avant que l'abonnement ne soit achevé. Le problème avec
 avec   <xref linkend="stmtsubscribeset"/> est qu'il est traité par
<emphasis>deux</emphasis> événements, un sur le n&oelig;ud origine et un autre
 qui met en place l'abonnement sur l'abonné.
   </para>

   <para>Afin de surveiller plus étroitement à l'intérieur du script <xref
   linkend="slonik"/> que l'instruction <xref linkend="stmtsubscribeset"/> 
est complète, vous pouvez soumettre un événement <xref linkend="stmtsync"/>
après l'abonnement et lancer une requête WAIT sur ce 
   <command>SYNC</command>, de la manière suivante&nbsp;: </para>
    <programlisting>
     # Supposons que l'ensemble 1 a deux abonnés direct 2 et 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrepairconfig"><refmeta><refentrytitle>REPAIR CONFIG</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>REPAIR CONFIG</refname>
    
    <refpurpose>Remet à zéro les tables de correspondance entre les noms et les OID pour un
ensemble de réplication, utile lorsqu'on restaure un n&oelig;ud après un 
<application>pg_dump</application>.</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>REPAIR CONFIG (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Remet à zéro la correspondance entre noms et OID.</para>
    
     <variablelist>
      <varlistentry><term><literal>SET ID = ival</literal></term>
       <listitem><para>Le numéro de l'ensemble à nettoyer.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>EVENT NODE = ival</literal></term>
       
       <listitem><para>L'identifiant du n&oelig;ud ou la commande doit être soumise.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal>EXECUTE ONLY ON = ival</literal></term>

       <listitem><para>L'identifiant du seul n&oelig;ud où la correspondance est mise à jour.
       Si cette valeur n'est pas précisée, par défaut on exécute la commande sur tous les
       n&oelig;uds abonnés à l'ensemble.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
REPAIR CONFIG (
  SET ID = 1,
  EVENT NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.1.</para>
   </refsect1>
  </refentry>
<!-- **************************************** -->

  <refentry id="stmtsync"><refmeta><refentrytitle>SYNC</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SYNC</refname>
    
    <refpurpose>Cette commande produit un événement SYNC ordinaire.</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SYNC (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>Cette commande génère un événement SYNC sur un n&oelig;ud donné.</para>
    
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
       <listitem><para>Le n&oelig;ud sur lequel on génère l'événement SYNC.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SUBSCRIBE SET (ID = 10, PROVIDER = 1, RECEIVER = 2);
     WAIT FOR EVENT (ORIGIN = 2, CONFIRMED = 1);
     SYNC (ID = 1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2);
    </programlisting>
   </refsect1>
   <refsect1> <title>Utilisation de verrous</title>

    <para>Aucun verrouillage ne devrait être visible depuis l'application.</para>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  
  <refentry id ="stmtsleep"><refmeta><refentrytitle>SLEEP</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SLEEP</refname>
    
    <refpurpose>S'endormir avec la fonction système <function>sleep()</function></refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>sleep </command>
     <arg><replaceable class="parameter"> secondes</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Cette commande endort les opérations pendant un certain nombre de secondes.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     sleep (seconds = 5);
    </programlisting>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1.</para>
   </refsect1>
  </refentry>

  <refentry id ="stmtcloneprepare"><refmeta><refentrytitle>CLONE PREPARE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLONE PREPARE</refname>
    
    <refpurpose>Prépare le clonage d'un n&oelig;ud.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>clone prepare</command>
     <arg><replaceable class="parameter">id</replaceable></arg>
     <arg><replaceable class="parameter">provider</replaceable></arg>
     <arg><replaceable class="parameter">comment</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Cette commande prépare le clonage d'un n&oelig;ud donné.
    </para>

    <para>
     Ceci duplique la configuration d'un n&oelig;ud <quote>fournisseur</quote>
     sous un nouvel identifiant en préparation de la copie de ce n&oelig;ud
     via un outil standard.
    </para>

    <para>Notez que pour être certain que ce nouveau n&oelig;ud est cohérent avec 
tous les n&oelig;uds, il est important de lancer un événement SYNC sur tous les 
n&oelig;uds à l'exception du fournisseur et d'attendre que tous ces événements
SYNC soient confirmés avant de copier la base fournisseur.
Sinon il est possible que le clone ait raté des événements.
     </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     clone prepare (id = 33, provider = 22, comment='Clone 33');
     sync (id=11);
     sync (id=22);
     </programlisting>
   </refsect1>
   <refsect1> <title>Note de version</title>
    <para>Cette commande fut introduite dans &slony1; 1.2.0.</para>
   </refsect1>
  </refentry>
  <refentry id ="stmtclonefinish"><refmeta><refentrytitle>CLONE FINISH</refentrytitle>
    <manvolnum>7</manvolnum></refmeta>
    <refnamediv><refname>CLONE FINISH</refname>
      <refpurpose>Termine le clonage d'un n&oelig;ud.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>clone prepare</command>
        <arg><replaceable class="parameter">id</replaceable></arg>
        <arg><replaceable class="parameter">provider</replaceable></arg>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>Description</title>
      <para>
         Cette commande achève le clonage sur un n&oelig;ud donné.
      </para>
      <para>Ceci complète le travail effectué par <xref linkend="stmtcloneprepare"/> en établissant les données de confirmation
        pour le nouveau <quote>clone</quote> à partir du statut trouvé pour le n&oelig;ud <quote>fournisseur</quote>.
      </para>
    </refsect1>
    <refsect1><title>Exemple</title>
      <programlisting>
        clone finish (id = 33, provider = 22);
      </programlisting>
    </refsect1>
    <refsect1> <title>Note de version</title>
      <para>Cette commande fut introduite dans &slony1; 1.2.0.</para>
    </refsect1>
  </refentry>

  
 </reference>
