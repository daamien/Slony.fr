<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<article id="slonikref">
<title>Tour d'horizon des commandes Slonik</title>
   <sect1><title>Introduction</title>
    
    <para>
     <application>Slonik</application> est un utilitaire en ligne de commande
     conçu spécifiquement pour mettre en place et modifier la configuration 
     d'un système de réplication &slony1;.
    </para>
   
   <sect2 id="outline">
    <title>Considérations générales</title>
    
    <para>
     L'utilitaire en ligne de commande <application>slonik</application>
     est supposé être intégré dans des scripts shell et lit 
     les commandes à partir d'un fichier ou de stdin ( voir plus 
     bas pour des exemples ). Presque tout le travail de configuration
      <emphasis>réel</emphasis> est effectué en appelant des procédures
      stockées après avoir chargé la base de support &slony1; dans 
      la base de données. Vous pouvez trouver de la documentation sur
      ces procédures dans le chapitre <ulink url="schemadoc">&slony1;
     Documentation du Schéma</ulink>, ainsi que dans les commentaires
     qui sont associé aux procédures dans la base de données.
    </para>

    <para>
     <application>Slonik</application> a été créé car:
     <itemizedlist>
      
      <listitem><para>Les procédures stockées ont des besoin d'informations
	  spécifiques telles que l'identifiant du noeud de réplication 
	  sur lequel elles sont appelées;</para></listitem>
      
      <listitem><para>L'absence de paramètres nommés dans les 
	  procédures stockées rend difficile de faire cela depuis
	  l'invite de commande 	<application>psql</application>;
	  </para></listitem>
      
      <listitem><para><application>psql</application>n'a pas la possibilité
	  de maintenir plusieurs connexions avec des transactions ouvertes.
	  </para></listitem>
     </itemizedlist>
    </para>
    <para>
     
    </para>
    <sect3><title>Commandes</title>
     <para>
      Le format du langage de commande slonik est libre.
      Les commandes commence par des mots-clefs et sont terminées
      par un point-virgule. La plupart des commande ont une liste de 
      paramètres, certains ont une valeur par défaut et sont donc 
      facultatifs. Les paramètres de commandes sont entourés par des
      parenthèses. Chaque option est constituée d'un ou plusieurs
      mots-clefs, suivis d'un symbole égal, suivi d'une valeur. Les 
      optons multiples à l'intérieur de parenthèses sont séparées par
      des virgules. Tous les mot-clefs sont sensibles à la casse. Le
      langage devrait rappeler le SQL.
     </para>
     <para>
      Les valeurs d'option peuvent être :
      <itemizedlist>
       <listitem><para>des entiers;</para></listitem>
       <listitem><para>des chaînes caractères entourés de quotes;</para></listitem>
       <listitem><para>des valeurs booléennes  {TRUE|ON|YES} ou {FALSE|OFF|NO};</para></listitem>
       <listitem><para>des mots-clefs dans des cas spécifiques</para></listitem>
      </itemizedlist>
     </para></sect3>
    <sect3><title>Commentaires</title>
     <para>
      Les commentaires commencent par un dièse (#) et vont jusqu'à la fin de la ligne.
     </para></sect3>
    <sect3><title>Groupes de commandes</title>
     <para>
      Les commandes peuvent être combinées par groupes de commandes avec une 
      éventuellement une condition <command>on error</command> et 
      <command>on success</command>. 
      La syntaxe est la suivante :
      <programlisting>
       try {
       commands;
       } 
       [on error { commands; }
       [on success { commands; }
      </programlisting></para>

     <para> Ces commandes sont regroupées ensemble au sein d'une transaction
       pour chaque noeud participant.</para>
<!-- ************************************************************ --></sect3></sect2></sect1></article>

 <reference id="metacmds">
  <title>Meta-commandes Slonik</title>
  <partintro>
   <para>
     Les commandes suivantes sont utilisées pour séparer
     les définitions des composants des scripts Slonik;
      <xref linkend="stmtinclude"/> regroupe la configuration 
      dans des fichiers centraux qui peuvent être réutilisés, et 
      <xref linkend="stmtdefine"/> permet de remplacer les identifiants
      numérique et ésotérique des objets par des identifiants mnémotechniques.
   </para>
  </partintro>
  <!-- **************************************** -->
  <refentry id ="stmtinclude"><refmeta><refentrytitle>INCLUDE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
  
   <refnamediv><refname>INCLUDE</refname>
    
    <refpurpose> insérer du code slonik à partir d'un autre fichier </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>include </command>
     <arg><replaceable class="parameter"> &lt;chemin&gt;</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
      Ceci injecte le script slonik spécifié à l'intérieur du script actuel.
      Si le <option>chemin</option> est relatif, <xref linkend="slonik"/> 
      cherchera à partir du répertoire de travail.
    </para>

    <para>
      Les inclusions imbriquées sont supportées. Le scanner et l'analyser
      retourne le bon nom de fichier et le numéro ligne correcte en cas
      d'erreur.
       </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     include &lt;/tmp/preamble.slonik&gt;;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>
  <!-- **************************************** -->
  <refentry id ="stmtdefine"><refmeta><refentrytitle>DEFINE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DEFINE</refname>
    
    <refpurpose> Définir un nom symbolique </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>define </command>
     <arg><replaceable class="parameter"> nom </replaceable></arg>
     <arg><replaceable class="parameter"> valeur </replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
      Ceci définit un nom symbolique. Les noms symboliques doivent
      respecter les règles de slonik en matière de construction d'identifiant,
      en commençant par une lettre, suivie de lettres, de nombres et de soulignés ("_").
    </para>

    <para>
      Les valeurs des noms symboliques peuvent contenir des espaces et peuvent contenir
      des références à des noms symboliques, de manière récursive.
    </para>

    <para>
      Les symboles sont référencés en utilisant une arobase <quote>@</quote> suivi
      du nom symbolique. Notons que le référencement d'un symbole est annulé
      à l'intérieur des chaînes de caractères.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
define    cluster films;
define    sakai   1;
define    chen    2;
define    fqn     fully qualified name;

cluster name = @cluster;
node @sakai admin conninfo = 'service=sakai-replication';
node @chen  admin conninfo = 'service=chen-replication';
define setFilms    id = 1;
define sakaiFilms  @setFilms, origin = @sakai;

create set ( @sakaiFilms, comment = 'films' );

set add table( set @sakaiFilms, id = 1, @fqn = 'public.clients', 
               comment = 'sakai customers' );
set add table( set @sakaiFilms, id = 2, @fqn = 'public.cassettes',     
               comment = 'sakai cassettes' );
echo '@sakaiFilms sera affiché comme une chaîne, et ne sera pas interprété';
    </programlisting>
   </refsect1>

   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>

 </reference>  
  
<!-- **************************************** -->

 <reference id="hdrcmds"> 
  <title>Commandes slonik préliminaires</title>
  <partintro>
   <para>
    Les commandes suivantes doivent apparaître en <quote>préambule</quote> au
    de chaque script de commande <application>slonik</application>. 
    Ils ne provoque aucune action directement sur les noeuds du 
    système de réplication, mais affecte l'exécution du script tout entier.
   </para>
  </partintro>
  <!-- **************************************** -->
  
  <refentry id ="clustername"><refmeta><refentrytitle>CLUSTER NAME</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLUSTER NAME</refname>
    
    <refpurpose> préambule - identifier le cluster &slony1; </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>CLUSTER NAME = </command>
     <arg><replaceable class="parameter"> nom;</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Ceci doit être la toute première ligne de chaque script
     <application>slonik</application>. Elle définit l'espace
     de nom dans lequel toutes les fonctions spécifiques, les procédures,
     les tables et les séquences de &slony1; sont déclarées.
     Le nom de l'espace de nom est construit en préfixant le chaîne
     de caractère fournie par un souligné. Ce nom d'espace sera 
     identique sur toutes les bases de données qui participent 
     aux même groupe de réplication.
    </para>
    
    <para>
     Aucun objet utilisateur n'est supposé être placé dans cet espace de nom,
     et l'espace de nom ne doit exister avant l'ajout de la base de données
     dans le système de réplication. Ainsi, si vous ajouter un nouveau noeud
     en utilisant <command> pg_dump -s </command> sur une base qui est déjà 
     dans le cluster de réplication, vous devrez supprimer l'espace de nom
     avec la commande SQL<command> DROP SCHEMA _testcluster CASCADE; </command>.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     CLUSTER NAME = testcluster;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
  
<!-- **************************************** -->

  <refentry id ="admconninfo"><refmeta><refentrytitle>ADMIN CONNINFO</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>ADMIN CONNINFO</refname>
    <refpurpose> preambule - identifier la base &postgres;</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>NODE ival ADMIN CONNINFO = 'DSN';</command>
     <arg><replaceable class="parameter"> ival;</replaceable></arg>
     <arg><replaceable class="parameter"> 'conninfo'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Décrit comment l'utilitaire <application>slonik</application> peut
     atteindre les bases des noeuds du cluster à partir du l'endroit
     où il se trouve (en général le poste de travail de l'administrateur)
     La chaîne connifo est l'argument passé à la fonction 
     libpq <function>PQconnectdb()</function>. L'utilisateur qui se connecter
     doit être un super-utilisateur spécifique à la réplication, car certaines
     actions réalisées par la suite comprennent des opérations strictement réservées
     aux super-utilisateurs du serveur  &postgres;.
    </para>

    <para>
     L'utilitaire <application>slonik</application> n'essaie pas de se connecter
     à une base de donnée que si un commande nécessite une connexion.
    </para>

   <note> <para>
     Comme indique dans les document originaux, &slony1; est conçu comme 
     une système de réplication d'entreprises pour datacenters. Lors du développement
     du logiciel, on présuppose que les serveurs de bases de données et les postes
     de travail impliqués dans la réplication et/ou dans les activités de mise en place et 
     de configuration peuvent utiliser des méthodes simples d'authentification telle que
     <quote>trust</quote>.  Cependant, libpq peut lire les mots de passe dans le fichier
     <filename> .pgpass </filename>.
    </para>
   </note>
   <note>
    <para>
    Si vous devez changer les informations DSN pour un noeud, par exemple si 
    l'adresse IP d'un hôte est modifiée, vous devez soumettre cette nouvelle
    information avec la commande  <xref linkend="stmtstorepath"/>,
    et la configuration sera propagée. Certains processus 
     <application> slon </application> existant devront être relancés afin qu'il 
     soient avertis de ce changement de configuration.
    </para>
   </note>

   <para>Pour plus de détails sur la distinction entre ceci et <xref
   linkend="stmtstorepath"/>, consultez le chapitre &rplainpaths;.</para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
 </reference>
<!-- ************************************************************ -->
 
<!-- **************************************** -->
 <reference id="cmds">
  <title>Commande de configuration et d'action</title>
<!-- **************************************** -->
  
  <refentry id ="stmtecho"><refmeta><refentrytitle>ECHO</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>ECHO</refname>
    
    <refpurpose> Outil générique de sortie </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>echo </command>
     <arg><replaceable class="parameter"> 'message'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Affiche un message littéral sur la sortie standard.
    </para>
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <programlisting>
     ECHO 'Noeud 1 initialisé correctement';
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
  <!-- **************************************** -->
  
  <refentry id ="stmtexit"><refmeta><refentrytitle>EXIT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXIT</refname>
    
    <refpurpose> Termine un script Slonik avec un signal </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>exit</command>
     <arg><replaceable class="parameter"> [-]ival</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     termine immédiatement un script d'exécution, annulant toute
     les transaction ouverte (roll back) sur toutes les bases de données
     connectées. L'utilitaire <application>slonik</application> retournera
     la valeur indiquée comme code de terminaison du programme.
    </para>
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <programlisting>
     EXIT 0;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

  <!-- **************************************** -->
  <refentry id="stmtinitcluster">
   <refmeta>
    <refentrytitle>INIT CLUSTER</refentrytitle>
     <manvolnum>7</manvolnum>
   </refmeta>
   <refnamediv>
    <refname>INIT CLUSTER</refname>
    <refpurpose>Initialise le cluster &slony1;</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>INIT CLUSTER</command> 
     <arg>ID = <replaceable class="parameter">entier</replaceable></arg>
     <arg>COMMENT = <replaceable class="parameter">'chaîne'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title> 

    <para> Initialise le premier noeud d'un nouveau cluster de réplication &slony1;.
    Le processus d'initialisation consiste à créer l'espace de nom du cluster,
    charger toutes les tables, les fonctions, les procédures et initialiser le noeud
    avec  &funinitializelocalnode; and &funenablenode;.
     
     <variablelist>
      <varlistentry><term><literal>ID</literal></term>
       <listitem><para>L'identifiant numérique et unique du noeud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal>COMMENT = 'commentaire'</literal></term> 
	<listitem><para> Un texte descriptif ajouté à la ligne du  noeud dans
	    la table &slnode;. 
      </para></listitem>
      </varlistentry>
     </variablelist>
     
    </para>
    
    <para> Pour que ce processus fonctionne, les scripts SQL du système 
      &slony1; doivent être installés sur le poste de travail de l'administrateur
      (l'ordinateur utilisé pour exécuter l'utilitaire <application>slonik</application>),
      tandis que sur le serveur qui héberge le noeud de base de donnée contenant les
      objets partagés, &slony1; doit être installé dans le répertoire qui contient 
      les librairies de &postgres;. De plus le langage procédural
    PL/pgSQL dit être installé au préalable sur la base de données cible.
    </para>
   </refsect1>
   <refsect1>
    <title>Exemple</title>
    <programlisting>
INIT CLUSTER (
   ID = 1,
   COMMENT = 'Noeud 1'
);
    </programlisting>

   <note> <para> Cette commande fonctionne de manière similaire à 
       <xref linkend="stmtstorenode"/>, la différence étant que <command>INIT
   CLUSTER </command> n'a pas besoin de récupérer la configuration des autres noeuds.
   </para> </note>
   <note> <para> Soyez conscients que certains objets qui sont créés contiennent
       le nom du cluster à l'intérieur de leur nom  (Notamment, les index
       partiels sur <envar>sl_log_1</envar> et <envar>sl_log_2</envar>).
       Ceci implique que les noms de cluster <emphasis>très longs</emphasis>
       sont une mauvaise idée, car ils entraînent un dépassement des noms 
       d'objets au delà de la limite de 63 caractères.
     </para> </note> 
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette commande crée un nouvel espace de noms et configure les
      tables à l'intérieur; aucun objets public ne doit être verrouiller
      pendant l'exécution de cette commande.</para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id ="stmtstorenode"><refmeta><refentrytitle>STORE NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE NODE</refname>
    <refpurpose> Initialise un noeud &slony1;</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Initialise un nouveau noeud et l'ajoute dans la configuration du 
      cluster existant.</para>

    <para> Le processus d'initialisation consiste à la création de l'espace
      de noms sur le nouveau noeud ( la base elle-même doit déjà exister ),
      charger les tables, les fonctions, les procédures et initialiser le 
      noeud. La configuration existante du reste du noeud est copiée à 
      partir d'un <quote>node d'événement</quote>.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para> L'identifiant numérique et unique du nouveau noeud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal> COMMENT = 'description' </literal></term>
       <listitem><para> Un texte descriptif ajouté à la ligne du noeud dans
	   la table &slnode;</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal> SPOOLNODE = booléen </literal></term>
       
       <listitem><para>Spécifie qu'un noeud est un noeud virtuel de récupération
	   pour l'archivage de journaux de réplication. Si ce paramètre est à true
	   <application>slonik</application> n'essaiera pas d'initialiser la base de 
	   donnée avec le schéma de réplication.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> L'identifiant du noeud utilisé pour créer l'événement de configuration,
	   qui prévient tous les noeuds existants de l'arrivée du nouveau noeud.
	   La valeur par défaut est 1.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Ceci utilise &funinitializelocalnode; et &funenablenode;. </para>
    
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <programlisting>
     STORE NODE ( ID = 2, COMMENT = 'Noeud 2');
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette commande crée un nouvel espace de nom et configure les tables
      à l'intérieur;aucun objets public ne doit être verrouiller
      pendant l'exécution de cette commande.</para>
   </refsect1>

   <refsect1> <title> Note de version </title> 
     <para> Cette commande fut introduite dans &slony1; 1.0.  La paramètre <envar>SPOOLNODE</envar>
     fut introduit dans la version 1.1, mais n'était pas implémentée dans cette version.
     La fonctionnalité <envar>SPOOLNODE</envar> est arrivée dans la
   version 1.2. </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtdropnode"><refmeta><refentrytitle>DROP NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP NODE</refname>
    
    <refpurpose> Supprime un noeud de la réplication </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un noeud. Cette commande retire complètement le noeud spécifié 
     de la configuration du système de réplication.
     Si le démon de réplication est toujours en fonctionnement sur ce noeud
     (et qu'ils traitent les événements), il tentera de désinstaller le système
     de réplication et s'arrêtera de lui-même.

     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> L'identifiant du noeud à supprimer.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       <listitem><para> L'identifiant du noeud qui génère l'événement. La valeur par défaut est 1.
       </para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Cette commande utilise &fundropnode;. </para>

    <para> Quand vous invoquez <command>DROP NODE</command>, une des étapes
      consiste à lancer <command>UNINSTALL NODE</command>.</para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Lorsqu'on supprime des triggers d'une table de l'application,
      cela nécessite un accès exclusif à chaque table répliquée sur le noeud
      que l'on supprime.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para> Si vous utiliser des connexions qui cachent les plans d'exécution
   (ce qui est particulièrement commun pour framework applicatifs Java utilisant
   de pools de connexion pools), les connexions peuvent cacher des plans
   de requêtes qui se base sur une vision pré-<command>DROP NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>

   <para>Ainsi après avoir supprimé un noeud, il est préférable de réinitialiser
     les connexions de votre applications.</para>

   <para> Vous ne pouvez pas soumettre cela à un <command>EVENT
   NODE</command> ayant le même numéro que le noeud que vous supprimez;
   la requête doit aller vers un noeud qui restera dans le cluster.
   </para>
   </refsect1>

   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  <refentry id="stmtuninstallnode"><refmeta><refentrytitle>UNINSTALL NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNINSTALL NODE</refname>
    
    <refpurpose> Désinstaller un noeud &slony1; </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNINSTALL NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Restaure toutes les tables dans leur état non verrouiller, avec 
      les triggers d'origines, les contraintes et les règles, les éventuelles colonnes
      spécifiques de &slony1; contenant des clefs SERIAL sont supprimées.
      et le schéma  &slony1; est effacé. Le noeud redevient une base de données
      indépendante. Les données ne sont pas modifiées.   
     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> Identifiant du noeud à désinstaller.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Cette commande utilise &fununinstallnode;. </para>

    <para> La  différence entre <command>UNINSTALL NODE</command>
    et <command>DROP NODE</command> est que <command>UNINSTALL
    NODE</command> se contente de supprimer la configuration &slony1;;
    il ne retire la configuration du noeud sur l'ensemble de réplication.
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  UNINSTALL NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Lorsque l'on supprime les triggers off des tables de l'application,
      cela nécessite un accès exclusif sur chaque table répliquée sur le noeud
      que l'on désinstallé.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para> Si vous utiliser des connexions qui cachent les plans d'exécution
   (ce qui est particulièrement commun pour framework applicatifs Java utilisant
   de pools de connexion pools), les connexions peuvent cacher des plans
   de requêtes qui se base sur une vision pré-<command>UNINSTALL NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>   

   <para>Ainsi après avoir désinstallé un noeud, il est préférable de réinitialiser
     les connexions de votre applications.</para>   
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrestartnode"><refmeta><refentrytitle>RESTART NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>RESTART NODE</refname>

    <refpurpose> Redémarre un noeud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>RESTART NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Provoque l'arrêt et le redémarrage d'un démon 
      de réplication sur le noeud spécifié 
      Théoriquement, cette commande est obsolète. En pratique,
      les timeouts TCP peuvent retarder les changements critiques 
      de configuration jusqu'à ce qu'il soit effectué alors que le
      noeud expéditeur est en échec et doit être ignoré par les 
      noeuds abonnés.     
     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> Identifiant du noeud à redémarrer.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  RESTART NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>


    <para> Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0;
      Elle ne devrait plus être nécessaire à partir de la version 1.0.5. </para>
   </refsect1>
  </refentry>
  

  <!-- **************************************** -->

  <refentry id="stmtstorepath"><refmeta><refentrytitle>STORE
     PATH</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE PATH</refname>
    
    <refpurpose> Configure la connexion d'un noeud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Configure comment le démon de réplication d'un noeud se 
      connecte à la base de données d'un autre noeud. Si le système
      de réplication est supposé utiliser un segment spécial de réseau,
      c'est ici qu'on définit les adresses IP ou les noms d'hôtes.
      Un configuration existante peut-être écrasée.
      </para>
    
    <para> Le paramètre conninfo doit contenir toutes les informations
      pour se connecter à la base en tant super-utilisateur de la réplication.
      Les termes <quote>serveur</quote> or <quote>client</quote> n'ont
      rien à voir avec le rôle particulier d'un noeud dans la configuration
      d'un cluster. On peut simplement voir cela comme un 
      <quote>serveur</quote> ayant un message or un donnée qu'un 
      <quote>client est supposé obtenir</quote>.
      Pour une installation simple avec 2 noeuds, les chemins dans les deux 
      directions doivent être configurés.
    </para>
    <para> Il ne pose aucun problème de configurer un chemin entre chaque 
      noeud. ( produit en croix complète ).Les connexions ne sont établit que 
      si cela est nécessaire pour transférer un événement ou une confirmation
      à cause des entrées <emphasis>listen</emphasis> ou une donnée à cause de
     <emphasis>souscriptions</emphasis>.
     
     <variablelist>
      <varlistentry><term><literal> SERVER  = ival </literal></term>
       <listitem><para> Identifiant du noeud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CLIENT  = ival </literal></term>
       <listitem><para> Identifiant du noeud du démon de réplication qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CONNINFO  = string </literal></term>
       <listitem><para> Argument <function>PQconnectdb()</function> pour établir la connexion.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CONNRETRY  = ival </literal></term>
       <listitem><para> Nombre de secondes d'attente avant qu'un autre tentative
	   de connexion soit faite dans le cas ou le serveur est indisponible. 
	   La valeur par défaut est 10.
	</para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funstorepath;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
STORE PATH ( SERVER = 1, CLIENT = 2, 
             CONNINFO = 'dbname=testdb host=serveur1 user=slony'
           );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>


    <para> Aucun verrouillage ne devrait être visible depuis l'application. </para>     
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdroppath"><refmeta><refentrytitle>DROP PATH</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP PATH</refname>
    
    <refpurpose> Supprime un chemin de connexion &slony1; </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Supprime les informations de connexion entre un <quote>serveur</quote> et
     <quote>client</quote>.</para>
     
     <variablelist>
      <varlistentry><term><literal> SERVER  = ival </literal></term>
       <listitem><para> Identifiant du noeud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CLIENT  = ival </literal></term>
       <listitem><para> Identifiant du noeud du démon qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> L'identifiant du noeud utilisé pour créer l'événement de configuration
	qui annonce à tous les noeuds existants que le chemin a été supprimé. 
	La valeur par défaut est l'identifiant du noeud <quote>client</quote>.
	</para></listitem>
      </varlistentry>
      </variablelist>
      </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP PATH ( SERVER = 1, CLIENT = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous</title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtstorelisten"><refmeta><refentrytitle>STORE LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE LISTEN</refname>
    
    <refpurpose> Configure un noeud &slony1; en lui indiquant où il 
      doit écouter les événements </refpurpose></refnamediv>
    
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Pour chaque entrée <quote>listen</quote>, le noeud récepteur demande
      à un noeud fournisseur de lui envoyer les événements d'un autre noeud
      ainsi que les confirmations en provenance des tous les autres noeuds existants.
      Cela nécessite qu'un <quote>chemin</quote> doit exister pour
      que le récepteur (le client) puisse se connecter au fournisseur (le serveur).</para>

    <para> Chaque noeud du système doit écouter les événements
      de tous les autres noeuds. En règle générale, un abonné
        (voir <xref linkend="stmtsubscribeset"/>) doit écouter les événements
    d'un ensemble origine sur un fournisseur unique, qui lui envoie
    les données. En retour, l'origine de l'ensemble de réplication
    doit écouter les événements dans la direction opposée.
    Un noeud peut écouter simultanément les événements d'un même ensemble d'origine
    en provenance de différents fournisseurs. Cependant pour traiter les 
    événements <command>SYNC</command> de cette ensemble d'origine tous les
    fournisseurs de données doivent avoir un niveau de synchronisation égal 
    ou supérieur, afin d'éviter des comportements de réplication trop 
    rapide.
    </para>

    <variablelist>
     <varlistentry><term><literal> ORIGIN  = ival </literal></term>
      <listitem><para> L'identifiant du noeud d'origine que le récepteur écoute.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> PROVIDER = ival </literal></term>
     <listitem><para> L'identifiant du noeud qui envoie au récepteur les événements 
	 produits par le noeud origine. Si cette valeur n'est pas spécifiée,
	 il s'agit du noeud origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> RECEIVER = ival </literal></term>
      
      <listitem><para> L'identifiant du noeud recevant les événements.</para></listitem>
     </varlistentry>
    </variablelist>

    <para> Cette commande utilise &funstorelisten;. </para>
    <para> Pour plus de détails, consultez &rlistenpaths;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     STORE LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande fut introduite 
   dans &slony1; 1.0.  À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande, car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroplisten"><refmeta><refentrytitle>DROP LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP LISTEN</refname>
    
    <refpurpose> Élimine la configuration qui décrit comment un noeud
    &slony1; écoute les  événements
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Supprime une <quote>voie d'écoute</quote> de la configuration. </para>
    
    <variablelist>
     <varlistentry><term><literal> ORIGIN  = ival </literal></term>
      <listitem><para> Identifiant du noeud origine que le récepteur écoute.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> PROVIDER = ival </literal></term>
     <listitem><para> Identifiant du noeud qui envoie au récepteur les événements
	 produits par l'origine. Si cette valeur n'est pas spécifiée, alors il 
	 s'agit de l'origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> RECEIVER = ival </literal></term>
      
      <listitem><para> L'identifiant du noeud qui reçoit les événements.</para></listitem>
     </varlistentry>
    </variablelist>
    
    <para> Cette commande utilise &fundroplisten;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande fut introduite 
   dans &slony1; 1.0.  À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande, car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

<refentry id="stmttableaddkey"><refmeta><refentrytitle>TABLE ADD KEY</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>TABLE ADD KEY</refname>
    
    <refpurpose> Ajoute une clef primaire pour 
    &slony1; dans une table qui n'en possède pas
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>TABLE ADD KEY (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans un système de réplication &slony1;, chaque table répliquée 
     doit avoir au moins une contrainte
     <command>UNIQUE</command> dont les colonnes sont déclarées
     <command>NOT NULL</command>. N'importe quelle clef primaire
     respecte ces pré-requis.
    </para>

    <para>
     En dernier recours, <emphasis>dans les versions de &slony1; antérieures
       à la 2.0</emphasis>, cette commande peut être utilisée pour ajouter 
     un attribut à une table qui ne possède par de clef primaire.
     Sachant que cette modification pour avoir des effets secondaires
     indésirables, <emphasis>il est très fortement recommandé que les 
       utilisateurs ajoute les attributs unique et not null par 
       leurs propres moyens.</emphasis>
    </para>

   <para> Si vous comptez utilisez &slony1; version 2.0, vous
   <emphasis>devez</emphasis> vous débrouiller pour définir
   une clef primaire plus adéquate.
   &slony1; ne vous en fournira pas une, et si vous 
   avez des clefs créées via <command>TABLE ADD KEY</command>,
   ne vous attendez pas à ce que &slony1; fonctionne correctement. </para>
    <variablelist>
     <varlistentry><term><literal> NODE ID = ival </literal></term>
      <listitem><para> Identifiant du noeud de l'ensemble de réplication d'origine
	  où l'on ajoute la table dans l'ensemble (voir <xref linkend="stmtsetaddtable"/>.)</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> FULLY QUALIFIED NAME  = 'string' </literal></term>
      <listitem><para> Le nom complet de la table composé du nom du schéma
	  et du nom de la table, au format SQL suivant 
	<command>quote_ident(nspname)
	 || '.' || quote_ident(relname)</command>.</para></listitem>
     </varlistentry>
    </variablelist>

    <note><para> Pour le moment il existe des limitations; vous pouvez
	créer une table &postgres; avec aucune colonne, par exemple 
	<command> create table table_vide (); </command>.  
	&slony1; refusera de manipuler une telle table.
	Ce n'est pas vraiment une limitation gênante, car il est 
	n'est pas très intéressant de répliquer des tables qui ne contiennent
	aucune information.</para> </note>

    <caution><para> <command>TABLE ADD KEY</command> <emphasis>ne doit
    pas être utilisée</emphasis> si vous pouvez vous en passer.
    C'est le <emphasis></emphasis> d'une &bestpracticelink;. </para>

    <para> L'absence d'une clef primaire adéquate est
      une indication très sérieuse que le schéma est 
    <emphasis>défectueux</emphasis>. La
    <emphasis>bonne</emphasis> méthode pour le réparer est d'introduire
    un clef primaire adéquate, pas demander à &slony1; d'en <quote>bricoler</quote> une.</para> 

    <para>Cette commande n'est  <emphasis>pas</emphasis> supportée  par le &logshiplink;,
    et nous n'avons pas l'intention de développer ce support.</para> </caution>
    
    <para> Cette commande utilise &funtableaddkey;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     TABLE ADD KEY ( NODE ID = 1, 
     FULLY QUALIFIED NAME = 'public.history' );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur le noeud origine, la commande posera un verrou exclusif
      sur la table modifiée tant que ces opérations ne seront pas terminées :
     :</para>
    <itemizedlist>
    <listitem><para> Modifier la table, ajouter la colonne;</para></listitem>
    <listitem><para> Modifier chaque ligne de la table, attacher la valeur de la séquence;</para></listitem>
    <listitem><para> Ajouter un nouvel index unique à la table.</para></listitem>
    </itemizedlist>

    <para> Sur les noeus abonnés, ces modifications sont
      réalisées sur la table lorsqu'elle est TODO, et perturbe 
      pas particulièrement l'abonnement au cours du verrouillage
      sur le noeud abonné.</para> 

    <para> Si la table est volumineuse et fréquemment mise à jour
      par vos applications, cela imposera un coupure de service
      significative qui correspond au temps de modification de la
      table sur le noeud d'origine. C'est pourquoi il est recommandé
      que cette commande ne soit pas utilisée quand c'est possible.</para>      
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
<warning>    <para> Cette commande n'est <emphasis> plus supportée</emphasis>
    à partir de &slony1; version 2.0.  Dans la version 2, les différents
    <quote>modifications du catalogue</quote> réalisée sur les
    versions de &postgres; antérieures à la 8.3 sont éliminées
    afin que les exports de schéma puissent être utilisés sur n'importe
    quel noeud. Ainsi les colonnes <quote>bricolées</quote> par
    <command>TABLE ADD KEY</command> sont la chose qui empêche la commande
    <xref linkend="stmtuninstallnode"/> d'être équivalente à 
    la commande SQL  <command>drop schema _nom_du_cluster 
    cascade;</command>.</para> </warning>    
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtcreateset"><refmeta><refentrytitle>CREATE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CREATE SET</refname>
    
    <refpurpose> Crée un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>CREATE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans le système de réplication &slony1;, les tables répliquées sont 
     regroupées en ensembles. En règle générale, un ensemble contient 
     des tables reliées pour une application donnée. Dans application 
     correctement conçue, toutes ces tables sont regroupées dans un
     schéma.
    </para>
    <para>
     L'ensemble de réplication est la plus petite unité qu'un noeud peut répliquer vers un autre noeud.
     Un ensemble de réplication a toujours une origine. En terme classique,
     c'est ce qu'on appelle le <quote>maître</quote>.
     Puisqu'avec &slony1; un noeud peut être simultanément <quote>maître</quote> pour un ensemble,
     et tenir le rôle  d'<quote>esclave</quote> pour un autre, cette terminologie peut 
     rapidement prêter à confusion et doit par conséquent être remplacée par 
      <quote>ensemble d'origine</quote> et <quote>abonné</quote>.
    </para>
    
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant de l'ensemble qu'il faut créer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine initial de cet ensemble.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> COMMENT = 'chaîne' </literal></term>
      <listitem><para> Un texte descriptif peut être ajouté pour l'ensemble de réplication.</para>
                <para> Si aucun commentaire n'est fourni, la valeur par défaut est  <command>A replication set so boring no one thought to give it a name</command>  (NdT : <quote>Un ensemble de réplication tellement
		  ennuyeux qui personne n'a pensé à lui donner un nom</quote>)
	      </para>
      </listitem>
     </varlistentry>
    </variablelist>
    
    <para> Cette commande utilise &funstoreset; . </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     CREATE SET ( ID = 1, 
               ORIGIN = 1,
               COMMENT = 'Tables du système de réservation' );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
    <para> Jusqu'à la version 1.2, la commande échoue si aucun commentaire n'est fourni. </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdropset"><refmeta><refentrytitle>DROP SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>DROP SET</refname>
    
    <refpurpose> Enlever un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un ensemble de table de la configuration &slony1;. 
     Cette commande désabonne automatiquement tous les noeuds qui 
     héberge cet ensemble et rétablit les règles et les triggers 
     originaux sur tous les abonnés.
    </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant de l'ensemble qu'il faut supprimer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine actuel de l'ensemble de réplication.</para></listitem>
     </varlistentry>
    </variablelist>
    
       <para> Cette commande utilise &fundropset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP SET ( ID = 5, 
             ORIGIN = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur chaque noeud, la commande pose un verrou exclusif sur 
      chaque table répliquée afin de modifier le schéma de la table
      pour nettoyer les triggers et les règles. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
 
<!-- **************************************** -->

  <refentry id="stmtmergeset"><refmeta><refentrytitle>MERGE
     SET</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MERGE SET</refname>
    
    <refpurpose> Fusionne plusieurs ensemble de réplication &slony1; 
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MERGE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Fusionne un ensemble de tables et de séquences dans un autre.
      Cette fonction est un contournement face à l'impossibilité
      d'ajouter des tables/séquences à des ensembles en cours de 
      réplication. On peut alors créer un ensemble temporaire, y ajouter
      les nouveaux objets, abonner tous les noeuds à ce nouvel ensemble,
      puis fusionner l'ensemble courant et l'ensemble temporaire, et ce qui supprime
      l'identifiant de l'ensemble temporaire.
      
    </para>

    <para>
     Cette opération ne fonctionnera si les deux ensembles ne sont pas 
     répliqués <emphasis>exactement</emphasis> sur les mêmes noeuds abonnés.
     </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant unique de l'ensemble qui contiendra les deux ensembles distincts.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ADD ID = ival </literal></term>
      <listitem><para> Identifiant unique de l'ensemble de l'ensemble dont les objets vont être transférés.  </para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine actuel des deux ensembles.  </para></listitem>
     </varlistentry>
    </variablelist>
    
       <para> Cette commande utilise &funmergeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     # Supposons que l'ensemble 1 est répliqué sur les noeuds 2 et 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1><title> Comportement dangereux ou non-intuitif </title>

   <para> La fusion se déroule suivant la configuration sur le noeud origine.
   Si une fusion est demandée alors que les abonnements sont toujours
   en cours de traitement, cela peut briser les réplications en cours
   sur les noeuds abonnés, car ils chercheront la configuration de cet
   ensemble alors qu'il vient d'être supprimé. Ne soyez pas trop 
   rapides lorsque vous fusionner des ensembles.
   </para>

   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande
       fut introduite dans &slony1; 1.0.5.  Dans la version 1.2.1, 
       une condition de compétition ("race condition") a été corrigée.
       Elle apparaissait lorsque la requête de fusion était soumise
       alors que les demande d'abonnement étaient traités.
       Cela empêche les fusion avant que les abonnements soient 
       complètement réalisés. </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddtable"><refmeta><refentrytitle>SET ADD TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD TABLE</refname>
    
    <refpurpose> Ajoute une table dans un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Ajoute une table existante dans un ensemble de réplication. L'ensemble ne doit 
    pas être répliqué sur un autre noeud, cette fonctionnalité est assurée par la commande 
    <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble dans lequel la table doit être ajoutée. </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud origine de l'ensemble.  Les prochaines version de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>

       <listitem><para> Identifiant unique de la table. Ces identifiants ne sont 
       pas seulement utilisé pour désigner une table dans l'ensemble de réplication.
       Cette valeur numérique détermine également l'ordre de verrouillage des tables,
       notamment lors de la commande <xref linkend="stmtlockset"/>.
       Cet identifiant doit donc suivre une certaine hiérarchie afin que les scripts
       <application>slonik</application> ne provoque de situation d'inter-blocage ("deadlocks").
       </para>

         <para> Cet identifiant doit être unique pour tous les ensembles de réplication;
	 vous ne devez pas avoir deux tables du même cluster avec le même identifiant.
	  </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
       <listitem><para> Le nom complet de la table tel que décrit dans
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> KEY = { 'string' | SERIAL }
	</literal></term> <listitem><para>
	 <emphasis>(Facultatif)</emphasis> Le nom de l'index relatif à la colonne unique et 
	 non-nulle qui est utilisée comme identifiant de ligne lors de la réplication.
	 Si le mot-clef SERIAL est utilisé, cela indique qu'il faut utiliser la colonne 
	 spéciale ajoutée avec la commande  <xref linkend="stmttableaddkey"/> command.
	 Par défaut, on utilise la clef primaire de la table. Le nom de l'index n'est 
	 <emphasis>pas</emphasis> un nom complet; vous devez omettre l'espace de nom.</para></listitem>

      </varlistentry>
      <varlistentry><term><literal> COMMENT = 'string' </literal></term>
       <listitem><para> Un texte décrivant la table.  </para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funsetaddtable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET ADD TABLE (
    SET ID = 1,
    ORIGIN = 1,
    ID = 20,
    FULLY QUALIFIED NAME = 'public.tracker_ticket',
    COMMENT = 'Ticket de Support'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Messages d'erreur </title>

    <para> Voici quelque messages d'erreurs que vous rencontrerez en cas d'utilisation incorrecte : </para>

   <variablelist>    
       <varlistentry><term><literal>Slony-I: setAddTable_int: table public.ma_table PK column id nullable </literal></term>

        <listitem><para> Les clefs primaires (ou les clefs candidates) doivent être composées 
	de colonnes <command>NOT NULL</command>. Si vous avez une clef primaire candidate dont une
	colonne n'est pas déclarée ainsi, alors &slony1; rejettera la table et produira ce message. </para> 
	</listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int: table id 14 has already been assigned! </literal></term>

        <listitem><para> L'identifiant de la table, stocké dans 
        <envar>sl_table.tab_id</envar>, doit être unique pour tous les noeuds/tables/ensembles.
	Ce message indique que vous avez tenté de déclarer un identifiant qui est déjà utilisé.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): table public.ma_table has no index mt_idx_14</literal></term>

        <listitem><para> Ceci se produit en général avec les clefs primaires candidates;
	Le message indique que l'index spécifié n'est pas disponible sur ce noeud.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): table public.ma_table not found </literal></term>

        <listitem><para> Pire que l'absence d'un index, c'est la table qui est manquante.
	Le message indique que le processus que vous avez utilisé pour mettre en place le schéma n'a pas
	fonctionné correctement. </para>
        </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): public.ma_vue is not a regular table </literal></term>

        <listitem><para> Vous ne pouvez répliquer que des tables (en tout cas avec 
        <command>SET ADD TABLE</command>). Cela n'inclut pas les vues et les indexes.
	( Les index sont répliqués de facto, mais on peut pas demander explicitement la réplication d'un index )
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): set 4 not found </literal></term>

        <listitem><para> Vous devez définit l'ensemble de réplication avant de lui assigner des tables.
        </para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable(): set 4 has remote origin </literal></term>

        <listitem><para> Ceci se produit lorsque l'ensemble de réplication #4 est configuré
	sur une origine, le noeud 1, et que vous lancez une commande <command>SET ADD
        TABLE</command> qui spécifie un autre noeud que le noeud 1. Ceci se produit généralement
	lorsque la configuration <command>admin conninfo</command> est confuse à l'intérieur du
	préambule du script slonik...</para>
        </listitem>
        </varlistentry>

       <varlistentry><term><literal>Slony-I: cannot add table to currently subscribed set 1 </literal></term>

        <listitem><para> &slony1; ne peut pas ajouter des tables dans un ensemble qui est 
	en cours de réplication. Pour contourner ce problème, vous devez définir un nouvel ensemble
	qui contiendra les nouvelles tables.</para> </listitem> </varlistentry>

   </variablelist>    

   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur le noeud origine, cette opération demande un verrou exclusif très bref sur la table
    afin de lui ajouter les triggers de réplication. Sur les noeuds abonnés, les verrous 
    correspondant sont réalisés au moment de l'événement <command>SUBSCRIBE_SET</command>.  </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddsequence"><refmeta><refentrytitle>SET ADD SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD SEQUENCE</refname>
    
    <refpurpose> Ajoute une séquence dans un ensemble de réplication
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
<refsect1>
    <title>Description</title>
    
    <para>
     Ajoute une séquence existante dans un ensemble de réplication. L'ensemble ne 
     doit pas être répliqué sur un autre noeud. Cette fonctionnalité est supportée 
     par la commande <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble dans lequel on ajoute la séquence.
	</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble. Les prochaines version de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Identifiant Unique de la séquence.  <note><para> Notons
	   que cet identifiant doit être unique parmi <emphasis>toutes les séquences</emphasis>
	   du cluster; la numérotation des tables est indépendante, donc il est possible 
	   de donner l'identifiant 20 à une table et à une séquence, sans que cela ne crée de confusion.
	   </para> </note></para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
       <listitem><para> Le nom complet de la séquence telle que décrit dans 
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> COMMENT = 'string' </literal></term>
       <listitem><para> Un texte décrivant la séquence.  </para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetaddsequence;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET ADD SEQUENCE (
     SET ID = 1,
     ORIGIN = 1,
     ID = 20,
     FULLY QUALIFIED NAME = 'public.tracker_ticket_id_seq',
     COMMENT = 'Séquence d'identifiants des tickets de support'
     );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdroptable"><refmeta><refentrytitle>SET DROP TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP TABLE</refname>
    
    <refpurpose> Supprime une table d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une table d'un ensemble de réplication.
    </para>
    <para>
     Notez que cette action ne supprimera <emphasis>pas</emphasis> une clef primaire
     candidate créée avec la commande <xref
     linkend="stmttableaddkey"/>.
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble de réplication.Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information. </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
  <listitem><para> Identifiant unique de la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetdroptable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET DROP TABLE (
     ORIGIN = 1,
     ID = 20
     );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette opération pose un verrou exclusif sur la table qui est supprimée afin 
    de retirer les triggers de réplication. Sur les noeuds abonnées, cela implique également
    le rétablissement des règles et des triggers qui ont été désactivés.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdropsequence"><refmeta><refentrytitle>SET DROP SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP SEQUENCE</refname>
    
    <refpurpose> Supprime une séquence d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une séquence existante dans un ensemble de réplication.
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Identifiant unique de la séquence.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetdropsequence;. </para>
   </refsect1>
<refsect1><title>Exemple</title>
    <programlisting>
     SET DROP SEQUENCE (
     ORIGIN = 1,
     ID = 20,
     );
</programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  
  <refentry id="stmtsetmovetable"><refmeta><refentrytitle>SET MOVE
     TABLE</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE TABLE</refname>

    <refpurpose> Déplace une table d'un ensemble de réplication vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Change l'ensemble de réplication dans lequel se trouve la table. L'ensemble courant et le 
     nouveau doivent avoir le même noeud origine et les même noeuds abonnés.
     
     <caution><para> La méthode d'abonnement d'un nouvel ensemble de réplication est 
		     particulière, vous devez vous assurer l'abonnement est complètement effectué sur tous les noeuds
     avant de déplacer les tables. Déplacer une table trop tôt vers un nouvel ensemble,
     implique que le noeud abonné va essayer d'ajouter la table pendant le processus d'abonnement
     de l'ensemble de réplication, ce qui échoue suite à une erreur de clef dupliquée et provoque 
     l'arrêt de la réplication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Origine actuelle de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>

       <listitem><para> Identifiant unique de la table.</para></listitem></varlistentry>
      <varlistentry><term><literal> NEW SET = ival </literal></term>
       
  <listitem><para> Identifiant unique de l'ensemble dans lequel il faut ajouter la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetmovetable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE TABLE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
</refentry>
  

<!-- **************************************** -->

  <refentry id="stmtsetmovesequence"><refmeta><refentrytitle>SET MOVE SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE SEQUENCE</refname>
    
    <refpurpose> Déplace une séquence d'un ensemble de réplication &slony1; vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para>
	Change l'ensemble de réplication dans lequel se trouve la séquence.
	L'ensemble courant et le nouveau doivent avoir le même noeud d'origine
	et les mêmes noeuds abonnés.
	
     <caution><para> La méthode d'abonnement à un nouvel ensemble est particulière,
	vous devez vous assurer que l'abonnement est complètement effectué
	avant de déplacer les séquences. Déplacer un séquence top tôt peut impliquer
	une tentative d'ajout de la séquence pendant le processus d'abonnement,
	ce qui échouera en émettant une erreur à cause d'une clef dupliquée et
	provoquera l'arrêt de la réplication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble de réplication. Les
	futures versions de <application>slonik</application>
	deviner toutes seules cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Identifiant unique de la séquence.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> NEW SET = ival </literal></term>
       
       <listitem><para> Identifiant unique de l'ensemble de réplication dans lequel
	la séquence doit être déplacée.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funsetmovesequence;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE SEQUENCE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtstoretrigger"><refmeta><refentrytitle>STORE TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>STORE TRIGGER</refname>
    
    <refpurpose> Indique qu'un trigger ne doit pas être désactivé par &slony1; 
sur un noeud abonné. should not be disabled by
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Par défaut, tout les triggers définis par l'utilisateur sont
désactivés sur tout les noeuds abonnés lorsque la table est répliquée.
Cette commande peut être utilisée pour empêcher explicitement la désactivation
d'un trigger.
     <variablelist>
      <varlistentry><term><literal> TABLE ID = ival </literal></term>
       <listitem><para> L'identifiant numérique et unique de la table concernée par le trigger.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>
       
       <listitem><para> Le nom du trigger tel qu'on le trouve dans le catalogue système
	 <envar>pg_trigger</envar>.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> (Optionnel) L'identifiant du noeud utilisé pour 
créer l'événement de configuration qui annonce aux noeuds existants la
présence d'un trigger spécial. Par défaut, cette valeur est 1.
	 </para></listitem>

      </varlistentry>
     </variablelist>
    </para>
    <note><para> Une astuce consiste à lancer <command>STORE
    TRIGGER</command> <emphasis>avant que le trigger soit installé
    ;</emphasis> ce qui ne provoquera pas d'erreurs. Vous pouvez
    ainsi définir la gestion d'un trigger par &slony1; 
    <emphasis>avant</emphasis> qu'il soit installé.  Vous êtes alors
    certain que le trigger est actif sur tous les noeuds immédiatement
après son installation via <xref linkend="stmtddlscript"/>; il n'y a 
aucun risque de voir un événement passer entre les événements 
    <command>EXECUTE
    SCRIPT</command> et <command>STORE TRIGGER</command>. </para>
    </note>    
    <para> Cette commande utilise &funstoretrigger;. </para>
   </refsect1>
   <refsect1><title>Exemple :</title>
    <programlisting>
STORE TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette opération pose brièvement  un verrou exclusif sur la table spécifiée
sur chaque noeud auquel elle s'applique, afin de modifier le schéma de la table
et y ajouter de nouveau le trigger.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>

    <para> Avec &slony1; version 2.0, cette commande est supprimée car
obsolète, puisque les triggers ne sont plus <quote>trafiqués</quote> 
dans le catalogue système. </para>    
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroptrigger"><refmeta><refentrytitle>DROP TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP TRIGGER</refname>
    
    <refpurpose> Cette commande redonde à un trigger son comportement par défaut :
c'est à dire qu'il ne se déclenche pas sur les noeuds abonnés. </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Supprime la gestion particulière du trigger spécifié.

     <variablelist>
      <varlistentry><term><literal> TABLE ID = ival </literal></term>
      <listitem><para> L'identifiant numérique et unique de la table pour laquelle le 
trigger est défini.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>

       <listitem><para> Le nom du trigger tel qu'on le trouve dans le catalogue système
         <envar>pg_trigger</envar>.</para></listitem>

      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>

       <listitem><para> (Optionnel) L'identifiant du noeud utilisé pour
créer l'événement de configuration qui annonce aux noeuds existants la
présence d'un trigger spécial. Par défaut, cette valeur est 1.
         </para></listitem>

      </varlistentry>

      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise  &fundroptrigger;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
DROP TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette opération pose brièvement  un verrou exclusif sur la table spécifiée
sur chaque noeud auquel elle s'applique, afin de modifier le schéma de la table
et y ajouter de nouveau le trigger.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>

    <para> Avec &slony1; version 2.0, cette commande est supprimée car
obsolète, puisque les triggers ne sont plus <quote>trafiqués</quote>
dans le catalogue système. </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtsubscribeset"><refmeta><refentrytitle>SUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SUBSCRIBE SET</refname>
    
    <refpurpose> Lance la réplication d'un ensemble donné </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande réalise une des deux opérations suivantes : </para>

    <itemizedlist>
 
    <listitem><para> Initie la réplication pour un ensemble de réplication </para>
    <para> Ceci déclenche la réplication sur un noeud (abonné) soit à partir
de l'origine soit à partir du fournisseur, qui doit être lui même un noeud
abonné actif et transmetteur ("forwarding subscriber").</para>
    
    <para> Les tables de l'application contenues dans l'ensemble de réplication 
doivent déjà exister et idéalement elles sont vides. La version courante de 
&slony1; ne tente <emphasis>pas</emphasis> de copier le schéma de l'ensemble 
de réplication. Le démon de réplication démarre et commence à copier le contenu 
de l'ensemble de réplication à partir du fournisseur spécifié, puis essaie
de rattraper son retard en rejouant les mises à jour qui se sont produites
lors du processus de copie. Un fois que l'abonnement a réussi, les tables 
sont protégées avec des triggers contre les mises à jour en provenance de 
l'application.
    </para>
    
    <para> Si les tables sur l'abonné ne sont 
    <emphasis>pas</emphasis> vides, alors l'événement <command>COPY
    SET</command> ( qui fait partie du processus d'abonnement)
    devra effectuer quelques taches supplémentaires :</para>
     <itemizedlist>

      <listitem><para> Il tente d'effectuer un <command>TRUNCATE</command>
     sur la table, ce qui devrait être efficace. </para> </listitem>
      
      <listitem><para> Si cela ne fonctionne pas ( une relation sur une 
clef étrangère empêche peut-être le fonctionnement de TRUNCATE), il 
utilise la commande  <command>DELETE</command> pour effacer toutes les 
<quote>anciennes</quote>
entrées de la tables</para></listitem>

      <listitem><para> Ces anciennes données encombrent encore l'espace
disque jusqu'à ce qu'un <command>VACUUM</command> soit effectué <emphasis>après</emphasis>
la fin du processus d'abonnement.</para></listitem>
      
      <listitem><para> Les index de la tables contiendront de références
aux anciennes données, ce qui ralentira l'insertion de nouvelles données
dans les index.</para></listitem>
     </itemizedlist>

     <warning><para> Le temps d'exécution de cette opération n'est pas 
négligeable. Si vous avez un grand volume de données dans un ensemble 
particulier de tables, cela peut prendre plusieurs heures, voire plusieurs
jours pour que l'opération aboutisse ( ici <quote>"un grand volume</quote>
signifie <quote>des dizaines ou des centaines de gigabytes de
</quote>).</para>

     <para> Cependant, la requête  <command>SUBSCRIBE SET</command> se terminera
presque immédiatement, même si les travaux, gérés par l'événement
<command>COPY SET</command>, sont encore en cours. Si vous devez configurer
les abonnements sur des noeuds en cascade, vous devez attendre que chaque
abonné ait terminé son abonnement avant de soumettre des requête d'abonnement
qui utilise ce noeud comme fournisseur. Si vous ne le faites pas, ce n'est pas
très grave : <command>slonik</command> va vérifier le noeud, découvrir qu'il 
n'est pas encore un fournisseur actif et reporter l'erreur suivante :
</para>

<programlisting>
 Slony-I: provider 2 is not an active forwarding node for replication set 1
</programlisting>

     <para> En pratique, de telles requêtes d'abonnement seront ignorées
jusqu'à ce que le fournisseur soit prêt.</para>
</warning>

     </listitem>

     <listitem><para> Modifier les informations d'abonnement pour les 
noeuds qui sont déjà abonnés. </para>

     <para> Si vous devez modifier les informations d'abonnement pour un 
noeud donné, vous devez <emphasis>également</emphasis> soumettre les 
nouvelles informations avec cette commande, et la nouvelle configuration sera
propagée à travers le réseau de réplication. En général, on modifier
les informations d'abonnement lorsque l'on veut abonner un noeud à un fournisseur
 <emphasis> différent </emphasis> ou transformer un noeud en <quote>transmetteur</quote>
afin qu'il puisse à son tour devenir le fournisseur d'un autre abonné.
</para>

     </listitem>
     </itemizedlist>

     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble auquel on s'abonne</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> PROVIDER = ival </literal></term>
       
       <listitem><para> Identifiant du noeud fournisseur qui transmet les données
à ce noeud.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> RECEIVER = ival </literal></term>
       
       <listitem><para> Identifiant du nouveau noeud abonné</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> FORWARD = boolean </literal></term>
       
       <listitem><para> Indique si le nouvel abonné doit stocker les logs
pendant la réplication afin de pouvoir devenir fournisseur pour de futurs 
noeuds.</para></listitem>

      </varlistentry>
     </variablelist>
    <para> Cette commande utilise &funsubscribeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SUBSCRIBE SET (
   ID = 1,
   PROVIDER = 1,
   RECEIVER = 3,
   FORWARD = YES
);
    </programlisting>
   </refsect1>

   <refsect1> <title> Transmission  </title>

    <para> Le paramètre <command>FORWARD=boolean</command> indique si le
l'abonné doit conserver les informations dans les tables
    &sllog1; and &sllog2;.  Ceci implique plusieurs choses...</para>

    <para>Stocker les données dans ces tables sur l'abonné représente
une charge supplémentaire. Si vous êtes certain(e) que vous n'effectuerez 
jamais les opérations <xref linkend="stmtmoveset"/> ou <xref
linkend="stmtfailover"/> sur un abonné particulier, il vaut mieux 
désactiver la transmission sur ce noeud.  </para>

    <para> Ceci étant, dans certains cas le fait de désactiver cette option
peut poser des problèmes lorsque l'on se trouve dans une situation inattendue.
De manière empirique, on considère qu'il préférable que <emphasis>tout 
noeud connecté directement à l'origine</emphasis> soit 
un <quote>noeud transmetteur </quote>. Il est possible que ce noeud
soit perdu lors d'une bascule d'urgence. Le problème survient lorsque
ce noeud est en avance sur les autres noeuds.</para>

    <para> Supposons que l'origine, le noeud 1, est au numéro de SYNC
88901, un noeud non-transmetteur, le noeud 2 en est arrivé au numéro
88897, tandis que les autres noeuds transmetteur, 3, 4, et 5, en sont
seulement au SYNC numéro  88895.  A ce moment, le disque système sur le
noeud origine prend feu.  Le noeud 2 possède les <emphasis>données</emphasis> à jour 
jusqu'à 88901, mais aucun noeud transmetteur ne dispose, dans les tables
 &sllog1; ou &sllog2;, des données correspondant
aux événements SYNCs numérotés 88896 et 88897. Il n'y a donc 
aucun moyen de ramener les noeuds 3-5 à ce niveau.</para>

    <para> À ce stade, vous avez deux choix : supprimer le noeud2, car il
n'existe aucun moyen de le maintenir, ou supprimer tous les noeuds 
<emphasis>sauf</emphasis> le noeud 2, car il n'existe aucun moyen de les 
amener jusqu'à l'événement SYNC 88897.</para>

    <para> Ce dilemme peut être évité en s'assurant que tous les noeuds directement 
abonnés à l'origine sont des transmetteurs. </para>

   </refsect1>
   <refsect1> <title> Comportement dangereux et non-intuitif </title>

   <itemizedlist>

     <listitem><para> Le fait que la requête se termine immédiatement
même si l'abonnement prend un temps considérable est parfois surprenant.
 </para> 

     <para> Le traitement des abonnements implique 
     <emphasis>deux</emphasis> événements; l'opération
     <command>SUBSCRIBE_SET</command>, initié sur le noeud fournisseur,
et une opération  <command>ENABLE_SUBSCRIPTION</command>, qui est 
initiée sur le noeud abonné. Cela signifie que <xref
     linkend="stmtwaitevent"/> ne peut pas attendre la fin d'une souscription.
Si vous souhaitez attendre la fin d'un abonnement, alors vous devez soumettre une
requête <xref linkend="stmtsync"/> et attendre que <emphasis>cet</emphasis> événement
s'achève.</para>
     </listitem>

     <listitem><para> Cette commande a <emphasis>deux</emphasis>
objectifs : mettre en place des abonnements ( ce qui n'est très surprenant )
et <emphasis>modifier des abonnements</emphasis>, ce qui n'est pas forcément
intuitif. </para> </listitem>

 <listitem><para> Les nouveaux abonnements sont définis en utilisant 
<command>DELETE</command> ou <command>TRUNCATE</command> pour vider
les tables sur l'abonné. Si vous avez créé un nouveau noeud en 
recopiant les données à partir d'un noeud existant, il peut <quote>paraître
évident</quote> que ces données seront conservées. Ce n'est pas le cas,
l'ancien contenu est détruit et le noeud est re-peupler <emphasis>à partir
de zéro</emphasis>.</para> </listitem>

   </itemizedlist>

   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette opération ne nécessite <emphasis>pas</emphasis> de verrous
sur le noeud fournisseur.</para>

    <para> Sur le noeud abonné, l'opération placera un verrou
sur toutes les table de l'ensemble de réplication. Dans la version
1.2, les verrous exclusifs sont placés au début du processus; dans les 
versions antérieurs, les verrous sont placés implicitement uniquement lorsque
qu'une activité le demande, ce qui laisse une possibilité d'inter-blocage
("deadlock") si d'autres applications peuvent accéder à la base à ce moment là.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtunsubscribeset"><refmeta><refentrytitle>UNSUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNSUBSCRIBE SET</refname>

    <refpurpose> Arrête la  réplication d'un ensemble de réplication &slony1; </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNSUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para> Cette commande interrompt la réplication d'un ensemble sur un abonné.
Les tables sont alors ouvertes en accès total aux applications clientes sur l'ancien 
abonné. Les tables ne sont pas détruites, ni modifiées. Tous les triggers originaux, les règles
et les contraintes sont restaurées.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble à désabonner</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> RECEIVER = ival </literal></term>
       
       <listitem><para> Identifiant de noeud de l' (ancien) abonné</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &fununsubscribeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNSUBSCRIBE SET (
   ID = 1,
   RECEIVER = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Des verrous exclusifs sont posés sur chaque table répliquées
de l'abonné afin de supprimer les triggers de réplication et de restaurer 
les anciens triggers/règles. </para>
   </refsect1>

   <refsect1><title> Comportement dangereux et non-intuitif </title>

     <para> Ré-abonner un ensemble désabonné nécessite une 
     <emphasis>copie fraîche et complète</emphasis> des données obtenue à partir
du noeud fournisseur, car les tables ont pu être soumises à des modifications
indépendantes.  </para>

   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

  
<!-- **************************************** -->

  <refentry id ="stmtlockset"><refmeta><refentrytitle>LOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>LOCK SET</refname>
    
    <refpurpose> Protège un ensemble de réplication &slony1; pour le 
préparer à un <command>MOVE SET</command>
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>LOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande protège un ensemble de réplication des mises à 
jour en provenance des applications clientes, en préparation d'une 
commande <xref linkend="stmtmoveset"/>.
    </para>

    <para> Cette commande doit être la première dans un groupe de commande <command>try</command>.
En effet, il faut <quote>committer</quote> les changements faits sur les tables
 (ajout d'une fonction trigger spéciale) avant d'attendre que toutes les 
transactions concurrentes se termine. En même temps, il ne faut pas
non plus garder une transaction ouverte sur la base elle-même car cela
cela signifierait qu'elle se bloque elle-même.
    </para>

    <para> Notons qu'il s'agit d'un opération &rlocking;, ce qui signifie qu'elle peut être
bloquer derrière d'autres activités de la base.</para>

    <para> L'opération attend que les identifiants de transaction avancent
afin qu'aucune donnée ne soient oubliées sur la nouvelle origine. Ainsi
si vous avez des transactions très longues en cours sur le noeud source, 
cette opération attendra que ces transactions aboutissent.
Malheureusement , si vous avez une autre base de données sur le même 
    postmaster du noeud origine, les transactions longues en cours
sur cette base seront aussi prises en compte même si elles sont par définition
indépendantes.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble à bloquer</para></listitem>
	 
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud TODO the current set origin</para></listitem>
	 
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funlockset;. </para>
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Des verrous exclusifs sont posés sur chaque table répliqué sur le noeud origine
    et des triggers qui rejettent les mises à jour sont ajoutés su chacune de ces tables
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtunlockset"><refmeta><refentrytitle>UNLOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNLOCK SET</refname>
    
    <refpurpose> Déverrouille un ensemble &slony1; qui est bloqué</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNLOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> 
     Cette commande déverrouille un ensemble préalablement vérrouillé.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble à déverrouiller</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud origine de l'ensemble</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &fununlockset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNLOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Des verrous exclusifs sont placés sur chaque table répliquée sur le noeud origine
    , car les triggers qui rejetent les mises à jour sont retirés de chacune des tables.
     </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtmoveset"><refmeta><refentrytitle>MOVE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MOVE SET</refname>
    
    <refpurpose> Change l'origine d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MOVE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande déplace l'origine d'un ensemble de réplication d'un noeud
    vers un autre. La nouvelle origine doit être un abonné de cet ensemble. L'ensemble
    doit être verrouillé sur l'ancien noeud origine.
    </para>
    
    <para> Après cette commande, l'ensemble ne peut plus être déverrouillé sur 
    l'ancienne origine. Celle-ci va continuer comme un noeud transmetteur
    de l'ensemble et la chaîne d'abonnement entre l'ancienne et la nouvelle origine
    sera inversée. Dès que la nouvelle origine a terminé le traitement de l'événement
    ( ce qui inclue tous les événements SYNC qui se sont produit avant la commande)
    elle prend le contrôle et ouvre toutes les tables de l'ensemble de réplication 
    aux mises à jour en provenance de l'application.
    </para>

    <para> Ceci n'est <emphasis>pas</emphasis> une bascule d'urgence, car cela nécessite
    que l'ancienne origine fonctionne correctement ( vous devez verrouiller l'ensemble 
    de réplication sur l'ancienne origine). Il est préférable d'utiliser 
    <command>MOVE SET</command> au lieu de <command>FAILOVER</command> si c'est possible
    , car la commande <command>FAILOVER</command> transforme le noeud origine en un 
    noeud corrompu. Avant d'effectuer un <command>MOVE SET</command>, il faut lancer la 
    commande <command>LOCK SET</command>.
</para>
     
    <para> Notez qu'il s'agit d'une opération &rlocking;, ce qui signifie qu'elle peut être bloquée
    derrière l'activité des autres bases.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble à transférer</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> OLD ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud origine actuel</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> NEW ORIGIN = ival </literal></term>
       
  <listitem><para> Identifiant du futur noeud origine</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funmoveset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 1
);
MOVE SET (
   ID = 1,
   OLD ORIGIN = 1,
   NEW ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Des verrous exclusifs sont posés sur chaque table répliquée
à la fois sur l'ancien noeud origine et le nouveau noeud origine, car 
les triggers de réplication sont changés sur les deux noeuds :
sur l'ancienne origine, chaque table supprime deux triggers 
(logtrigger et lockset) et ajoute un trigger denyaccess;
sur la nouvelle origine, le trigger denyaccess est supprimé et
le trigger logtrigger est ajouté. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtfailover"><refmeta><refentrytitle>FAILOVER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>FAILOVER</refname>
    
    <refpurpose> Cette commande bascule un ensemble de réplication 
en échec vers un noeud de secours.
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>FAILOVER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     La commande <command>FAILOVER</command> transfert tous les ensembles dont
l'origine est en panne vers le noeud de secours.
     <application>slonik</application> va contacter tous les autres noeuds directement
abonnés au noeud en panne pour déterminer quel noeud à le meilleur niveau de synchronisation
pour chacun des ensembles de réplication. Si un autre noeud a un niveau de synchronisation
plus élevé que le noeud de secours, la réplication sera d'abord redirigée pour que le noeud
de secours rattrape son retard sur l'autre noeud, puis qu'il assume le role d'origine
et reçoive les mises à jour.
    </para>

    <para>
     Après une bascule d'urgence réussie, tous les anciens noeuds abonnés directement 
au noeud en panne deviennent des abonnés direct du noeud de secours.
Le noeud en panne est abandonné, et doit être retiré de la configuration avec 
<xref linkend="stmtdropnode"/>.
    </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant du noeud en panne</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> BACKUP NODE = ival </literal></term>
      
      <listitem><para> Identifiant du noeud de secours qui va prendre en charge
les ensembles de réplication dont l'origine est le noeud en panne</para></listitem>

     </varlistentry>
    </variablelist>
    
    <para> Cette commande utilise &funfailednode;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
FAILOVER (
   ID = 1,
   BACKUP NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Des verrous exclusifs sont posés sur chaque table répliquée sur
le nouveau noeud origine, car les triggers de réplication sont changés.
Si la nouvelle origine n'est pas tout à fait à jour, et que des données 
doivent être rapatriées depuis à partir d'un autre noeud qui est mieux synchronisé,
alors la nouvelle origine ne sera pas utilisable avant que ces mises à jour
soient terminées.
     </para>
   </refsect1>
   <refsect1><title> Comportement dangereux et non-intuitif </title>
    <para> Cette commande va abandonner le noeud en panne.
Il n'y a pas de possibilité de réintégrer le noeud en panne,
sans le reconstruire à partir de zéro en tant qu'esclave.
Si c'est possible, il est préférable d'utiliser la commande 
     <xref linkend="stmtmoveset"/> , car elle n'abandonne
    <emphasis>pas</emphasis> le noeud en panne.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtddlscript"><refmeta><refentrytitle>EXECUTE SCRIPT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXECUTE SCRIPT</refname>
    
    <refpurpose> Exécute un script SQL/DDL  </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>EXECUTE SCRIPT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande exécutes un script contenant de ordres SQL sur 
tous les noeuds qui sont abonnés à un ensemble de réplication à un 
point précis dans le flux des transactions.</para>
    OA
    <para> L'origine de l'événement doit être l'origine de l'ensemble
de réplication. Le fichier de script ne doit pas contenir d'ordres 
<command>START</command> ou <command>COMMIT TRANSACTION</command>.
  (Ceci change un peu avec &postgres; 8.0 puisque les transactions imbriquées,
appelée également <quote>points de sauvegarde</quote> (<quote>
    savepoints</quote>, sont supportés.
De plus les ordres DML non déterministes (par exemple mettre a jour un 
champs avec la valeur  <function>CURRENT_TIMESTAMP</function>) doivent
être évitées, car les changements effectués par ce script ne sont pas
explicitement répliqués. </para>

    <variablelist>
     <varlistentry><term><literal> SET ID = ival </literal></term>

      <listitem><para> Le numéro unique de l'ensemble affecté par le script</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> FILENAME = '/chemin/vers/le/fichier' </literal></term>
      
      <listitem><para> Le nom du fichier contenant le script SQL à exécuter.
Il peut s'agir d'un chemin relatif à l'emplacement de l'instance <application>slonik</application>
que vous avez lancé, ou de préférence, un chemin absolu sur le système où 
 <application>slonik</application> est lancé.</para>
       
       <para> Le <emphasis>contenu</emphasis> de ce fichier est propagé dans un
événement, donc il n'est pas nécessaire que le fichier soit accessible depuis
les autres noeuds.
	</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> EVENT NODE = ival </literal></term>
      <listitem><para> (Optionnel) L'identifiant de l'origine courante du set.  La valeur par défaut est 1.</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> EXECUTE ONLY ON = ival

       </literal></term><listitem><para> (Optionnel) L'identifiant du seul noeud qui
doit exécuter le script.  Cette option implique que le script sera propagé
sur tous les noeuds mais exécuté sur un seul. 
Par défaut on exécute le script sur tous les noeuds abonnés à l'ensemble de réplication.
	</para></listitem> 
      
     </varlistentry>
    </variablelist>
    
    <para> Voir également les avertissements dans la section &rddlchanges;.</para>

    <para> Notons qu'il s'agit d'une opération &rlocking;,  ce qui signifie qu'elle peut être
bloquée par l'activité d'une autre base.</para>
     
    <para> Au démarrage de cet événement, toutes les tables répliquées sont
déverrouillées par la fonction <function>alterTableRestore(tab_id)</function>. 
Une fois le script SQL exécuté, elles sont remises en <quote>mode réplication
</quote> avec <function>alterTableForReplication(tab_id)</function>.  
Cela implique que toutes les tables sont verrouillées par ce processus 
&slon; pendant la durée du script SQL.</para>

    <para> Si les colonnes d'une table sont modifiées, il est très
important que les triggers soient régénérés, sinon ils peuvent 
être inadaptés à la nouvelle forme du schéma.
    </para>

    <para> Notez que si vous devez faire référence au nom du cluster,
vous pouvez utiliser l'alias <command>@CLUSTERNAME@</command>; 
si vous devez faire référence à l'espace de nom &slony1;,
vous pouvez utiliser l'alias <command>@NAMESPACE@</command>; 
les deux seront remplacés par la valeur appropriée. </para>

    <para> Cette commande utilise &funddlscript;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
EXECUTE SCRIPT (
   SET ID = 1,
   FILENAME = '/tmp/changes_2008-04-01.sql',
   EVENT NODE = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur les versions antérieures à la  branche 2.0, un verrou exclusif est posé 
sur chaque table répliquée sur le noeud origine, afin de retirer les triggers
de réplication; Une fois le script DDL achevé, ces verrous sont enlevés.
     </para>  
  
    <para> Une fois le script DDL exécuté sur le noeud origine, il est lancé sur les noeuds
abonnés, des verrous similaires sont posés sur tous les noeuds pour altérer 
les triggers des tables répliquées.
    </para>

    <para> À partir de la branche 2.0, &slony1; utilise un GUC qui contrôle
le comportement des triggers, ce qui permet de désactiver les triggers créer par 
&slony1; pendant l'opération  <emphasis>sans</emphasis> poser de verrous exclusifs sur
toutes les tables. Désormais, les seules tables qui sont verrouillées sont les tables
qui sont effectivement modifiée par le script DDL.
    </para>  
  
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0. </para>

    <para> Avant la version 1.2, l'ensemble du script DDL était soumis 
dans une requête <function>PQexec()</function>, ce qui impliquait que
le script <emphasis>tout entier</emphasis> était traité en se basant sur 
l'état de la base avant l'invocation du script. Cela signifie que 
des ordres placés à la fin d'un script ne pouvait pas dépendre d'un ordre
situé au début de ce même script. Ainsi, il n'était pas possible
d'ajouter un colonne dans une table, puis une contrainte sur cette 
colonne au sein du même script.
    </para>

    <para> Dans &slony1; version 1.2, le script  DDL est découpé par ordre par ordre,
et chaque ordre est soumis séparément. Cela implique, que les ordres de la fin
du script peuvent se référer aux objets ou aux attributs créer et modifié au début
du script.
De plus, dans la version 1.2, le résultat de sortie de<command>slonik</command>
contient la liste de ordre au fur et à mesure de leur traitement sur le noeud
d'origine de l'ensemble de réplication. De même, les ordres traités sont listés
dans les logs de slon sur les autres noeuds.
    </para>

    <para> Dans &slony1; version 1.0, cette commande verrouille uniquement les tables
de l'ensemble spécifié. À partir de la version 1.1, <emphasis>toutes
les tables répliquées</emphasis> sont verrouillées (<emphasis>c'est à dire</emphasis>
que les triggers sont retirés au départ, et restaurés à la fin).
Ceci couvre les risques lorsqu'on lance une requête de changements DDL
sur des tables appartenant de plusieurs ensemble de réplication.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtupdatefunctions"><refmeta><refentrytitle>UPDATE FUNCTIONS</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>UPDATE FUNCTIONS</refname>
    
    <refpurpose> Recharge les fonctions stockées </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UPDATE FUNCTIONS (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande recharge les fonctions stockées pour un noeud.</para>
    
    <para>Elle restaure toutes les procédures stockées et les définitions de fonctions dans 
le schéma &slony1; pour un noeud donné. Cette commande fait habituellement partie des
procédure de mise à jour logicielles.
    </para>

     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Le noeud à rafraîchir.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UPDATE FUNCTIONS (
    ID = 3        # Update functions on node 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
   <refsect1> <title> Bizarreries </title>

    <para> Toute incohérence entre <xref linkend="slonik"/> et la librairie C
    <quote>résidant</quote> dans l'installation de &postgres; empêchera le
bon fonctionnement de l'ensemble et provoquera probablement une panne.
Vous pouvez <emphasis>penser</emphasis> que vous mettez à jour à la version
1.1.5, mais si vous êtes en train d'utiliser la version 1.1.2, ou si vous
n'avez pas redémarrer la base avec une version qui a les librairies 1.1.5,
et que vous référencer des fonctions stockées en C de la version 1.1.1,
la tentative de mise à jour va échouer, car les ensembles de fonctions C
sont régulièrement modifié entre les versions majeures.
    </para>

    <para> Avant &slony1; 1.2, le message d'erreur affiché n'était pas 
très informatif. ce qu'on trouvait dans les logs de  &postgres; était une
erreur signalant l'impossibilité de charger des functions stockées implémentées
en C. À partir de la version 1.2, une des premières actions effectuées est 
le chargement d'un fonction stocker pour vérifier les numéros de versions;
Un message bien plus clair est affiché si vous utiliser des versions non 
cohérentes.
     </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtwaitevent"><refmeta><refentrytitle>WAIT FOR EVENT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>WAIT FOR EVENT</refname>
    
    <refpurpose> Demander à un script Slonik d'attendre que l'événement précédent s'achève</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>WAIT FOR EVENT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande attend une confirmation d'événement.</para>
    
    <para> <application>Slonik</application> se souvient du dernier événement 
généré sur chaque noeud pendant l'exécution d'un script ( les événements produits 
lors des appels précédents ne sont pas vérifiés). Dans certaines situations
il est nécessaire que des événements générés sur un noeud (tel que 
 <command>CREATE SET</command>) soient traités sur un autre noeud avant de 
lancer d'autres commandes (par exemple, <xref
      linkend="stmtsubscribeset"/>).  
<command>WAIT FOR EVENT</command> peut être utilisé pour demander à un 
script <application>slonik</application> d'attendre jusqu'à ce que le noeud abonné
soit prêt pour l'action suivante.
    </para>
    
    <para> <command>WAIT FOR EVENT</command> doit être appelée en dehors d'un
bloc <command>try</command>, car les nouveaux messages de confirmation ne sont 
pas visibles à l'intérieur d'une transaction.

     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival | ALL </literal></term>
       <listitem><para> L'origine de l'événement qu'il faut attendre.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> CONFIRMED = ival | ALL </literal></term>
       
       <listitem><para> L'identifiant du noeud récepteur qui doit confirmer le(s)
événement(s).
</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> WAIT ON = ival </literal></term>
       <listitem><para> L'identifiant du noeud ou la table  &slconfirm; est vérifiée.
La valeur par défaut est 1.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TIMEOUT = ival </literal></term>
       
       <listitem><para> Le nombre de secondes d'attente. La valeur par défaut est 600
       (10 minutes).  <command>TIMEOUT = 0</command> implique que le script attend 
indéfiniment.</para></listitem>
       
      </varlistentry>
     </variablelist></para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
WAIT FOR EVENT (
  ORIGIN = ALL,
  CONFIRMED = ALL,
  WAIT ON = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
   
   <refsect1> <title> Bizarreries </title> 
<para> Tous les événements ne retournent pas forcément des résultats intéressants.
Par exemple, beaucoup de gens ont rencontré énormément de problèmes avec
<xref linkend="stmtsubscribeset"/>, lorsqu'il abonnait un nouvel ensemble.
Soyez conscient que  la requête <xref linkend="stmtsubscribeset"/> va retourner
la confirmation d'événement presque immédiatement, même si il reste plusieurs heures 
de travail avant que l'abonnement soit achevé. Le problème avec
 avec   <xref linkend="stmtsubscribeset"/> est qui est traité par
<emphasis>deux</emphasis> événements, un sur le noeud origine, et un second événement
 qui met en place l'abonnement sur l'abonné.
   </para>

   <para> Afin surveiller plus étroitement à l'intérieur du script <xref
   linkend="slonik"/> que l'instruction <xref linkend="stmtsubscribeset"/> 
est complète, vous pouvez soumettre un événement <xref linkend="stmtsync"/>
après l'abonnement, et lancer une requête WAIT sur ce 
   <command>SYNC</command>, de la manière suivante : </para>
    <programlisting>
     # Supposons que l'ensemble 1 a deux abonnés direct 2 et 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrepairconfig"><refmeta><refentrytitle>REPAIR CONFIG</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>REPAIR CONFIG</refname>
    
    <refpurpose> Remet à zéro les tables de correspondance entre les noms et les OID pour un
ensemble de réplication, utile lorsque l'on restaure un noeud après un 
<application>pg_dump</application>. </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>REPAIR CONFIG (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Remet à zéro la correspondance entre noms et OIDs.</para>
    
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Le numéro de l'ensemble à nettoyer.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> L'identifiant du noeud ou la commande doit être soumise.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EXECUTE ONLY ON = ival </literal></term>

       <listitem><para> L'identifiant du seul noeud ou la correspondance est mise à jour
. Si cette valeur n'est pas précisée, par défaut on exécute la commande sur tous les noeuds abonnés
à l'ensemble.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
REPAIR CONFIG (
  SET ID = 1,
  EVENT NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>
<!-- **************************************** -->

  <refentry id="stmtsync"><refmeta><refentrytitle>SYNC</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SYNC</refname>
    
    <refpurpose> Cette commande produit un événement SYNC ordinaire </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SYNC (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Cette commande génère un événement SYNC sur un noeud donné.</para>
    
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> Le noeud sur lequel on génère l'événement SYNC.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SUBSCRIBE SET (ID = 10, PROVIDER = 1, RECEIVER = 2);
     WAIT FOR EVENT (ORIGIN = 2, CONFIRMED = 1);
     SYNC (ID = 1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verrouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  
  <refentry id ="stmtsleep"><refmeta><refentrytitle>SLEEP</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SLEEP</refname>
    
    <refpurpose> S'endormir avec la fonction système <function>sleep()</function> </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>sleep </command>
     <arg><replaceable class="parameter"> seconds</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Cette commande endors les opérations pendant un certain nombre de secondes.
    </para>
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <programlisting>
     sleep (seconds = 5);
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1. </para>
   </refsect1>
  </refentry>

  <refentry id ="stmtcloneprepare"><refmeta><refentrytitle>CLONE PREPARE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLONE PREPARE</refname>
    
    <refpurpose> Prepare le clonage d'un node. </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>clone prepare </command>
     <arg><replaceable class="parameter"> id</replaceable></arg>
     <arg><replaceable class="parameter"> provider</replaceable></arg>
     <arg><replaceable class="parameter"> comment</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Cette commande prépare le clonage d'un noeud donné.
    </para>

    <para>
     Ceci duplique la configuration d'un noeud <quote>fournisseur</quote>
     sous un nouvel identifiant en préparation de la copie de ce noeud
     via un outil standard.
    </para>

    <para> Notez que pour être certain que ce nouveau noeud est cohérent avec 
tous les noeuds, il est important de lancer un événement SYNC sur tous les 
noeuds à l'exception du fournisseur et d'attendre que tous ces événements
SYNC soient confirmés avant de copier la base fournisseur.
Sinon il est possible que le clone est raté des événements.
     </para>

   </refsect1>
   <refsect1><Title>Exemple</Title>
    <Programlisting>
     clone prepare (id = 33, provider = 22, comment='Clone 33');
     sync (id=11);
     sync (id=22);
     </Programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.2.0. </para>
   </refsect1>
  </refentry>


  <refentry id ="stmtclonefinish"><refmeta><refentrytitle>CLONE FINISH</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLONE FINISH</refname>
    
    <refpurpose> Termine le clonage d'un noeud. </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>clone prepare </command>
     <arg><replaceable class="parameter"> id</replaceable></arg>
     <arg><replaceable class="parameter"> provider</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Cette commande achève le clonage sur un noeud donné.
    </para>

    <para>
     Ceci complète le travail effectué par  <xref
     linkend="stmtcloneprepare"/>, en établissant les données de confirmation
pour le nouveau <quote>clone</quote> à partir du statut trouvé pour le 
noeud <quote>fournisseur</quote>.
    </para>
   </refsect1>
   <refsect1><Title>Exemple</Title>
    <Programlisting>
     clone finish (id = 33, provider = 22);
    </Programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.2.0. </para>
   </refsect1>
  </refentry>

  
 </reference>
