<?xml version="1.0" encoding="UTF-8"?>
<!-- Dernière modification
     le       $Date$
     par      $Author$
     révision $Revision$ -->

<article id="slonikref">
<title>Tour d'horizon des commandes Slonik</title>
   <sect1><title>Introduction</title>
    
    <para>
     <application>Slonik</application> est un utilitaire en ligne de commande
     conçu spécifiquement pour mettre en place et modifier la configuration 
     d'un système de réplication &slony1;.
    </para>
   
   <sect2 id="outline">
    <title>Considérations générales</title>
    
    <para>
     L'utilitaire en ligne de commande <application>slonik</application>
     est suppposé être intégré dans des scripts shell et lit 
     les commandes à partir d'un fichier ou de stdin ( voir plus 
     bas pour des exemples ). Presque tout le travail de configuration
      <emphasis>réel</emphasis> est effectué en appelant des procédures
      stockées après avoir chargé la base de support &slony1; dans 
      la base de données. Vous pouvez trouver de la documentation sur
      ces procédures dans le chapitre <ulink url="schemadoc">&slony1;
     Documentation du Schéma</ulink>, ainsi que dans les commentaires
     qui sont associé aux procédures dans la base de données.
    </para>

    <para>
     <application>Slonik</application> a été créé car:
     <itemizedlist>
      
      <listitem><para>Les procédures stockées ont des besoin d'informations
	  spécifiques telles que l'identifiant du noeud de réplication 
	  sur lequel elles sont appelées;</para></listitem>
      
      <listitem><para>L'absence de paramètres nommés dans les 
	  procédures stocées rend difficile de faire cela depuis
	  l'invite de commande 	<application>psql</application>;
	  </para></listitem>
      
      <listitem><para><application>psql</application>n'a pas la possibilité
	  de maintenir plusieurs connexions avec des transactions ouvertes.
	  </para></listitem>
     </itemizedlist>
    </para>
    <para>
     
    </para>
    <sect3><title>Commandes</title>
     <para>
      Le format du langage de commande slonik est libre.
      Les commandes commence par des mots-clefs et sont terminées
      par un point-virgule. La pluspart des commande ont une liste de 
      paramètres, certains ont une valeur par défaut et sont donc 
      facultatifs. Les paramètres de commandes sont entourés par des
      parenthèses. Chaque option est constituée d'un ou plusieurs
      mots-clefs, suivis d'un symbole égal, suivi d'une valeur. Les 
      optons multiples à l'intérieur de parenthèses sont séparées par
      des virgules. Tous les mot-clefs sont sensibles à la casse. Le
      langage devrait rappeler le SQL.
     </para>
     <para>
      Les valeurs d'option peuvent être :
      <itemizedlist>
       <listitem><para>des entiers;</para></listitem>
       <listitem><para>des chaines caractères entourés de quotes;</para></listitem>
       <listitem><para>des valeurs booléennes  {TRUE|ON|YES} ou {FALSE|OFF|NO};</para></listitem>
       <listitem><para>des mots-clefs dans des cas spécifiques</para></listitem>
      </itemizedlist>
     </para></sect3>
    <sect3><title>Commentaires</title>
     <para>
      Les commentaires commencent par un dièse (#) et vont jusqu'à la fin de la ligne.
     </para></sect3>
    <sect3><title>Groupes de commandes</title>
     <para>
      Les commandes peuvent être combinées par groupes de commandres avec une 
      éventuellement une condition <command>on error</command> et 
      <command>on success</command>. 
      La syntaxe est la suivante :
      <programlisting>
       try {
       commands;
       } 
       [on error { commands; }
       [on success { commands; }
      </programlisting></para>

     <para> Ces commandes sont regroupées ensemble au sein d'une transaction
       pour chaque noeud participant.</para>
<!-- ************************************************************ --></sect3></sect2></sect1></article>

 <reference id="metacmds">
  <title>Meta-commandes Slonik</title>
  <partintro>
   <para>
     Les commandes suivantes sont utilisées pour séparer
     les définitions des composants des scripts Slonik;
      <xref linkend="stmtinclude"/> regroupe la configuration 
      dans des fichiers centraux qui peuvent être réutilisés, et 
      <xref linkend="stmtdefine"/> permet de remplacer les identifiants
      numérique et esotérique des objets par des identifiants mnémotechniques.
   </para>
  </partintro>
  <!-- **************************************** -->
  <refentry id ="stmtinclude"><refmeta><refentrytitle>INCLUDE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
  
   <refnamediv><refname>INCLUDE</refname>
    
    <refpurpose> insérer du code slonik à partir d'un autre fichier </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>include </command>
     <arg><replaceable class="parameter"> &lt;chemin&gt;</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
      Ceci injecte le script slonik spécifié à l'intérieur du script actuel.
      Si le <option>chemin</option> est relatif, <xref linkend="slonik"/> 
      cherchera à partir du répertoire de travail.
    </para>

    <para>
      Les inclusions imbriquées sont supportées. Le scanner et l'analyser
      retourne le bon nom de fichier et le numéro ligne correcten cas
      d'erreur.
       </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     include &lt;/tmp/preamble.slonik&gt;;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>
  <!-- **************************************** -->
  <refentry id ="stmtdefine"><refmeta><refentrytitle>DEFINE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DEFINE</refname>
    
    <refpurpose> Définir un nom symbolique </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>define </command>
     <arg><replaceable class="parameter"> nom </replaceable></arg>
     <arg><replaceable class="parameter"> valeur </replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
      Ceci définit un nom symbolique. Les noms symboliques doivent
      respecter les règles de slonik en matière de construction d'identifiant,
      en commençant par une lettre, suivie de lettres, de nombres et de soulignés ("_").
    </para>

    <para>
      Les valeurs des noms symboliques peuvent contenir des espaces et peuvent contenir
      des références à des noms symboliques, de manière récursive.
    </para>

    <para>
      Les symboles sont réferencés en utilisant une arobase <quote>@</quote> suivi
      du nom symbolique. Notons que le référencement d'un symbole est annulé
      à l'intérieur des chaines de caractères.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
define    cluster films;
define    sakai   1;
define    chen    2;
define    fqn     fully qualified name;

cluster name = @cluster;
node @sakai admin conninfo = 'service=sakai-replication';
node @chen  admin conninfo = 'service=chen-replication';
define setFilms    id = 1;
define sakaiFilms  @setFilms, origin = @sakai;

create set ( @sakaiFilms, comment = 'films' );

set add table( set @sakaiFilms, id = 1, @fqn = 'public.clients', 
               comment = 'sakai customers' );
set add table( set @sakaiFilms, id = 2, @fqn = 'public.cassettes',     
               comment = 'sakai cassettes' );
echo '@sakaiFilms sera affiché comme une chaine, et ne sera pas interprété';
    </programlisting>
   </refsect1>

   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>

 </reference>  
  
<!-- **************************************** -->

 <reference id="hdrcmds"> 
  <title>Commandes slonik préliminaires</title>
  <partintro>
   <para>
    Les commandes suivantes doivent apparaître en <quote>préambule</quote> au
    de chaque script de commande <application>slonik</application>. 
    Ils ne provoque aucune action directement sur les noeuds du 
    système de réplication, mais affecte l'exécution du script tout entier.
   </para>
  </partintro>
  <!-- **************************************** -->
  
  <refentry id ="clustername"><refmeta><refentrytitle>CLUSTER NAME</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLUSTER NAME</refname>
    
    <refpurpose> préambule - identifier le cluster &slony1; </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>CLUSTER NAME = </command>
     <arg><replaceable class="parameter"> nom;</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Ceci doit être la toute première ligne de chaque script
     <application>slonik</application>. Elle définit l'espace
     de nom dans lequel toutes les fonctions spécifiques, les procédures,
     les tables et les séquences de &slony1; sont déclarées.
     Le nom de l'espace de nom est construit en préfixant le chaine
     de caractère fournie par un souligné. Ce nom d'espace sera 
     identique sur toutes les bases de données qui participent 
     aux même groupe de réplication.
    </para>
    
    <para>
     Aucun objet utilisateur n'est supposé être placé dans cet espace de nom,
     et l'espace de nom ne doit exister avant l'ajout de la base de données
     dans le système de réplication. Ainsi, si vous ajouter un nouveau noeud
     en utilisant <command> pg_dump -s </command> sur une base qui est déjà 
     dans le cluster de réplication, vous devrez supprimer l'espace de nom
     avec la commande SQL<command> DROP SCHEMA _testcluster CASCADE; </command>.
    </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     CLUSTER NAME = testcluster;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
  
<!-- **************************************** -->

  <refentry id ="admconninfo"><refmeta><refentrytitle>ADMIN CONNINFO</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>ADMIN CONNINFO</refname>
    <refpurpose> preambule - identifier la base &postgres;</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>NODE ival ADMIN CONNINFO = 'DSN';</command>
     <arg><replaceable class="parameter"> ival;</replaceable></arg>
     <arg><replaceable class="parameter"> 'conninfo'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Décrit comment l'utilitaire <application>slonik</application> peut
     atteindre les bases des noeuds du cluster à partir du l'endroit
     où il se trouve (en général le poste de travail de l'administrateur)
     La chaine connifo est l'argument passé à la fonction 
     libpq <function>PQconnectdb()</function>. L'utlisateur qui se connecter
     doit être un super-utilisateur spécifique à la réplication, car certaines
     actions réalisées par la suite comprennent des opérations strictement réservées
     aux super-utilisateurs du serveur  &postgres;.
    </para>

    <para>
     L'utilitaire <application>slonik</application> n'essaie pas de se connecter
     à une base de donnnée que si un commande nécessite une connexion.
    </para>

   <note> <para>
     Comme indique dans les document originaux, &slony1; est conçu comme 
     une système de réplication d'entreprises pour datacenters. Lors du développement
     du logiciel, on présuppose que les serveurs de bases de données et les postes
     de travail impliqués dans la réplication et/ou dans les activités de mise en place et 
     de configuration peuvent utiliser des méthodes simples d'authentification telle que
     <quote>trust</quote>.  Cependant, libpq peut lire les mots de passe dans le fichier
     <filename> .pgpass </filename>.
    </para>
   </note>
   <note>
    <para>
    Si vous devez changer les informations DSN pour un noeud, par exemple si 
    l'adresse IP d'un hôte est modifiée, vous devez soumettre cette nouvelle
    information avec la commande  <xref linkend="stmtstorepath"/>,
    et la configuration sera propagée. Certains processus 
     <application> slon </application> existant devront être relancés afin qu'il 
     soient avertis de ce changement de configuration.
    </para>
   </note>

   <para>Pour plus de détails sur la distinction entre ceci et <xref
   linkend="stmtstorepath"/>, consultez le chapitre &rplainpaths;.</para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
 </reference>
<!-- ************************************************************ -->
 
<!-- **************************************** -->
 <reference id="cmds">
  <title>Commande de configuration et d'action</title>
<!-- **************************************** -->
  
  <refentry id ="stmtecho"><refmeta><refentrytitle>ECHO</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>ECHO</refname>
    
    <refpurpose> Outil générique de sortie </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>echo </command>
     <arg><replaceable class="parameter"> 'message'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Affiche un message litéral sur la sortie standard.
    </para>
   </refsect1>
   <refsect1><Title>Example</Title>
    <programlisting>
     ECHO 'Noeud 1 initialisé correctement';
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
  <!-- **************************************** -->
  
  <refentry id ="stmtexit"><refmeta><refentrytitle>EXIT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXIT</refname>
    
    <refpurpose> Termine un script Slonik avec un signal </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>exit</command>
     <arg><replaceable class="parameter"> [-]ival</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     termine immédiatement un script d'éxecution, annulant toute
     les transaction ouverte (roll back) sur toutes les bases de données
     connectées. L'utilitaire <application>slonik</application> retournera
     la valeur indiquée comme code de terminaison du programme.
    </para>
   </refsect1>
   <refsect1><Title>Example</Title>
    <programlisting>
     EXIT 0;
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

  <!-- **************************************** -->
  <refentry id="stmtinitcluster">
   <refmeta>
    <refentrytitle>INIT CLUSTER</refentrytitle>
     <manvolnum>7</manvolnum>
   </refmeta>
   <refnamediv>
    <refname>INIT CLUSTER</refname>
    <refpurpose>Initialise le cluster &slony1;</refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>INIT CLUSTER</command> 
     <arg>ID = <replaceable class="parameter">entier</replaceable></arg>
     <arg>COMMENT = <replaceable class="parameter">'chaine'</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title> 

    <para> Initialise le premier noeud d'un nouveau cluster de réplication &slony1;.
    Le processus d'initialisation consiste à créer l'espace de nom du cluster,
    charger toutes les tables, les functions, les procédures et initialiser le noeud
    avec  &funinitializelocalnode; and &funenablenode;.
     
     <variablelist>
      <varlistentry><term><literal>ID</literal></term>
       <listitem><para>L'identifiant numérique et unique du noeud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal>COMMENT = 'commentaire'</literal></term> 
	<listitem><para> Un texte descriptif ajouté à la ligne du  noeud dans
	    la table &slnode;. 
      </para></listitem>
      </varlistentry>
     </variablelist>
     
    </para>
    
    <para> Pour que ce processus fonctionne, les scripts SQL du système 
      &slony1; doivent être installés sur le poste de travail de l'administrateur
      (l'ordinateur utilisé pour exécuter l'utilitaire <application>slonik</application>),
      tandis que sur le serveur qui héberge le noeud de base de donnée contenant les
      objets partagés, &slony1; doit être installé dans le répertoire qui contient 
      les librairies de &postgres;. De plus le langage procédural
    PL/pgSQL dit être installé au préalable sur la base de données cible.
    </para>
   </refsect1>
   <refsect1>
    <title>Exemple</title>
    <programlisting>
INIT CLUSTER (
   ID = 1,
   COMMENT = 'Noeud 1'
);
    </programlisting>

   <note> <para> Cette commande fonctionne de manière similaire à 
       <xref linkend="stmtstorenode"/>, la différence étant que <command>INIT
   CLUSTER </command> n'a pas besoin de récupérer la configuration des autres noeuds.
   </para> </note>
   <note> <para> Soyez conscients que certains objets qui sont créés contiennet
       le nom du cluster à l'intérieur de leur nom  (Notamment, les index
       partiels sur <envar>sl_log_1</envar> et <envar>sl_log_2</envar>).
       Ceci implique que les noms de cluster <emphasis>très longs</emphasis>
       sont une mauvaise idée, car ils entrainent un dépassement des noms 
       d'objets au delà de la limite de 63 caractères.
     </para> </note> 
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette commande crée un nouvel espace de noms et configure les
      tables à l'intérieur; aucun objets public ne doit être verrouiller
      pendant l'exécution de cette commade.</para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id ="stmtstorenode"><refmeta><refentrytitle>STORE NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE NODE</refname>
    <refpurpose> Initialis un noeud &slony1;</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Initialise un nouveau noeud et l'ajoute dans la configuation du 
      cluster existant.</para>

    <para> Le processus d'initialisation consiste à la création de l'espace
      de noms sur le nouveau noeud ( la base elle-même doit déjà exister ),
      charger les tables, les fonctions, les procédures et initialiser le 
      noeud. La configuration existante du reste du noeud est copiée à 
      partir d'un <quote>node d'événement</quote>.
     
     <variablelist>
      <varlistentry><term><literal>ID = ival</literal></term>
      <listitem><para> L'identifiant numérique et unique du nouveau noeud.</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal> COMMENT = 'description' </literal></term>
       <listitem><para> Un texte descriptif ajouté à la ligne du noeud dans
	   la table &slnode;</para></listitem>
      </varlistentry>
      
      <varlistentry><term><literal> SPOOLNODE = booléen </literal></term>
       
       <listitem><para>Spécifie qu'un noeud est un noeud virtuel de récupération
	   pour l'archivage de journaux de réplication. Si ce paramètre est à true
	   <application>slonik</application> n'essaiera pas d'initialiser la base de 
	   donnée avec le schéma de réplication.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> L'identifiant du noeud utilisé pour créer l'évenement de configuration,
	   qui prévient tous les noeuds existants de l'arrivée du nouveau noeud.
	   La valeur par défaut est 1.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Ceci utilise &funinitializelocalnode; et &funenablenode;. </para>
    
   </refsect1>
   <refsect1><Title>Example</Title>
    <programlisting>
     STORE NODE ( ID = 2, COMMENT = 'Noeud 2');
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette commande crée un nouvel espace de nom et configure les tables
      à l'intérieur;aucun objets public ne doit être verrouiller
      pendant l'exécution de cette commade.</para>
   </refsect1>

   <refsect1> <title> Note de version </title> 
     <para> Cette commande fut intorduite dans &slony1; 1.0.  La paramètre <envar>SPOOLNODE</envar>
     fut intrduit dans la version 1.1, mais n'était pas implémentée dans cette version.
     La fonctionnalité <envar>SPOOLNODE</envar> est arrivée dans la
   version 1.2. </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtdropnode"><refmeta><refentrytitle>DROP NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP NODE</refname>
    
    <refpurpose> Supprime un noeud de la réplication </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un noeud. Cette commande retire complètement le noeud spécifié 
     de la configuration du système de réplication.
     Si le démon de réplication est toujours en fonctionnement sur ce noeud
     (et qu'ils traitent les événements), il tentera de désinstaller le système
     de réplication et s'arrêtera de lui-même.

     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> L'indentifiant du noeud à supprimer.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       <listitem><para> L'identifiant du noeud qui génère l'événement. La valeur par défaut est 1.
       </para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Cette commande utilise &fundropnode;. </para>

    <para> Quand vous invoquez <command>DROP NODE</command>, une des étapes
      consiste à lancer <command>UNINSTALL NODE</command>.</para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Lorsqu'on supprime des triggers d'une table de l'application,
      cela nécessite un accès exclusif à chaque table répliquée sur le noeud
      que l'on supprime.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para> Si vous utiliser des connexions qui cachent les plans d'éxécution
   (ce qui est particulièrement commun pour framework applicatifs Java utilisant
   de pools de connexion pools), les connexions peuvent cacher des plans
   de reques qui se base sur une vision pré-<command>DROP NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>

   <para>Ainsi après avoir supprimé un noeud, il est préférable de réinitialiser
     les connexions de votre applications.</para>

   <para> Vous ne pouvez pas soumettre cela à un <command>EVENT
   NODE</command> ayant le même numéro que le noeud que vous supprimez;
   la requête doit aller vers un noeud qui restera dans le cluster.
   </para>
   </refsect1>

   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  <refentry id="stmtuninstallnode"><refmeta><refentrytitle>UNINSTALL NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNINSTALL NODE</refname>
    
    <refpurpose> Désinstaller un noeud &slony1; </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNINSTALL NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Restaure toutes les tables dans leur état non verrouiller, avec 
      les triggers d'origines, les contraintes et les règles, les éventuelles colonnes
      spécifiques de &slony1; contenant des clefs SERIAL sont supprimées.
      et le schéma  &slony1; est effacé. Le noeud redevient une base de données
      indépendante. Les données ne sont pas modifiées.   
     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> Identifiant du noeud à désinstaller.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para> Cette commande utilise &fununinstallnode;. </para>

    <para> La  différence entre <command>UNINSTALL NODE</command>
    et <command>DROP NODE</command> est que <command>UNINSTALL
    NODE</command> se contente de supprimer la configuration &slony1;;
    il ne retire la configuration du noeud sur l'ensemble de réplication.
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  UNINSTALL NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Lorsque l'on supprime les triggers off des tables de l'application,
      cela nécessite un accès exclusif sur chaque table répliquée sur le noeud
      que l'on désinstallé.</para>
   </refsect1>
   <refsect1><title>Comportement dangereux ou non-intuitif</title>
   <para> Si vous utiliser des connexions qui cachent les plans d'éxécution
   (ce qui est particulièrement commun pour framework applicatifs Java utilisant
   de pools de connexion pools), les connexions peuvent cacher des plans
   de reques qui se base sur une vision pré-<command>UNINSTALL NODE</command>,
   ce qui implique que vous obtiendrez des &rmissingoids;.</para>   

   <para>Ainsi après avoir désinstallé un noeud, il est préférable de réinitialiser
     les connexions de votre applications.</para>   
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrestartnode"><refmeta><refentrytitle>RESTART NODE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>RESTART NODE</refname>

    <refpurpose> Redémarre un noeud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>RESTART NODE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Provoque l'arrêt et le redémarrage d'un démon 
      de réplication sur le noeud spécifié 
      Théoriquement, cette commande est obsolète. En pratique,
      les timeouts TCP peuvent retarder les changements critiques 
      de configuration jusqu'à ce qu'il soit effectué alors que le
      noeud expéditeur est en echec et doit être ignoré par les 
      noeuds abonnés.     
     <variablelist>
      <varlistentry><term><literal> ID  = ival </literal></term>
       <listitem><para> Identifiant du noeud à redémarrer.</para></listitem>
      </varlistentry>
     </variablelist>
    </para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  RESTART NODE ( ID = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>


    <para> Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0;
      Elle ne devrait plus être nécessaire à partir de la version 1.0.5. </para>
   </refsect1>
  </refentry>
  

  <!-- **************************************** -->

  <refentry id="stmtstorepath"><refmeta><refentrytitle>STORE
     PATH</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE PATH</refname>
    
    <refpurpose> Configure la connexion d'un noeud &slony1;</refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Configure comment le démon de réplication d'un noeud se 
      connecte à la base de données d'un autre noeud. Si le système
      de réplication est supposé utiliser un segment spécial de réseau,
      c'est ici qu'on définit les adresses IP ou les noms d'hôtes.
      Un configuration existante peut-être écrasée.
      </para>
    
    <para> Le paramètre conninfo doit contenir toutes les informations
      pour se connecter à la base en tant super-utilisateur de la répliction.
      Les termes <quote>serveur</quote> or <quote>client</quote> n'ont
      rien à voir avec le rôle particulier d'un noeud dans la configuration
      d'un cluster. On peut simplement voir cela comme un 
      <quote>serveur</quote> ayant un message or un donnée qu'un 
      <quote>client est supposé obtenir</quote>.
      Pour une installation simple avec 2 noeuds, les chemins dans les deux 
      directions doivent être configurés.
    </para>
    <para> Il ne pose aucun problème de configurer un chemin entre chaque 
      noeud. ( produit en croix complète ).Les connexions ne sont établit que 
      si cela est nécessaire pour transférer un événement ou une confirmation
      à cause des entrées <emphasis>listen</emphasis> ou une donnée à cause de
     <emphasis>souscriptions</emphasis>.
     
     <variablelist>
      <varlistentry><term><literal> SERVER  = ival </literal></term>
       <listitem><para> Identifiant du noeud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CLIENT  = ival </literal></term>
       <listitem><para> Identifiant du noeud du démon de réplication qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CONNINFO  = string </literal></term>
       <listitem><para> Argument <function>PQconnectdb()</function> pour établir la connexion.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CONNRETRY  = ival </literal></term>
       <listitem><para> Nombre de secondes d'attente avant qu'un autre tentative
	   de connexion soit faite dasn le cas ou le serveur est indisponible. 
	   La valeur par défaut est 10.
	</para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funstorepath;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
STORE PATH ( SERVER = 1, CLIENT = 2, 
             CONNINFO = 'dbname=testdb host=serveur1 user=slony'
           );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>


    <para> Aucun verouillage ne devrait être visible depuis l'application. </para>     
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdroppath"><refmeta><refentrytitle>DROP PATH</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP PATH</refname>
    
    <refpurpose> Supprime un chemin de connexion &slony1; </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP PATH (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Supprime les informations de connexion entre un <quote>serveur</quote> et
     <quote>client</quote>.</para>
     
     <variablelist>
      <varlistentry><term><literal> SERVER  = ival </literal></term>
       <listitem><para> Identifiant du noeud de la base à laquelle on doit se connecter.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> CLIENT  = ival </literal></term>
       <listitem><para> Identifiant du noeud du démon qui se connecte.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> L'identifiant du noeud utilisé pour créer l'événement de configuration
	qui annonce à tous les noeuds existants que le chemin a été supprimé. 
	La valeur par défaut est l'identifiant du noeud <quote>client</quote>.
	</para></listitem>
      </varlistentry>
      </variablelist>
      </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP PATH ( SERVER = 1, CLIENT = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous</title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtstorelisten"><refmeta><refentrytitle>STORE LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>STORE LISTEN</refname>
    
    <refpurpose> Configure un noeud &slony1; en lui indiquant où il 
      doit écouter les événements </refpurpose></refnamediv>
    
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Pour chaque entrée <quote>listen</quote>, le noeud récepteur demande
      à un noeud fournisseur de lui envoyer les événements d'un autre noeud
      ainsi que les confirmations en provenance des tous les autres noeuds existants.
      Cela nécessite qu'un <quote>chemin</quote> doit exister pour
      que le recepteur (le client) puisse se connecter au fournisseur (le serveur).</para>

    <para> Chaque noeud du système doit écouter les événements
      de tous les autres noeuds. En règle générale, un abonné
    other node in the system. As a general rule of thumb, a subscriber
    (voir <xref linkend="stmtsubscribeset"/>) doit écouter les événements
    d'un ensemble origine sur un fournisseur unique, qui lui envoie
    les données. En retour, l'origine de l'ensemble de réplication
    doit écouter les événements dans la direction opposée.
    Un noeud peut écouter simultanément les événéments d'un même ensemble d'origine
    en provenance de différents fournisseurs. Cependant pour traiter les 
    événements <command>SYNC</command> de cette ensemble d'origine tous les
    fournisseurs de données doivent avoir un niveau de synchronisation égal 
    ou supérieur, afin d'éviter des comportements de réplication trop 
    rapide.
    </para>

    <variablelist>
     <varlistentry><term><literal> ORIGIN  = ival </literal></term>
      <listitem><para> L'identifiant du noeud d'origine que le récepteur écoute.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> PROVIDER = ival </literal></term>
     <listitem><para> L'identifiant du noeud qui envoie au récepteur les événements 
	 produits par le noeud origine. Si cette valeur n'est pas spécifiée,
	 il s'agit du noeud origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> RECEIVER = ival </literal></term>
      
      <listitem><para> L'identifiant du noeud recevant les événements.</para></listitem>
     </varlistentry>
    </variablelist>

    <para> Cette commande utilise &funstorelisten;. </para>
    <para> Pour plus de détails, consultez &rlistenpaths;.</para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     STORE LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande fut introduite 
   dans &slony1; 1.0.  À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande, car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroplisten"><refmeta><refentrytitle>DROP LISTEN</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP LISTEN</refname>
    
    <refpurpose> Élimine la configuration qui décrit comment un noeud
    &slony1; écoute les  événements
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP LISTEN (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Supprime une <quote>voie d'écoute</quote> de la configuration. </para>
    
    <variablelist>
     <varlistentry><term><literal> ORIGIN  = ival </literal></term>
      <listitem><para> Identifiant du noeudIdentifiant du noeud of the event origin the receiver is listening for.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> PROVIDER = ival </literal></term>
     <listitem><para> Identifiant du noeud qui envoie au recepteur les événements
	 produits par l'origine. Si cette valeur n'est pas spécifiée, alors il 
	 s'agit de l'origine.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> RECEIVER = ival </literal></term>
      
      <listitem><para> L'identifiant du noeud qui reçoit les événements.</para></listitem>
     </varlistentry>
    </variablelist>
    
    <para> Cette commande utilise &fundroplisten;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     DROP LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande fut introduite 
   dans &slony1; 1.0.  À partir de la version 1.1, vous ne <emphasis>devriez</emphasis>
   pas avoir besoin de cette commande, car les voies d'écoute sont générées automatiquement.
    </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

<refentry id="stmttableaddkey"><refmeta><refentrytitle>TABLE ADD KEY</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>TABLE ADD KEY</refname>
    
    <refpurpose> Ajoute une clef primaire pour 
    &slony1; dans une table qui n'en possède pas
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>TABLE ADD KEY (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans un système de réplication &slony1;, chaque table répliquée 
     doit avoir au moins une contrainte
     <command>UNIQUE</command> dont les colonnes sont déclarées
     <command>NOT NULL</command>. N'importe quelle clef primaire
     respecte ces pré-requis.
    </para>

    <para>
     En dernier recours, <emphasis>dans les versions de &slony1; antérieures
       à la 2.0</emphasis>, cette commande peut être utilisée pour ajouter 
     un attribut à une table qui ne possède par de clef primaire.
     Sachant que cette modification pour avoir des effets secondaires
     indésirables, <emphasis>il est très fortement recommandé que les 
       utilisateurs ajoute les attributs unique et not null par 
       leurs propres moyens.</emphasis>
    </para>

   <para> Si vous comptez utilisez &slony1; version 2.0, vous
   <emphasis>devez</emphasis> vous débrouiller pour définir
   une clef primaire plus adéquate.
   &slony1; ne vous en fournira pas une, et si vous 
   avez des clefs créées via <command>TABLE ADD KEY</command>,
   ne vous attendez pas à ce que &slony1; fonctionne correctement. </para>
    <variablelist>
     <varlistentry><term><literal> NODE ID = ival </literal></term>
      <listitem><para> Identifiant du noeud de l'ensemble de réplication d'origine
	  où l'on ajoute la table dans l'ensemble (voir <xref linkend="stmtsetaddtable"/>.)</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> FULLY QUALIFIED NAME  = 'string' </literal></term>
      <listitem><para> Le nom complet de la table composé du nom du schéma
	  et du nom de la table, au format SQL suivant 
	<command>quote_ident(nspname)
	 || '.' || quote_ident(relname)</command>.</para></listitem>
     </varlistentry>
    </variablelist>

    <note><para> Pour le moment il existe des limitations; vous pouvez
	créer une table &postgres; avec aucune colonne, par exemple 
	<command> create table table_vide (); </command>.  
	&slony1; refusera de manipuler une telle table.
	Ce n'est pas vraiment une limitation génante, car il est 
	n'est pas très intéressant de répliquer des tables qui ne contiennent
	aucune information.</para> </note>

    <caution><para> <command>TABLE ADD KEY</command> <emphasis>ne doit
    pas être utilisée</emphasis> si vous pouvez vous en passer.
    C'est le <emphasis></emphasis> d'une &bestpracticelink;. </para>

    <para> L'absence d'une clef primaire adéquate est
      une indication très sérieuse que le schéma est 
    <emphasis>défectueux</emphasis>. La
    <emphasis>bonne</emphasis> méthode pour le réparer est d'introduire
    un clef primaire adéquate, pas demander à &slony1; d'en <quote>bricoler</quote> une.</para> 

    <para>Cette commande n'est  <emphasis>pas</emphasis> supportée  par le &logshiplink;,
    et nous n'avons pas l'intention de développer ce support.</para> </caution>
    
    <para> Cette commande utilise &funtableaddkey;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     TABLE ADD KEY ( NODE ID = 1, 
     FULLY QUALIFIED NAME = 'public.history' );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur le noeud origine, la commande posera un verrou exclusif
      sur la table modifiée tant que ces opérations ne seront pas terminées :
     :</para>
    <itemizedlist>
    <listitem><para> Modifier la table, ajouter la colonne;</para></listitem>
    <listitem><para> Modifier chaque ligne de la table, attacher la valeur de la séquence;</para></listitem>
    <listitem><para> Ajouter un nouvel index unique à la table.</para></listitem>
    </itemizedlist>

    <para> Sur les noeus abonnés, ces modifications sont
      réalisées sur la table losqu'elle est vode, et perturbe 
      pas particulièrement l'abonnement au cours du verrouillage
      sur le noeud abonné.</para> 

    <para> Si la table est volumineuse et fréquemment mise à jour
      par vos applications, cela imposera un coupure de service
      significative qui correspond au tems de modification de la
      table sur le noeud d'origine. C'est pourquoi il est recommandé
      que cette commande ne sit pas utilisée quand c'est possible.</para>      
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
<warning>    <para> Cette commande n'est <emphasis> plus supportée</emphasis>
    à partir de &slony1; version 2.0.  Dans la version 2, les différents
    <quote>modifications du catalogue</quote> réalisée sur les
    versions de &postgres; antérieures à la 8.3 sont éliminées
    afin que les exports de schéma puissent être utilisés sur n'importe
    quel noeud. Ainsi les colonnes <quote>bricolées</quote> par
    <command>TABLE ADD KEY</command> sont la chose qui empêche la commande
    <xref linkend="stmtuninstallnode"/> d'être équivalente à 
    la commande SQL  <command>drop schema _nom_du_cluster 
    cascade;</command>.</para> </warning>    
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtcreateset"><refmeta><refentrytitle>CREATE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CREATE SET</refname>
    
    <refpurpose> Crée un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>CREATE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Dans le système de réplication &slony1;, les tables répliquées sont 
     regroupées en ensembles. En règle générale, un ensemble contient 
     des tables reliées pour une application donnée. Dans application 
     correctement conçue, toutes ces tables sont regroupées dans un
     schéma.
    </para>
    <para>
     L'ensemble de réplication est la plus petite unité qu'un noeud peut répliquer vers un autre noeud.
     Un ensemble de réplication a toujours une origine. En terme classique,
     c'est ce qu'on appele le <quote>maître</quote>.
     Puisqu'avec &slony1; un noeud peut être simultanément <quote>maître</quote> pour un ensemble,
     et tenir le rôle  d'<quote>esclave</quote> pour un autre, cette terminologie peut 
     rapidement prêter à confusion et doit par conséquent être remplacée par 
      <quote>ensemble d'origine</quote> et <quote>abonné</quote>.
    </para>
    
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant de l'ensemble qu'il faut créer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine initial de cet ensemble.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> COMMENT = 'chaîne' </literal></term>
      <listitem><para> Un texte descriptif peut être ajouté pour l'ensemble de réplication.</para>
                <para> Si aucun commentaire n'est fourni, la valeur par défaut est  <command>A replication set so boring no one thought to give it a name</command>  (NdT : <quote>Un ensemble de réplication tellement
		  ennuyeux qui personne n'a pensé à lui donner un nom</quote>)
	      </para>
      </listitem>
     </varlistentry>
    </variablelist>
    
    <para> Cette commande utilise &funstoreset; . </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     CREATE SET ( ID = 1, 
               ORIGIN = 1,
               COMMENT = 'Tables du système de réservation' );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
    <para> Jusqu'à la version 1.2, la commande échoue si aucun commentaire n'est fourni. </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtdropset"><refmeta><refentrytitle>DROP SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>DROP SET</refname>
    
    <refpurpose> Enlever un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime un ensemble de table de la configuration &slony1;. 
     Cette commande désabonne automatiquement tous les noeuds qui 
     héberge cet ensemble et rétablit les règles et les triggers 
     originaux sur tous les abonnés.
    </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant de l'ensemble qu'il faut supprimer.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine actuel de l'ensemble de réplication.</para></listitem>
     </varlistentry>
    </variablelist>
    
       <para> Cette commande utilise &fundropset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
  DROP SET ( ID = 5, 
             ORIGIN = 2 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur chaque noeud, la commande pose un verrou exclusif sur 
      chaque table répliquée afin de modifier le schéma de la table
      pour nettoyer les triggers et les règles. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
 
<!-- **************************************** -->

  <refentry id="stmtmergeset"><refmeta><refentrytitle>MERGE
     SET</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MERGE SET</refname>
    
    <refpurpose> Fusionne plusieurs ensemble de réplication &slony1; 
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MERGE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Fusionne un ensemble de tables et de séquences dans un autre.
      Cette fonction est un contournement face à l'impossibilité
      d'ajouter des tables/séquences à des ensembles en cours de 
      réplication. On peut alors créer un ensemble temporaire, y ajouter
      les nouveaux objects, abonner tous les noeuds à ce nouvel ensemble,
      puis fusionner l'ensemble courant et l'ensemble temporaire, et ce qui supprime
      l'identifiant de l'ensemble temporaire.
      
    </para>

    <para>
     Cette opération ne fonctionnera si les deux ensembles ne sont pas 
     répliqués <emphasis>exactement</emphasis> sur les mêmes noeuds abonnés.
     </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> Identifiant unique de l'ensemble qui contiendra les deux ensembles distincts.</para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ADD ID = ival </literal></term>
      <listitem><para> Identifiant unique de l'ensemble de l'ensemble dont les objets vont être transférés.  </para></listitem>
     </varlistentry>
     <varlistentry><term><literal> ORIGIN = ival </literal></term>
      <listitem><para> Noeud d'origine actuel des deux ensembles.  </para></listitem>
     </varlistentry>
    </variablelist>
    
       <para> Cette commande utilise &funmergeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     # Supposons que l'ensemble 1 est répliqué sur les noeuds 2 et 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1><title> Comportement dangereux ou non-intuitif </title>

   <para> La fusion se déroule suivant la configuration sur le noeud origine.
   Si une fusion est demandée alors que les abonnements sont toujours
   en cours de traitement, cela peut briser les réplications en cours
   sur les noeuds abonnés, car ils chercheront la configuration de cet
   ensemble alors qu'il vient d'être supprimé. Ne soyez pas trop 
   rapides lorsque vous fusionner des ensembles.
   </para>

   </refsect1>
   <refsect1> <title> Note de version </title> <para> Cette commande
       fut introduite dans &slony1; 1.0.5.  Dans la version 1.2.1, 
       une condition de compétition ("race condition") a été corrigée.
       Elle apparaissait lorsque la requête de fusion était soumise
       alors que les demande d'abonnement étaient traités.
       Cela empêche les fusion avant que les abonnements soient 
       complètement réalisés. </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddtable"><refmeta><refentrytitle>SET ADD TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD TABLE</refname>
    
    <refpurpose> Ajoute une table dans un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Ajoute une table existante dans un ensemble de réplication. L'ensemble ne doit 
    pas être répliqué sur un autre noeud, cette fonctionnalité est assurée par la commande 
    Add an existing usep table to a replication set. The set
    <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble dans lequel la table doit être ajoutée. </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeuf origine de l'ensemble.  Les prochaines version de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>

       <listitem><para> Identifiant unique de la table. Ces identifiants ne sont 
       pas seulement utilisé pour désigner une table dans l'ensemble de réplication.
       Cette valeur numérique détermine également l'ordre de verrouillage des tables,
       notamment lors de la commande <xref linkend="stmtlockset"/>.
       Cet identifiant doit donc suivre une certaine hiérachie afin que les scripts
       <application>slonik</application> ne provoque de situation d'inter-blocage ("deadlocks").
       </para>

         <para> Cet identifiant doit être unique pour tous les ensembles de réplication;
	 vous ne devez pas avoir deux tables du même cluster avec le même identifiant.
	  </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
       <listitem><para> Le nom complet de la table tel que décrit dans
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> KEY = { 'string' | SERIAL }
	</literal></term> <listitem><para>
	 <emphasis>(Facultatif)</emphasis> Le nom de l'index relatif à la colonne unique et 
	 non-nulle qui est utilisée comme identifiant de ligne lors de la réplication.
	 Si le mot-clef SERIAL est utilisé, cela indique qu'il faut utiliser la colonne 
	 spéciale ajoutée avec la commande  <xref linkend="stmttableaddkey"/> command.
	 Par défaut, on utilise la clef primaire de la table. Le nom de l'index n'est 
	 <emphasis>pas</emphasis> un nom complet; vous devez omettre l'espace de nom.</para></listitem>

      </varlistentry>
      <varlistentry><term><literal> COMMENT = 'string' </literal></term>
       <listitem><para> Un texte décrivant la table.  </para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise &funsetaddtable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET ADD TABLE (
    SET ID = 1,
    ORIGIN = 1,
    ID = 20,
    FULLY QUALIFIED NAME = 'public.tracker_ticket',
    COMMENT = 'Ticket de Support'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Messages d'erreur </title>

    <para> Voici quelque messages d'erreurs que vous rencontrerez en cas d'utilisation incorrecte : </para>

   <variablelist>    
       <varlistentry><term><literal>Slony-I: setAddTable_int: table public.ma_table PK column id nullable </literal></term>

        <listitem><para> Les clefs primaires (ou les clefs candidates) doivent être composées 
	de colonnes <command>NOT NULL</command>. Si vous avez une clef primaire candidate dont une
	colonne n'est pas déclarée ainsi, alors &slony1; rejetera la table et produira ce message. </para> 
	</listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int: table id 14 has already been assigned! </literal></term>

        <listitem><para> L'identifiant de la table, stocké dans 
        <envar>sl_table.tab_id</envar>, doit être unique pour tous les noeuds/tables/ensembles.
	Ce message indique que vous avez tenté de déclarer un identifiant qui est déjà utilisé.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): table public.ma_table has no index mt_idx_14</literal></term>

        <listitem><para> Ceci se produit en général avec les clefs primaires candidates;
	Le message indique que l'index spécifié n'est pas disponible sur ce noeud.
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal>Slony-I: setAddTable_int(): table public.ma_table not found </literal></term>

        <listitem><para> Pire que l'absence d'un index, c'est la table qui est manquante.
	Le message indique que le processus que vous avez utilisé pour mettre en place le schéma n'a pas
	fonctionné correctement. </para>
        </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): public.ma_vue is not a regular table </literal></term>

        <listitem><para> Vous ne pouvez répliquer que des tables (en tout cas avec 
        <command>SET ADD TABLE</command>). Cela n'inclut pas les vues et les indexes.
	( Les index sont répliqués de facto, mais on peut pas demander explicitement la réplication d'un index )
	</para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable_int(): set 4 not found </literal></term>

        <listitem><para> Vous devez définit l'ensemble de réplication avant de lui assigner des tables.
        </para> </listitem> </varlistentry>

       <varlistentry><term><literal> Slony-I: setAddTable(): set 4 has remote origin </literal></term>

        <listitem><para> Ceci se produit lorsque l'ensemble de réplication #4 est configuré
	sur une origine, le noeud 1, et que vous lancez une commande <command>SET ADD
        TABLE</command> qui spécifie un autre noeud que le noeud 1. Ceci se produit généralement
	lorsque la configuration <command>admin conninfo</command> est confuse à l'intérieur du
	préambule du script slonik...</para>
        </listitem>
        </varlistentry>

       <varlistentry><term><literal>Slony-I: cannot add table to currently subscribed set 1 </literal></term>

        <listitem><para> &slony1; ne peut pas ajouter des tables dans un ensemble qui est 
	en cours de réplication. Pour contourner ce problème, vous devez définir un nouvel ensemble
	qui contiendra les nouvelles tables.</para> </listitem> </varlistentry>

   </variablelist>    

   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Sur le noeud orgine, cette opération demande un verrou exclusif très bref sur la table
    afin de lui ajouter les triggers de réplication. Sur les noeuds abonnés, les verrous 
    correspondant sont réalisés au moment de l'événement <command>SUBSCRIBE_SET</command>.  </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtsetaddsequence"><refmeta><refentrytitle>SET ADD SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET ADD SEQUENCE</refname>
    
    <refpurpose> Ajoute une séquence dans un ensemble de réplication
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET ADD SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
<refsect1>
    <title>Description</title>
    
    <para>
     Ajoute une séquence existante dans un ensemble de réplication. L'ensemble ne 
     doit pas être répliqué sur un autre noeud. Cette fonctionnalité est supportée 
     par la commande <xref linkend="stmtmergeset"/>.
     
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Identifiant de l'ensemble dans lequel on ajoute la séquence.
	</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble. Les prochaines version de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Identifiant Unique de la séquence.  <note><para> Notons
	   que cet identifiant doit être unique parmi <emphasis>toutes les séquences</emphasis>
	   du cluster; la numérotation des tables est indépendante, donc il est possible 
	   de donner l'identifiant 20 à une table et à une séquence, sans que cela ne crée de confusion.
	   </para> </note></para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
       <listitem><para> Le nom complet de la séquence telle que décrit dans 
	 <xref linkend="stmttableaddkey"/>.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> COMMENT = 'string' </literal></term>
       <listitem><para> Un texte décrivant la séquence.  </para></listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetaddsequence;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET ADD SEQUENCE (
     SET ID = 1,
     ORIGIN = 1,
     ID = 20,
     FULLY QUALIFIED NAME = 'public.tracker_ticket_id_seq',
     COMMENT = 'Séquence d'identifiants des tickets de support'
     );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdroptable"><refmeta><refentrytitle>SET DROP TABLE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP TABLE</refname>
    
    <refpurpose> Supprime une table d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une table d'un ensemble de réplication.
    </para>
    <para>
     Notez que cette action ne supprimera <emphasis>pas</emphasis> une clef primaire
     candidate créée avec la commande <xref
     linkend="stmttableaddkey"/>.
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble de réplication.Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information. </para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
  <listitem><para> Identifiant unique de la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetdroptable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SET DROP TABLE (
     ORIGIN = 1,
     ID = 20
     );
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Cette opération pose un verrou exclusif sur la table qui est supprimée afin 
    de retirer les triggers de réplication. Sur les noeuds abonnées, cela implique également
    le rétablissement des règles et des triggers qui ont été désactivés.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtsetdropsequence"><refmeta><refentrytitle>SET DROP SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET DROP SEQUENCE</refname>
    
    <refpurpose> Supprime une séquence d'un ensemble de réplication &slony1;
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET DROP SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Supprime une séquence existante dans un ensemble de réplication.
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Noeud d'origine de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Identifiant unique de la séquence.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetdropsequence;. </para>
   </refsect1>
<refsect1><title>Exemple</title>
    <programlisting>
     SET DROP SEQUENCE (
     ORIGIN = 1,
     ID = 20,
     );
</programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  
  <refentry id="stmtsetmovetable"><refmeta><refentrytitle>SET MOVE
     TABLE</refentrytitle><manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE TABLE</refname>

    <refpurpose> Déplace une table d'un ensemble de réplication vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE TABLE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     Change l'ensemble de réplication dans lequel se trouve la table. L'ensemble courant et le 
     nouveau doivent avoir le même noeud origine et les même noeuds abonnés.
     
     <caution><para> La méthode d'abonnement d'un nouvel ensemble de réplication 
     permet de garantir que l'abonnement est complètement effectué sur tous les noeuds
     avant que le tables soient déplacées. Déplacer une table trop tôt vers un nouvel ensemble,
     implique que le noeud abonné va essayer d'ajouter la table pendant le processus d'abonnement
     de l'ensemble de réplication, ce qui échoue suite à une erreur de clef dupliquée et provoque 
     l'arrêt de la réplication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Origine actuelle de l'ensemble. Les prochaines versions de <application>slonik</application>
	 devraient pouvoir deviner cette information.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>

       <listitem><para> Identifiant unique de la table.</para></listitem></varlistentry>
      <varlistentry><term><literal> NEW SET = ival </literal></term>
       
  <listitem><para> Identifiant unique de l'ensemble dans lequel il faut ajouter la table.</para></listitem></varlistentry>
     </variablelist>
    </para>
    <para> Cette commande utilise la fonction &funsetmovetable;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE TABLE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
</refentry>
  

<!-- **************************************** -->

  <refentry id="stmtsetmovesequence"><refmeta><refentrytitle>SET MOVE SEQUENCE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SET MOVE SEQUENCE</refname>
    
    <refpurpose> Déplace une séquence d'un ensemble de réplication &slony1; vers un autre.
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SET MOVE SEQUENCE (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para>
     Change the set a sequence belongs to. The current set and the new
     set must originate on the same node and subscribed by the same
     nodes.

     <caution><para> Due to the way subscribing to new sets works make
       absolutely sure that the subscription of all nodes to the sets
       is completely processed before moving sequences. Moving a sequence too
       early to a new set causes the subscriber to try and add the sequence
       already during the subscription process, which fails with a duplicate
       key error and breaks replication.</para></caution>
     
     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       <listitem><para> Origin node for the set.  A future version of <application>slonik</application>
	 might figure out this information by itself.</para></listitem>
      </varlistentry>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> Unique ID of the sequence.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> NEW SET = ival </literal></term>
       
       <listitem><para> Unique ID of the set to which the sequence should be moved.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &funsetmovesequence;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SET MOVE SEQUENCE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0.5 </para>
   </refsect1>
  </refentry>


<!-- **************************************** -->

  <refentry id="stmtstoretrigger"><refmeta><refentrytitle>STORE TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>STORE TRIGGER</refname>
    
    <refpurpose> Indicate that a trigger should not be disabled by
    &slony1; on a subscriber node
    </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>STORE TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> By default, all user defined triggers and constraints are
     disabled on all subscriber nodes while a table is replicated. This
     command can be used to explicitly exclude a trigger from being
     disabled.

     <variablelist>
      <varlistentry><term><literal> TABLE ID = ival </literal></term>
       <listitem><para> The unique, numeric ID number of the table the trigger is defined for.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>
       
       <listitem><para> The name of the trigger as it appears in the
	 <envar>pg_trigger</envar> system catalog.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> (Optional) The ID of the node used to create
       the configuration event that tells all existing nodes about the
	 special trigger. Default value is 1.</para></listitem>

      </varlistentry>
     </variablelist>
    </para>
    <note><para> A nifty trick is that you can run <command>STORE
    TRIGGER</command> <emphasis>before the trigger is
    installed;</emphasis> that will not cause any errors.  You could
    thus add &slony1;'s handling of the trigger
    <emphasis>before</emphasis> it is installed.  That allows you to
    be certain that it becomes active on all nodes immediately upon
    its installation via <xref linkend="stmtddlscript"/>; there is no
    risk of events getting through in between the <command>EXECUTE
    SCRIPT</command> and <command>STORE TRIGGER</command>
    events. </para>
    </note>    
    <para> This uses &funstoretrigger;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
STORE TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> This operation will need to acquire an exclusive lock on
    the specified table on each node to which it applies in order to
    alter table schemas to add back the trigger, but only breifly. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>

    <para> In &slony1; version 2.0, this command is removed as
    obsolete because triggers are no longer <quote>messed around
    with</quote> in the system catalogue. </para>    
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtdroptrigger"><refmeta><refentrytitle>DROP TRIGGER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>DROP TRIGGER</refname>
    
    <refpurpose> Return a trigger to default behavior, where it will
    not fire on subscriber nodes </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>DROP TRIGGER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Remove the special handling for the specified trigger.

     <variablelist>
      <varlistentry><term><literal> TABLE ID = ival </literal></term>
      <listitem><para> The unique, numeric ID number of the table the
      trigger is defined for.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>
       
       <listitem><para> The name of the trigger as it appears in the
	 <envar>pg_trigger</envar> system catalog.</para></listitem>

      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> (Optional) The ID of the node used to create
	 the configuration event that tells all existing nodes about the
	 special trigger. Default value is 1.</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &fundroptrigger;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
DROP TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> This operation will need to acquire an exclusive lock on
    the specified table on each node to which it applies in order to
    alter table schemas to remove the trigger. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>

    <para> In &slony1; version 2.0, this command is removed as
    obsolete because triggers are no longer <quote>messed around
    with</quote> in the system catalogue. </para>    
    
   </refsect1>
  </refentry>
  
<!-- **************************************** -->
  <refentry id="stmtsubscribeset"><refmeta><refentrytitle>SUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SUBSCRIBE SET</refname>
    
    <refpurpose> Start replication of &slony1; set </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> This performs one of two actions: </para>

    <itemizedlist>
 
    <listitem><para> Initiates replication for a replication set </para>
    <para> Causes a node (subscriber) to start replicating a set of
    tables either from the origin or from another provider node, which
    must itself already be be an active, forwarding subscriber.</para>
    
    <para> The application tables contained in the set must already
     exist and should ideally be empty. The current version of
     &slony1; will <emphasis>not</emphasis>
     attempt to copy the schema of the set. The replication daemon will
     start copying the current content of the set from the given
     provider and then try to catch up with any update activity that
     happened during that copy process. After successful subscription,
     the tables are guarded on the subscriber, using triggers, against
     accidental updates by the application.
    </para>
    
    <para> If the tables on the subscriber are
    <emphasis>not</emphasis> empty, then the <command>COPY
    SET</command> event (which is part of the subscription process)
    may wind up doing more work than should be strictly
    necessary:</para>
     <itemizedlist>

      <listitem><para> It attempts to <command>TRUNCATE</command> the
      table, which will be efficient. </para> </listitem>
      
      <listitem><para> If that fails (a foreign key relationship might
      prevent TRUNCATE from working), it uses
      <command>DELETE</command> to delete all <quote>old</quote>
      entries in the table</para></listitem>

      <listitem><para> Those old entries clutter up the table until it
      is next <command>VACUUM</command>ed <emphasis>after</emphasis>
      the subscription process is complete</para></listitem>
      
      <listitem><para> The indices for the table will contain entries
      for the old, deleted entries, which will slow the process of
      inserting new entries into the index.</para></listitem>
     </itemizedlist>

     <warning><para> This operation can take a (potentially distinctly)
     non-zero period of time.  If you have a great deal of data in a
     particular set of tables, it may take hours or even (if <quote>a
     great deal</quote> indicates <quote>tens or hundreds gigabytes of
     data</quote>) possibly multiple days for this event to
     complete.</para>

     <para> The <command>SUBSCRIBE SET</command> request will,
     nonetheless, return fairly much immediately, even though the
     work, being handled by the <command>COPY SET</command> event, is
     still in progress.  If you need to set up subscriptions for a set
     of cascading nodes, you will need to wait for each subscriber to
     complete subscribing before submitting requests for subscriptions
     that use that node as a provider.  If you don't, it won't be a
     big deal: <command>slonik</command> will check the node, discover
     that it is not yet an active provider for the set, and report
     back:</para>

<programlisting>
 Slony-I: provider 2 is not an active forwarding node for replication set 1
</programlisting>

     <para> In effect, such subscription requests will be ignored
     until the provider is ready.</para>
</warning>

     </listitem>

     <listitem><para> Revising subscription information for already-subscribed nodes. </para>

     <para> If you need to revise subscription information for a
       node, you <emphasis>also</emphasis> submit the new information
       using this command, and the new configuration will be propagated
       throughout the replication network.  The normal reason to revise
       this information is that you want a node to subscribe to a
       <emphasis> different </emphasis> provider node, or for a node to
       become a <quote>forwarding</quote> subscriber so it may later
       become the provider for a later subscriber.</para>

     </listitem>
     </itemizedlist>

     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> ID of the set to subscribe</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> PROVIDER = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the data provider from which this
       node draws data.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> RECEIVER = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the new subscriber</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> FORWARD = boolean </literal></term>
       
       <listitem><para> Flag whether or not the new subscriber should
	 store the log information during replication to make it
	 possible candidate for the provider role for future
	 nodes.</para></listitem>

      </varlistentry>
     </variablelist>
    <para> This uses &funsubscribeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
SUBSCRIBE SET (
   ID = 1,
   PROVIDER = 1,
   RECEIVER = 3,
   FORWARD = YES
);
    </programlisting>
   </refsect1>

   <refsect1> <title> Forwarding Behaviour </title>

    <para> The <command>FORWARD=boolean</command> flag indicates
    whether the subscriber will store log information in tables
    &sllog1; and &sllog2;.  Several implications fall from
    this...</para>

    <para> By storing the data in these tables on the subscriber,
    there is some additional processing burden.  If you are certain
    that you would never want to <xref linkend="stmtmoveset"/> or <xref
    linkend="stmtfailover"/> to a particular subscriber, it is worth
    considering turning off forwarding on that node.  </para>

    <para> There is, however, a case where having forwarding turned
    off opens up a perhaps-unexpected failure condition; a rule of
    thumb should be that <emphasis>all nodes that connect directly to
    the origin</emphasis> should have forwarding turned on.  Supposing
    one such <quote>direct subscriber</quote> has forwarding turned
    off, it is possible for that node to be forcibly lost in a case of
    failover.  The problem comes if that node gets ahead of other
    nodes.</para>

    <para> Let's suppose that the origin, node 1 is at SYNC number
    88901, a non-forwarding node, node 2 has processed up to SYNC
    88897, and other forwarding nodes, 3, 4, and 5, have only
    processed data up to SYNC 88895.  At that moment, the disk system
    on the origin node catches fire.  Node 2 has the
    <emphasis>data</emphasis> up to SYNC 88897, but there is no
    remaining node that contains, in &sllog1; or &sllog2;, the data
    for SYNCs 88896 and 88897, so there is no way to bring nodes 3-5
    up to that point.</para>

    <para> At that point, there are only two choices: To drop node 2,
    because there is no way to continue managing it, or to drop all
    nodes <emphasis>but</emphasis> 2, because there is no way to bring
    them up to SYNC 88897.</para>

    <para> That dilemma may be avoided by making sure that all nodes
    directly subscribing to the origin have forwarding turned
    on. </para>

   </refsect1>
   <refsect1> <title> Dangerous/Unintuitive Behaviour </title>

   <itemizedlist>

     <listitem><para> The fact that the request returns immediately
     even though the subscription may take considerable time to
     complete may be a bit surprising. </para> 

     <para> Processing of the subscription involves
     <emphasis>two</emphasis> events; the
     <command>SUBSCRIBE_SET</command>, initiated from the provider
     node, and an <command>ENABLE_SUBSCRIPTION</command>, which is
     initiated on the subscriber node.  This means that <xref
     linkend="stmtwaitevent"/> cannot directly wait for completion of a
     subscription.  If you need to wait for completion of a
     subscription, then what you need to do instead is to submit a
     <xref linkend="stmtsync"/> request, and wait for
     <emphasis>that</emphasis> event.</para>
     </listitem>

     <listitem><para> This command has <emphasis>two</emphasis>
     purposes; setting up subscriptions (which should be unsurprising)
     and <emphasis>revising subscriptions</emphasis>, which isn't so
     obvious to intuition. </para> </listitem>

     <listitem><para> New subscriptions are set up by using
     <command>DELETE</command> or <command>TRUNCATE</command> to
     empty the table on a subscriber.  If you created a new node by
     copying data from an existing node, it might <quote>seem
     intuitive</quote> that that data should be kept; that is not the
     case - the former contents are discarded and the node is
     populated <emphasis>from scratch</emphasis>.</para> </listitem>

   </itemizedlist>

   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> This operation does <emphasis>not</emphasis> require
    acquiring any locks on the provider node.</para>

    <para> On the subscriber node, it will have the effect of locking
    every table in the replication set.  In version 1.2, exclusive
    locks are acquired at the beginning of the process; in earlier
    versions, locks were acquired implicitly as activity mandated it,
    which left some risk of deadlock if other applications could
    access the subscriber database at this time.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  
<!-- **************************************** -->

  <refentry id="stmtunsubscribeset"><refmeta><refentrytitle>UNSUBSCRIBE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNSUBSCRIBE SET</refname>

    <refpurpose> End replication of &slony1; set </refpurpose></refnamediv>
   
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNSUBSCRIBE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>

    <para> Stops the subscriber from replicating the set. The tables
     are opened up for full access by the client application on the
     former subscriber. The tables are not truncated or otherwise
     modified. All original triggers, rules and constraints are
     restored.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> ID of the set to unsubscribe</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> RECEIVER = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the (former) subscriber</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &fununsubscribeset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNSUBSCRIBE SET (
   ID = 1,
   RECEIVER = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Exclusive locks on each replicated table will be taken out
    on the subscriber in order to drop replication triggers from the
    tables and restore other triggers/rules. </para>
   </refsect1>

   <refsect1><title> Dangerous/Unintuitive Behaviour </title>

     <para> Resubscribing an unsubscribed set requires a
     <emphasis>complete fresh copy</emphasis> of data from the
     provider to be transferred since the tables have been subject to
     possible independent modifications.  </para>

   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

  
<!-- **************************************** -->

  <refentry id ="stmtlockset"><refmeta><refentrytitle>LOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>LOCK SET</refname>
    
    <refpurpose> Guard &slony1; replication
    set to prepare for <command>MOVE SET</command>
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>LOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Guards a replication set against client application updates
    in preparation for a <xref linkend="stmtmoveset"/> command.
    </para>

    <para> This command must be the first in a possible statement
    group (<command>try</command>).  The reason for this is that it
    needs to commit the changes made to the tables (adding a special
    trigger function) before it can wait for every concurrent
    transaction to finish. At the same time it cannot hold an open
    transaction to the same database itself since this would result in
    blocking itself forever.</para>

    <para> Note that this is a &rlocking; operation, which means that
    it can get stuck behind other database activity.</para>

    <para> The operation waits for transaction IDs to advance in order
    that data is not missed on the new origin.  Thus, if you have
    long-running transactions running on the source node, this
    operation will wait for those transactions to complete.
    Unfortunately, if you have another database on the same postmaster
    as the origin node, long running transactions on that database
    will also be considered even though they are essentially
    independent.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> ID of the set to lock</para></listitem>
	 
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the current set origin</para></listitem>
	 
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &funlockset;. </para>
   </refsect1>
   <refsect1><Title>Example</Title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Exclusive locks on each replicated table will be taken out
    on the origin node, and triggers are added to each such table that
    reject table updates. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtunlockset"><refmeta><refentrytitle>UNLOCK SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>UNLOCK SET</refname>
    
    <refpurpose> Unlock a &slony1; set that was locked </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UNLOCK SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> 
     Unlocks a previously locked set.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> ID of the set to unlock</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the current set origin</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &fununlockset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UNLOCK SET (
   ID = 1,
   ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Exclusive locks on each replicated table will be taken out
    on the origin node, as the triggers are removed from each table
    that reject table updates. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>
  

<!-- **************************************** -->

  <refentry id="stmtmoveset"><refmeta><refentrytitle>MOVE SET</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>MOVE SET</refname>
    
    <refpurpose> Change origin of a &slony1;
    replication set </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>MOVE SET (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Changes the origin of a set from one node to another. The
    new origin must be a current subscriber of the set. The set must
    currently be locked on the old origin. </para>
    
    <para> After this command, the set cannot be unlocked on the old
     origin any more. The old origin will continue as a forwarding
     subscriber of the set and the subscription chain from the old
     origin to the new origin will be reversed, hop by hop. As soon as
     the new origin has finished processing the event (that includes
     any outstanding sync events that happened before,
     <emphasis>i.e.</emphasis> fully catching up), the new origin will
     take over and open all tables in the set for client application
     update activity.
    </para>

    <para> This is <emphasis>not</emphasis> failover, as it requires a
     functioning old origin node (you needed to lock the set on the old
     origin).  You would probably prefer to <command>MOVE SET</command>
     instead of <command>FAILOVER</command>, if at all possible, as
     <command>FAILOVER</command> winds up discarding the old origin
     node as being corrupted. Before <command>MOVE SET</command> will
     function a <command>LOCK SET</command> is needed.
</para>
     
    <para> Note that this is a &rlocking; operation, which means that
    it can get stuck behind other database activity.
     
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> ID of the set to transfer</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> OLD ORIGIN = ival </literal></term>
       
       <listitem><para> Identifiant du noeud of the current set origin</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> NEW ORIGIN = ival </literal></term>
       
  <listitem><para> Identifiant du noeud of the new set origin</para></listitem>
       
      </varlistentry>
     </variablelist>
    </para>
    <para> This uses &funmoveset;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
LOCK SET (
   ID = 1,
   ORIGIN = 1
);
MOVE SET (
   ID = 1,
   OLD ORIGIN = 1,
   NEW ORIGIN = 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Exclusive locks on each replicated table will be taken out
    on both the old origin node and the new origin node, as
    replication triggers are changed on both nodes: on the former
    origin, each table has two triggers (logtrigger and lockset)
    dropped and a denyaccess trigger added; on the new origin, the
    denyaccess trigger is dropped and a logtrigger trigger
    added. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtfailover"><refmeta><refentrytitle>FAILOVER</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>FAILOVER</refname>
    
    <refpurpose> Fail a broken replication set over to a backup node
    </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>FAILOVER (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para>
     The <command>FAILOVER</command> command causes the backup node to take over all sets
     that currently originate on the failed
     node. <application>slonik</application> will contact all other
     direct subscribers of the failed node to determine which node has
     the highest sync status for each set. If another node has a
     higher sync status than the backup node, the replication will
     first be redirected so that the backup node replicates against
     that other node, before assuming the origin role and allowing
     update activity.
    </para>

    <para>
     After successful failover, all former direct subscribers of the
     failed node become direct subscribers of the backup node. The
     failed node is abandoned, and can and should be removed from the
     configuration with <xref linkend="stmtdropnode"/>.
    </para>
    
    <variablelist>
     <varlistentry><term><literal> ID = ival </literal></term>
      <listitem><para> ID of the failed node</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> BACKUP NODE = ival </literal></term>
      
      <listitem><para> Identifiant du noeud of the node that will take over all
      sets originating on the failed node</para></listitem>

     </varlistentry>
    </variablelist>
    
    <para> This uses &funfailednode;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
FAILOVER (
   ID = 1,
   BACKUP NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Exclusive locks on each replicated table will be taken out
    on both the new origin node as replication triggers are changed.
    If the new origin was not completely up to date, and replication
    data must be drawn from some other node that is more up to date,
    the new origin will not become usable until those updates are
    complete. </para>
   </refsect1>
   <refsect1><title> Dangerous/Unintuitive Behaviour </title>
    <para> This command will abandon the status of the failed
    node.  There is no possibility to let the failed node join the
    cluster again without rebuilding it from scratch as a slave.  If
    at all possible, you would likely prefer to use <xref
    linkend="stmtmoveset"/> instead, as that does
    <emphasis>not</emphasis> abandon the failed node.
    </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtddlscript"><refmeta><refentrytitle>EXECUTE SCRIPT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>EXECUTE SCRIPT</refname>
    
    <refpurpose> Execute SQL/DDL script  </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>EXECUTE SCRIPT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Executes a script containing arbitrary SQL statements on
     all nodes that are subscribed to a set at a common controlled
     point within the replication transaction stream.</para>
    
    <para> The specified event origin must be the origin of the set.
    The script file must not contain any <command>START</command> or
    <command>COMMIT TRANSACTION</command> calls.  (This changes
    somewhat in &postgres; 8.0 once nested transactions, aka
    savepoints, are supported) In addition, non-deterministic DML
    statements (like updating a field with
    <function>CURRENT_TIMESTAMP</function>) must be avoided, since the
    data changes done by the script are explicitly not
    replicated. </para>

    <variablelist>
     <varlistentry><term><literal> SET ID = ival </literal></term>

      <listitem><para> The unique numeric ID number of the set
      affected by the script</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> FILENAME = '/path/to/file' </literal></term>
      
      <listitem><para> The name of the file containing the SQL script to
	execute.  This might be a relative path, relative to the location of
	the <application>slonik</application> instance you are running, or, preferably,
	an absolute path on the system where <application>slonik</application> is to run.</para>
       
       <para> The <emphasis>contents</emphasis> of the file are propagated as part of
	the event, so the file does not need to be accessible on any of the
	nodes.</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> EVENT NODE = ival </literal></term>
      <listitem><para> (Optional) The ID of the current origin of the set.  Default value is 1.</para></listitem>
      
     </varlistentry>
     <varlistentry><term><literal> EXECUTE ONLY ON = ival

       </literal></term><listitem><para> (Optional) The ID of the only
	node to actually execute the script.  This option causes the
	script to be propagated by all nodes but executed only by one.
	The default is to execute the script on all nodes that are
	subscribed to the set.</para></listitem> 
      
     </varlistentry>
    </variablelist>
    
    <para> See also the warnings in &rddlchanges;.</para>

    <para> Note that this is a &rlocking; operation, which means that
    it can get stuck behind other database activity.</para>
     
    <para> At the start of this event, all replicated tables are
    unlocked via the function
    <function>alterTableRestore(tab_id)</function>.  After the SQL
    script has run, they are returned to <quote>replicating
    state</quote> using
    <function>alterTableForReplication(tab_id)</function>.  This means
    that all of these tables are locked by this &slon; process for the
    duration of the SQL script execution.</para>

    <para> If a table's columns are modified, it is very important
    that the triggers be regenerated, otherwise they may be
    inappropriate for the new form of the table schema.</para>

    <para> Note that if you need to make reference to the cluster
    name, you can use the token <command>@CLUSTERNAME@</command>; if
    you need to make reference to the &slony1; namespace, you can use
    the token <command>@NAMESPACE@</command>; both will be expanded
    into the appropriate replacement tokens. </para>

    <para> This uses &funddlscript;. </para>
   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
EXECUTE SCRIPT (
   SET ID = 1,
   FILENAME = '/tmp/changes_2008-04-01.sql',
   EVENT NODE = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para> Up until the 2.0 branch, each replicated table received an
    exclusive lock, on the origin node, in order to remove the
    replication triggers; after the DDL script completes, those locks
    will be cleared. </para>  
  
    <para> After the DDL script has run on the origin node, it will
    then run on subscriber nodes, where replicated tables will be
    similarly altered to remove replication triggers, therefore
    requiring that exclusive locks be taken out on each node, in
    turn. </para>

    <para> As of the 2.0 branch, &slony1; uses a GUC that controls
    trigger behaviour, which allows deactivating the &slony1;-created
    triggers during this operation <emphasis>without</emphasis> the
    need to take out exclusive locks on all tables.  Now, the only
    tables requiring exclusive locks are those tables that are
    actually altered as a part of the DDL script. </para>  
  
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0. </para>

    <para> Before &slony1; version 1.2, the entire DDL script was
    submitted as one <function>PQexec()</function> request, with the
    implication that the <emphasis>entire</emphasis> script was parsed
    based on the state of the database before invokation of the
    script.  This means statements later in the script cannot depend
    on DDL changes made by earlier statements in the same script.
    Thus, you cannot add a column to a table and add constraints to
    that column later in the same request. </para>

    <para> In &slony1; version 1.2, the DDL script is split into
    statements, and each statement is submitted separately.  As a
    result, it is fine for later statements to refer to objects or
    attributes created or modified in earlier statements.
    Furthermore, in version 1.2, the <command>slonik</command> output
    includes a listing of each statement as it is processed, on the
    set origin node.  Similarly, the statements processed are listed
    in slon logs on the other nodes.</para>

    <para> In &slony1; version 1.0, this would only lock the tables in
    the specified replication set.  As of 1.1, <emphasis>all
    replicated tables</emphasis> are locked (<emphasis>e.g.</emphasis>
    - triggers are removed at the start, and restored at the end).
    This deals with the risk that one might request DDL changes on
    tables in multiple replication sets.</para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtupdatefunctions"><refmeta><refentrytitle>UPDATE FUNCTIONS</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>UPDATE FUNCTIONS</refname>
    
    <refpurpose> Reload stored functions </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>UPDATE FUNCTIONS (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Reloads stored functions for a node.</para>
    
    <para>Reloads all stored procedure and function definitions in the
    &slony1; schema for the specified node. This command is usually
    part of the &slony1; software upgrade procedure.
    </para>

     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       
       <listitem><para> The node to refresh.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
UPDATE FUNCTIONS (
    ID = 3        # Update functions on node 3
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
   <refsect1> <title> Oddities </title>

    <para> Any mismatch between <xref linkend="slonik"/> and the C
    libraries <quote>living</quote> in the &postgres; installation
    will result in this failing to do what is expected, and, more than
    likely, failing to run at all.  You may <emphasis>think</emphasis>
    you are upgrading to version 1.1.5, but if you are running <xref
    linkend="slonik"/> from version 1.1.2, or if you didn't restart the
    database with a version that has 1.1.5 libraries, and instead are
    referencing C stored functions from version 1.1.1, the attempt to
    upgrade will fail, because the sets of C functions have regularly
    changed between major versions.</para>

    <para> Before &slony1; 1.2, the error messages that would result
    would be not terribly informative; what you'd find, in &postgres;
    logs, is some error message about being unable to load some stored
    function that happens to be implemented in C.  As of 1.2, one of
    the first things done is to load a stored function to verify
    version numbers; it complains in a much more direct fashion if you
    have some versioning mismatch.  </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtwaitevent"><refmeta><refentrytitle>WAIT FOR EVENT</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>WAIT FOR EVENT</refname>
    
    <refpurpose> Have Slonik script wait for previous event to
    complete </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>WAIT FOR EVENT (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Waits for event Confirmation.</para>
    
    <para> <application>Slonik</application> remembers the last event
     generated on every node during script execution (events generated
     by earlier calls are currently not checked). In certain situations
     it is necessary that events generated on one node (such as
     <command>CREATE SET</command>) are processed on another node
     before issuing more commands (for instance, <xref
      linkend="stmtsubscribeset"/>).  <command>WAIT FOR EVENT</command> may be
     used to cause the <application>slonik</application> script to wait
     until the subscriber node is ready for the next action.
    </para>
    
    <para> <command>WAIT FOR EVENT</command> must be called outside of
    any <command>try</command> block in order to work, since new
    confirm messages don't become visible within a transaction.

     <variablelist>
      <varlistentry><term><literal> ORIGIN = ival | ALL </literal></term>
       <listitem><para> The origin of the event(s) to wait for.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> CONFIRMED = ival | ALL </literal></term>
       
       <listitem><para> The node ID of the receiver that must confirm the event(s).</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> WAIT ON = ival </literal></term>
       <listitem><para> The ID of the node where the &slconfirm; table
	 is to be checked.  The default value is 1.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> TIMEOUT = ival </literal></term>
       
       <listitem><para> The number of seconds to wait.  Default is 600
       (10 minutes).  <command>TIMEOUT = 0</command> causes the script
	 to wait indefinitely.</para></listitem>
       
      </varlistentry>
     </variablelist></para>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
WAIT FOR EVENT (
  ORIGIN = ALL,
  CONFIRMED = ALL,
  WAIT ON = 1
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.0 </para>
   </refsect1>
   
   <refsect1> <title> Oddities </title> <para> Not all events return
   interesting results.  For instance, many people have run afoul of
   problems with <xref linkend="stmtsubscribeset"/>, when subscribing a
   new set.  Be aware (and beware!) that a <xref
   linkend="stmtsubscribeset"/> request will return the event
   confirmation almost immediately, even though there might be several
   hours of work to do before the subscription is ready.  The trouble
   with <xref linkend="stmtsubscribeset"/> is that it is processed as
   <emphasis>two</emphasis> events, one on the origin node, with a
   second event, to enable the subscription, on the subscriber.
   </para>

   <para> In order to more reliably monitor from within a <xref
   linkend="slonik"/> script that <xref linkend="stmtsubscribeset"/> is
   complete, you may submit a <xref linkend="stmtsync"/> event after
   the subscription, and have the WAIT request wait on that
   <command>SYNC</command> event, as follows. </para>
    <programlisting>
     # Assuming that set 1 has direct subscribers 2 and 3
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 2);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2, WAIT FOR=1);
     SUBSCRIBE SET (ID = 999, PROVIDER = 1, RECEIVER = 3);
     SYNC (ID=1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 3, WAIT FOR=1);
     MERGE SET ( ID = 1, ADD ID = 999, ORIGIN = 1 );
    </programlisting>
   </refsect1>
   
  </refentry>

<!-- **************************************** -->

  <refentry id="stmtrepairconfig"><refmeta><refentrytitle>REPAIR CONFIG</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>REPAIR CONFIG</refname>
    
    <refpurpose> Resets the name-to-oid mapping of tables in a replication set, useful for restoring a node after a <application>pg_dump</application>. </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>REPAIR CONFIG (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Resets name-to-oid mapping.</para>
    
     <variablelist>
      <varlistentry><term><literal> SET ID = ival </literal></term>
       <listitem><para> Which set to clean up after.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EVENT NODE = ival </literal></term>
       
       <listitem><para> The node ID where this should be submitted.</para></listitem>
       
      </varlistentry>
      <varlistentry><term><literal> EXECUTE ONLY ON = ival </literal></term>

       <listitem><para> The ID of the only node where the mappings are
       to be updated.  If not specified, the default is to execute
       this on all nodes subscribed to the set.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
REPAIR CONFIG (
  SET ID = 1,
  EVENT NODE = 2
);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1 </para>
   </refsect1>
  </refentry>
<!-- **************************************** -->

  <refentry id="stmtsync"><refmeta><refentrytitle>SYNC</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>

   <refnamediv><refname>SYNC</refname>
    
    <refpurpose> Generate an ordinary SYNC event </refpurpose></refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>SYNC (options);</command>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    
    <para> Generates a SYNC event on a specified node.</para>
    
     <variablelist>
      <varlistentry><term><literal> ID = ival </literal></term>
       <listitem><para> The node on which to generate the SYNC event.</para></listitem>
       
      </varlistentry>
     </variablelist>

   </refsect1>
   <refsect1><title>Exemple</title>
    <programlisting>
     SUBSCRIBE SET (ID = 10, PROVIDER = 1, RECEIVER = 2);
     WAIT FOR EVENT (ORIGIN = 2, CONFIRMED = 1);
     SYNC (ID = 1);
     WAIT FOR EVENT (ORIGIN = 1, CONFIRMED = 2);
    </programlisting>
   </refsect1>
   <refsect1> <title> Utilisation de verrous </title>

    <para>  Aucun verouillage ne devrait être visible depuis l'application. </para>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1 </para>
   </refsect1>
  </refentry>

<!-- **************************************** -->
  
  <refentry id ="stmtsleep"><refmeta><refentrytitle>SLEEP</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>SLEEP</refname>
    
    <refpurpose> Sleep using system <function>sleep()</function> </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>sleep </command>
     <arg><replaceable class="parameter"> seconds</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Sleeps for the specified number of seconds.
    </para>
   </refsect1>
   <refsect1><Title>Example</Title>
    <programlisting>
     sleep (seconds = 5);
    </programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.1.6 / 1.2.1. </para>
   </refsect1>
  </refentry>

  <refentry id ="stmtcloneprepare"><refmeta><refentrytitle>CLONE PREPARE</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLONE PREPARE</refname>
    
    <refpurpose> Prepare for cloning a node. </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>clone prepare </command>
     <arg><replaceable class="parameter"> id</replaceable></arg>
     <arg><replaceable class="parameter"> provider</replaceable></arg>
     <arg><replaceable class="parameter"> comment</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Prepares for cloning a specified node.
    </para>

    <para>
     This duplicates the <quote>provider</quote> node's configuration
     under a new node ID in preparation for the node to be copied via
     standard database tools.
    </para>

    <para> Note that in order that we be certain that this new node be
    consistent with all nodes, it is important to issue a SYNC event
    against every node aside from the provider and wait to start
    copying the provider database at least until all those SYNC events
    have been confirmed by the provider.  Otherwise, it is possible
    for the clone to miss some events. </para>

   </refsect1>
   <refsect1><Title>Example</Title>
    <Programlisting>
     clone prepare (id = 33, provider = 22, comment='Clone 33');
     sync (id=11);
     sync (id=22);
     </Programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.2.0. </para>
   </refsect1>
  </refentry>


  <refentry id ="stmtclonefinish"><refmeta><refentrytitle>CLONE FINISH</refentrytitle>
   <manvolnum>7</manvolnum></refmeta>
   
   <refnamediv><refname>CLONE FINISH</refname>
    
    <refpurpose> Complete cloning a node. </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <cmdsynopsis>
     <command>clone prepare </command>
     <arg><replaceable class="parameter"> id</replaceable></arg>
     <arg><replaceable class="parameter"> provider</replaceable></arg>
    </cmdsynopsis>
   </refsynopsisdiv>
   <refsect1>
    <title>Description</title>
    <para>
     Finishes cloning a specified node.
    </para>

    <para>
     This completes the work done by <xref
     linkend="stmtcloneprepare"/>, establishing confirmation data for
     the new <quote>clone</quote> based on the status found for the
     <quote>provider</quote> node.
    </para>
   </refsect1>
   <refsect1><Title>Example</Title>
    <Programlisting>
     clone finish (id = 33, provider = 22);
    </Programlisting>
   </refsect1>
   <refsect1> <title> Note de version </title>
    <para> Cette commande fut introduite dans &slony1; 1.2.0. </para>
   </refsect1>
  </refentry>

  
 </reference>
